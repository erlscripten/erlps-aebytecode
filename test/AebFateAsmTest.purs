module Aeb.Fate.Asm.Test(erlps__test__0,
                         erlps__asm_disasm_files_test___0,
                         erlps__asm_disasm_idenity_test__0) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__asm_path__0 :: ErlangFun
erlps__asm_path__0 [] =
  let   
    arg_0 =
      toErl "aebytecode/test"
  in let arg_3 = toErl "asm_code"
  in
    BIF.do_remote_fun_call "Filename" "erlps__join__2" [arg_0, arg_3]
erlps__asm_path__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__file_path__1 :: ErlangFun
erlps__file_path__1 [file_0] =
  let    arg_2 = erlps__asm_path__0 []
  in let
    lop_1 =
      BIF.do_remote_fun_call "Filename" "erlps__join__2"
        [arg_2, file_0]
  in let rop_4 = toErl ".fate"
  in BIF.erlang__op_append [lop_1, rop_4]
erlps__file_path__1 [arg_5] = EXC.function_clause unit
erlps__file_path__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__read_file__1 :: ErlangFun
erlps__read_file__1 [file_0] =
  let    filepath_2 = erlps__file_path__1 [file_0]
  in let
    asm_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Asm" "erlps__read_file__1"
        [filepath_2]
  in asm_4
erlps__read_file__1 [arg_5] = EXC.function_clause unit
erlps__read_file__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assemble__1 :: ErlangFun
erlps__assemble__1 [asm_0] =
  BIF.do_remote_fun_call "Aeb.Fate.Asm" "erlps__asm_to_bytecode__2"
    [asm_0, ErlangEmptyList]
erlps__assemble__1 [arg_3] = EXC.function_clause unit
erlps__assemble__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__asm_disasm_idenity_test__0 :: ErlangFun
erlps__asm_disasm_idenity_test__0 [] =
  erlps__check_roundtrip__1 [ErlangAtom "identity"]
erlps__asm_disasm_idenity_test__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__asm_disasm_files_test___0 :: ErlangFun
erlps__asm_disasm_files_test___0 [] =
  let lcSrc_0 = erlps__sources__0 []
  in
    flmap
      (\ lc_2 ->
         let    arg_6 = toErl "~p"
         in let
           arg_5 =
             BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
               [arg_6, ErlangCons lc_2 ErlangEmptyList]
         in let
           tup_el_4 =
             BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_5]
         in let
           tup_el_10 =
             ErlangFun 0
               (let
                  lambda_11 [] = erlps__check_roundtrip__1 [lc_2]
                  lambda_11 [] = EXC.function_clause unit
                  lambda_11 args = EXC.badarity (ErlangFun 0 lambda_11) args
                in lambda_11)
         in let lcRet_3 = ErlangTuple [tup_el_4, tup_el_10]
         in ErlangCons lcRet_3 ErlangEmptyList)
      lcSrc_0
erlps__asm_disasm_files_test___0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__sources__0 :: ErlangFun
erlps__sources__0 [] =
  let    head_0 = toErl "arith"
  in let head_2 = toErl "bool"
  in let head_4 = toErl "comp"
  in let head_6 = toErl "jumpif"
  in let head_8 = toErl "map"
  in let head_10 = toErl "memory"
  in let head_12 = toErl "remote"
  in let head_14 = toErl "test"
  in let head_16 = toErl "tuple"
  in let head_18 = toErl "mapofmap"
  in let head_20 = toErl "immediates"
  in let head_22 = toErl "names"
  in let head_24 = toErl "oracles"
  in let head_26 = toErl "meta"
  in
    ErlangCons head_0
      (ErlangCons head_2
         (ErlangCons head_4
            (ErlangCons head_6
               (ErlangCons head_8
                  (ErlangCons head_10
                     (ErlangCons head_12
                        (ErlangCons head_14
                           (ErlangCons head_16
                              (ErlangCons head_18
                                 (ErlangCons head_20
                                    (ErlangCons head_22
                                       (ErlangCons head_24
                                          (ErlangCons head_26
                                             ErlangEmptyList)))))))))))))
erlps__sources__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__check_roundtrip__1 :: ErlangFun
erlps__check_roundtrip__1 [file_0] =
  let    assemblercode_2 = erlps__read_file__1 [file_0]
  in let matchExpr_6 = erlps__assemble__1 [assemblercode_2]
  in
    case matchExpr_6 of
      (ErlangTuple [_env_4, bytecode_5]) ->
        let   
          fatecode_8 =
            BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__deserialize__1"
              [bytecode_5]
        in let
          dissasmcode_10 =
            BIF.do_remote_fun_call "Aeb.Fate.Asm" "erlps__to_asm__1"
              [fatecode_8]
        in let matchExpr_14 = erlps__assemble__1 [dissasmcode_10]
        in
          case matchExpr_14 of
            (ErlangTuple [_env2_12, bytecode2_13]) ->
              let   
                bytecode3_16 =
                  BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__serialize__1"
                    [fatecode_8]
              in let
                code1_18 =
                  BIF.do_remote_fun_call "Aeb.Fate.Asm" "erlps__strip__1"
                    [bytecode_5]
              in let
                code2_20 =
                  BIF.do_remote_fun_call "Aeb.Fate.Asm" "erlps__strip__1"
                    [bytecode2_13]
              in let
                code3_22 =
                  BIF.do_remote_fun_call "Aeb.Fate.Asm" "erlps__strip__1"
                    [bytecode3_16]
              in let
                fun_23 =
                  ErlangFun 0
                    (let
                       lambda_24 [] =
                         case code2_20 of
                           __x_27 | __x_27 == code1_18 -> ErlangAtom "ok"
                           __v_28 ->
                             let   
                               head_32 =
                                 ErlangTuple
                                   [ErlangAtom "module",
                                    ErlangAtom "aeb_fate_asm_test"]
                             in let tup_el_38 = toErl 65
                             in let
                               head_36 =
                                 ErlangTuple [ErlangAtom "line", tup_el_38]
                             in let tup_el_42 = toErl "Code2"
                             in let
                               head_40 =
                                 ErlangTuple
                                   [ErlangAtom "expression", tup_el_42]
                             in let
                               head_44 =
                                 ErlangTuple [ErlangAtom "expected", code1_18]
                             in let
                               head_48 =
                                 ErlangTuple [ErlangAtom "value", __v_28]
                             in let
                               arg_29 =
                                 ErlangTuple
                                   [ErlangAtom "assertEqual",
                                    ErlangCons head_32
                                      (ErlangCons head_36
                                         (ErlangCons head_40
                                            (ErlangCons head_44
                                               (ErlangCons head_48
                                                  ErlangEmptyList))))]
                             in BIF.erlang__error__1 [arg_29]
                       lambda_24 [] = EXC.function_clause unit
                       lambda_24 args =
                         EXC.badarity (ErlangFun 0 lambda_24) args
                     in lambda_24)
                _ = BIF.erlang__apply__2 [fun_23, ErlangEmptyList]
              in let
                fun_52 =
                  ErlangFun 0
                    (let
                       lambda_53 [] =
                         case code3_22 of
                           __x_56 | __x_56 == code1_18 -> ErlangAtom "ok"
                           __v_57 ->
                             let   
                               head_61 =
                                 ErlangTuple
                                   [ErlangAtom "module",
                                    ErlangAtom "aeb_fate_asm_test"]
                             in let tup_el_67 = toErl 66
                             in let
                               head_65 =
                                 ErlangTuple [ErlangAtom "line", tup_el_67]
                             in let tup_el_71 = toErl "Code3"
                             in let
                               head_69 =
                                 ErlangTuple
                                   [ErlangAtom "expression", tup_el_71]
                             in let
                               head_73 =
                                 ErlangTuple [ErlangAtom "expected", code1_18]
                             in let
                               head_77 =
                                 ErlangTuple [ErlangAtom "value", __v_57]
                             in let
                               arg_58 =
                                 ErlangTuple
                                   [ErlangAtom "assertEqual",
                                    ErlangCons head_61
                                      (ErlangCons head_65
                                         (ErlangCons head_69
                                            (ErlangCons head_73
                                               (ErlangCons head_77
                                                  ErlangEmptyList))))]
                             in BIF.erlang__error__1 [arg_58]
                       lambda_53 [] = EXC.function_clause unit
                       lambda_53 args =
                         EXC.badarity (ErlangFun 0 lambda_53) args
                     in lambda_53)
              in BIF.erlang__apply__2 [fun_52, ErlangEmptyList]
            _ -> EXC.badmatch matchExpr_14
      _ -> EXC.badmatch matchExpr_6
erlps__check_roundtrip__1 [arg_81] = EXC.function_clause unit
erlps__check_roundtrip__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__test__0 :: ErlangFun
erlps__test__0 [] =
  BIF.do_remote_fun_call "Eunit" "erlps__test__1"
    [ErlangAtom "aeb_fate_asm_test"]
erlps__test__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args