module Aeb.Aevm.Abi(erlps__create_calldata__4,
                    erlps__check_calldata__3, erlps__function_type_info__4,
                    erlps__function_type_hash__3,
                    erlps__arg_typerep_from_function__2,
                    erlps__type_hash_from_function_name__2,
                    erlps__typereps_from_type_hash__2,
                    erlps__function_name_from_type_hash__2,
                    erlps__get_function_hash_from_calldata__1,
                    erlps__is_payable__2, erlps__abi_version__0) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.0.2
-}

import Prelude
import Data.Array as DA
import Data.List as DL
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as Tup
import Data.BigInt as DBI
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers as H
import Erlang.Exception as EXC
import Erlang.Type (ErlangFun, ErlangTerm(..), weakCmp, weakEq,
                    weakNEq, weakLt, weakLeq, weakGeq, weakGt)
import Effect (Effect)
import Effect.Unsafe (unsafePerformEffect)
import Effect.Exception (throw)
import Partial.Unsafe (unsafePartial)


erlps__abi_version__0 :: ErlangFun
erlps__abi_version__0 [] = (ErlangInt (DBI.fromInt 1))
erlps__abi_version__0 args =
  (EXC.badarity
     (ErlangFun 0 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__create_calldata__4 :: ErlangFun
erlps__create_calldata__4 [funname_0, args_1, argtypes0_2,
                           rettype_3]
  =
  let   
    argtypes_6 = (ErlangTuple [(ErlangAtom "tuple"), argtypes0_2])
  in let arg_7 = (BIF.erlang__list_to_binary__1 [funname_0])
  in let
    match_expr_15 =
      (erlps__function_type_hash__3 [arg_7, argtypes_6, rettype_3])
  in
    case match_expr_15 of
      (ErlangBinary bin_c_11) | size_12 <- ((DBI.fromInt 32))
                              , (BIN.Ok typehashint_14 bin_13) <-
                                  ((BIN.chop_int bin_c_11 size_12 8 BIN.Big
                                      BIN.Unsigned))
                              , (BIN.empty bin_13) ->
        let    tup_el_18 = (BIF.erlang__list_to_tuple__1 [args_1])
        in let arg_16 = (ErlangTuple [typehashint_14, tup_el_18])
        in let
          data_20 =
            (BIF.do_remote_fun_call "Aeb.Heap" "erlps__to_binary__1"
               [arg_16])
        in (ErlangTuple [(ErlangAtom "ok"), data_20])
      _ -> (EXC.badmatch match_expr_15)
erlps__create_calldata__4 [arg_23, arg_24, arg_25, arg_26] =
  (EXC.function_clause unit)
erlps__create_calldata__4 args =
  (EXC.badarity
     (ErlangFun 4 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__check_calldata__3 :: ErlangFun
erlps__check_calldata__3 [calldata_0, typeinfo_1, checkpayable_2]
  =
  let
    case_3 = (erlps__get_function_hash_from_calldata__1 [calldata_0])
  in
    case case_3 of
      (ErlangTuple [(ErlangAtom "ok"), hash_5]) ->
        (erlps__check_calldata__4
           [hash_5, calldata_0, typeinfo_1, checkpayable_2])
      (ErlangTuple [(ErlangAtom "error"), _what_10]) ->
        (ErlangTuple
           [(ErlangAtom "error"), (ErlangAtom "bad_call_data")])
      something_else -> (EXC.case_clause something_else)
erlps__check_calldata__3 [arg_13, arg_14, arg_15] =
  (EXC.function_clause unit)
erlps__check_calldata__3 args =
  (EXC.badarity
     (ErlangFun 3 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__check_calldata__4 :: ErlangFun
erlps__check_calldata__4 [hash_0, calldata_1, typeinfo_2,
                          (ErlangAtom "true")]
  =
  let case_3 = (erlps__is_payable__2 [hash_0, typeinfo_2])
  in
    case case_3 of
      (ErlangTuple [(ErlangAtom "ok"), (ErlangAtom "true")]) ->
        (erlps__check_calldata__4
           [hash_0, calldata_1, typeinfo_2, (ErlangAtom "false")])
      (ErlangTuple [(ErlangAtom "ok"), (ErlangAtom "false")]) ->
        (ErlangTuple
           [(ErlangAtom "error"), (ErlangAtom "function_is_not_payable")])
      err_12@(ErlangTuple [(ErlangAtom "error"), _]) -> err_12
      something_else -> (EXC.case_clause something_else)
erlps__check_calldata__4 [hash_0, calldata_1, typeinfo_2,
                          (ErlangAtom "false")]
  =
  let
    case_3 = (erlps__typereps_from_type_hash__2 [hash_0, typeinfo_2])
  in
    case case_3 of
      (ErlangTuple [(ErlangAtom "ok"), argtype_6, outtype_7]) ->
        (EXC.tryOfCatch
           (\ _ ->
              let
                arg_8 =
                  (ErlangTuple
                     [(ErlangAtom "tuple"),
                      (ErlangCons (ErlangAtom "word")
                         (ErlangCons argtype_6 ErlangEmptyList))])
              in
                (BIF.do_remote_fun_call "Aeb.Heap" "erlps__from_binary__2"
                   [arg_8, calldata_1]))
           (\ of_16 ->
              case of_16 of
                (ErlangTuple [(ErlangAtom "ok"), _something_19]) ->
                  let
                    tup_el_21 =
                      (ErlangTuple
                         [(ErlangAtom "tuple"),
                          (ErlangCons (ErlangAtom "word")
                             (ErlangCons argtype_6 ErlangEmptyList))])
                  in (ErlangTuple [(ErlangAtom "ok"), tup_el_21, outtype_7])
                (ErlangTuple [(ErlangAtom "error"), _]) ->
                  (ErlangTuple
                     [(ErlangAtom "error"), (ErlangAtom "bad_call_data")])
                something_else -> (EXC.try_clause something_else))
           (\ ex_17 ->
              case ex_17 of
                (ErlangTuple [_t_31, _e_32, _]) ->
                  (ErlangTuple
                     [(ErlangAtom "error"), (ErlangAtom "bad_call_data")])
                ex_18 -> (EXC.raise ex_18)))
      (ErlangTuple [(ErlangAtom "error"), _]) ->
        (ErlangTuple
           [(ErlangAtom "error"), (ErlangAtom "unknown_function")])
      something_else -> (EXC.case_clause something_else)
erlps__check_calldata__4 [arg_37, arg_38, arg_39, arg_40] =
  (EXC.function_clause unit)
erlps__check_calldata__4 args =
  (EXC.badarity
     (ErlangFun 4 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__get_function_hash_from_calldata__1 :: ErlangFun
erlps__get_function_hash_from_calldata__1 [calldata_0] =
  let   
    arg_2 =
      (ErlangTuple
         [(ErlangAtom "tuple"),
          (ErlangCons (ErlangAtom "word") ErlangEmptyList)])
  in let
    case_1 =
      (BIF.do_remote_fun_call "Aeb.Heap" "erlps__from_binary__2"
         [arg_2, calldata_0])
  in
    case case_1 of
      (ErlangTuple [(ErlangAtom "ok"), (ErlangTuple [hashint_8])]) ->
        let
          tup_el_10 =
            (ErlangBinary
               (BIN.from_int hashint_8 (ErlangInt (DBI.fromInt 32)) 8 BIN.Big))
        in (ErlangTuple [(ErlangAtom "ok"), tup_el_10])
      error_12@(ErlangTuple [(ErlangAtom "error"), _]) -> error_12
      something_else -> (EXC.case_clause something_else)
erlps__get_function_hash_from_calldata__1 [arg_13] =
  (EXC.function_clause unit)
erlps__get_function_hash_from_calldata__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__function_type_info__4 :: ErlangFun
erlps__function_type_info__4 [name_0, payable_1, argtypes_2,
                              outtype_3]
  =
  let   
    argtype_6 = (ErlangTuple [(ErlangAtom "tuple"), argtypes_2])
  in let
    tup_el_7 =
      (erlps__function_type_hash__3 [name_0, argtype_6, outtype_3])
  in let
    tup_el_13 =
      (BIF.do_remote_fun_call "Aeb.Heap" "erlps__to_binary__1"
         [argtype_6])
  in let
    tup_el_15 =
      (BIF.do_remote_fun_call "Aeb.Heap" "erlps__to_binary__1"
         [outtype_3])
  in
    (ErlangTuple [tup_el_7, name_0, payable_1, tup_el_13, tup_el_15])
erlps__function_type_info__4 [arg_17, arg_18, arg_19, arg_20] =
  (EXC.function_clause unit)
erlps__function_type_info__4 args =
  (EXC.badarity
     (ErlangFun 4 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__function_type_hash__3 :: ErlangFun
erlps__function_type_hash__3 [name_0, argtype_1, outtype_2]
  | ((ErlangAtom "true") ==
       (H.falsifyErrors (\ _ -> (BIF.erlang__is_binary__1 [name_0])))) =
  let   
    head_6 =
      (BIF.do_remote_fun_call "Aeb.Heap" "erlps__to_binary__1"
         [argtype_1])
  in let
    head_9 =
      (BIF.do_remote_fun_call "Aeb.Heap" "erlps__to_binary__1"
         [outtype_2])
  in let
    bin_12 =
      (BIF.erlang__iolist_to_binary__1
         [(ErlangCons name_0
             (ErlangCons head_6 (ErlangCons head_9 ErlangEmptyList)))])
  in let
    match_expr_16 =
      (BIF.do_remote_fun_call "Eblake2" "erlps__blake2b__2"
         [(ErlangInt (DBI.fromInt 32)), bin_12])
  in
    case match_expr_16 of
      (ErlangTuple [(ErlangAtom "ok"), hash_15]) -> hash_15
      _ -> (EXC.badmatch match_expr_16)
erlps__function_type_hash__3 [arg_18, arg_19, arg_20] =
  (EXC.function_clause unit)
erlps__function_type_hash__3 args =
  (EXC.badarity
     (ErlangFun 3 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__arg_typerep_from_function__2 :: ErlangFun
erlps__arg_typerep_from_function__2 [function_0, typeinfo_1] =
  let
    case_2 =
      (BIF.lists__keyfind__3
         [function_0, (ErlangInt (DBI.fromInt 2)), typeinfo_1])
  in
    case case_2 of
      (ErlangTuple [_typehash_6, function_7, argtypebin_8,
                    _outtypebin_9]) | (function_7 == function_0) ->
        (erlps__arg_typerep_from_type_binary__1 [argtypebin_8])
      (ErlangTuple [_typehash_11, function_12, _payable_13,
                    argtypebin_14, _outtypebin_15]) | (function_12 ==
                                                         function_0) ->
        (erlps__arg_typerep_from_type_binary__1 [argtypebin_14])
      (ErlangAtom "false") ->
        (ErlangTuple
           [(ErlangAtom "error"), (ErlangAtom "unknown_function")])
      something_else -> (EXC.case_clause something_else)
erlps__arg_typerep_from_function__2 [arg_19, arg_20] =
  (EXC.function_clause unit)
erlps__arg_typerep_from_function__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__arg_typerep_from_type_binary__1 :: ErlangFun
erlps__arg_typerep_from_type_binary__1 [argtbin_0] =
  let
    case_1 =
      (BIF.do_remote_fun_call "Aeb.Heap" "erlps__from_binary__2"
         [(ErlangAtom "typerep"), argtbin_0])
  in
    case case_1 of
      (ErlangTuple [(ErlangAtom "ok"), argt_4]) ->
        (ErlangTuple [(ErlangAtom "ok"), argt_4])
      (ErlangTuple [(ErlangAtom "error"), _]) ->
        (ErlangTuple
           [(ErlangAtom "error"), (ErlangAtom "bad_type_data")])
      something_else -> (EXC.case_clause something_else)
erlps__arg_typerep_from_type_binary__1 [arg_9] =
  (EXC.function_clause unit)
erlps__arg_typerep_from_type_binary__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__typereps_from_type_hash__2 :: ErlangFun
erlps__typereps_from_type_hash__2 [typehash_0, typeinfo_1] =
  let
    case_2 =
      (BIF.lists__keyfind__3
         [typehash_0, (ErlangInt (DBI.fromInt 1)), typeinfo_1])
  in
    case case_2 of
      (ErlangTuple [typehash_6, _function_7, argtypebin_8,
                    outtypebin_9]) | (typehash_6 == typehash_0) ->
        (erlps__typereps_from_type_binaries__2
           [argtypebin_8, outtypebin_9])
      (ErlangTuple [typehash_12, _function_13, _payable_14,
                    argtypebin_15, outtypebin_16]) | (typehash_12 ==
                                                        typehash_0) ->
        (erlps__typereps_from_type_binaries__2
           [argtypebin_15, outtypebin_16])
      (ErlangAtom "false") ->
        (ErlangTuple
           [(ErlangAtom "error"), (ErlangAtom "unknown_function")])
      something_else -> (EXC.case_clause something_else)
erlps__typereps_from_type_hash__2 [arg_21, arg_22] =
  (EXC.function_clause unit)
erlps__typereps_from_type_hash__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__typereps_from_type_binaries__2 :: ErlangFun
erlps__typereps_from_type_binaries__2 [argtbin_0, outtbin_1] =
  let   
    tup_el_3 =
      (BIF.do_remote_fun_call "Aeb.Heap" "erlps__from_binary__2"
         [(ErlangAtom "typerep"), argtbin_0])
  in let
    tup_el_6 =
      (BIF.do_remote_fun_call "Aeb.Heap" "erlps__from_binary__2"
         [(ErlangAtom "typerep"), outtbin_1])
  in let case_2 = (ErlangTuple [tup_el_3, tup_el_6])
  in
    case case_2 of
      (ErlangTuple [(ErlangTuple [(ErlangAtom "ok"), argt_9]),
                    (ErlangTuple [(ErlangAtom "ok"), outt_10])]) ->
        (ErlangTuple [(ErlangAtom "ok"), argt_9, outt_10])
      (ErlangTuple [_, _]) ->
        (ErlangTuple
           [(ErlangAtom "error"), (ErlangAtom "bad_type_data")])
      something_else -> (EXC.case_clause something_else)
erlps__typereps_from_type_binaries__2 [arg_16, arg_17] =
  (EXC.function_clause unit)
erlps__typereps_from_type_binaries__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__function_name_from_type_hash__2 :: ErlangFun
erlps__function_name_from_type_hash__2 [typehash_0, typeinfo_1] =
  let
    case_2 =
      (BIF.lists__keyfind__3
         [typehash_0, (ErlangInt (DBI.fromInt 1)), typeinfo_1])
  in
    case case_2 of
      (ErlangTuple [typehash_6, function_7, _argtypebin_8,
                    _outtypebin_9]) | (typehash_6 == typehash_0) ->
        (ErlangTuple [(ErlangAtom "ok"), function_7])
      (ErlangTuple [typehash_12, function_13, _payable_14,
                    _argtypebin_15, _outtypebin_16]) | (typehash_12 ==
                                                          typehash_0) ->
        (ErlangTuple [(ErlangAtom "ok"), function_13])
      (ErlangAtom "false") ->
        (ErlangTuple
           [(ErlangAtom "error"), (ErlangAtom "unknown_function")])
      something_else -> (EXC.case_clause something_else)
erlps__function_name_from_type_hash__2 [arg_21, arg_22] =
  (EXC.function_clause unit)
erlps__function_name_from_type_hash__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__type_hash_from_function_name__2 :: ErlangFun
erlps__type_hash_from_function_name__2 [name_0, typeinfo_1] =
  let
    case_2 =
      (BIF.lists__keyfind__3
         [name_0, (ErlangInt (DBI.fromInt 2)), typeinfo_1])
  in
    case case_2 of
      (ErlangTuple [typehash_6, name_7, _argtypebin_8,
                    _outtypebin_9]) | (name_7 == name_0) ->
        (ErlangTuple [(ErlangAtom "ok"), typehash_6])
      (ErlangTuple [typehash_12, name_13, _payable_14, _argtypebin_15,
                    _outtypebin_16]) | (name_13 == name_0) ->
        (ErlangTuple [(ErlangAtom "ok"), typehash_12])
      (ErlangAtom "false") ->
        (ErlangTuple
           [(ErlangAtom "error"), (ErlangAtom "unknown_function")])
      something_else -> (EXC.case_clause something_else)
erlps__type_hash_from_function_name__2 [arg_21, arg_22] =
  (EXC.function_clause unit)
erlps__type_hash_from_function_name__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__is_payable__2 :: ErlangFun
erlps__is_payable__2 [typehash_0, typeinfo_1] =
  let
    case_2 =
      (BIF.lists__keyfind__3
         [typehash_0, (ErlangInt (DBI.fromInt 1)), typeinfo_1])
  in
    case case_2 of
      (ErlangTuple [typehash_6, _function_7, _argtypebin_8,
                    _outtypebin_9]) | (typehash_6 == typehash_0) ->
        (ErlangTuple [(ErlangAtom "ok"), (ErlangAtom "true")])
      (ErlangTuple [typehash_12, _function_13, payable_14,
                    _argtypebin_15, _outtypebin_16]) | (typehash_12 ==
                                                          typehash_0) ->
        (ErlangTuple [(ErlangAtom "ok"), payable_14])
      (ErlangAtom "false") ->
        (ErlangTuple
           [(ErlangAtom "error"), (ErlangAtom "unknown_function")])
      something_else -> (EXC.case_clause something_else)
erlps__is_payable__2 [arg_21, arg_22] =
  (EXC.function_clause unit)
erlps__is_payable__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)