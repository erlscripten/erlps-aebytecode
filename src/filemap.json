{
"aebytecode/test/asm_code/remote.fate":
";; CONTRACT remote\nFUNCTION add_five(integer):integer\n ADD a 5 arg0\n RETURN\n"
,"aebytecode/test/asm_code/names.fate":
";; CONTRACT names\n\nFUNCTION preclaim(address, {bytes, 32}) : {tuple, []}\n  AENS_PRECLAIM #AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== arg0 arg1\n  RETURNR {}\n\nFUNCTION claim(address, string, integer, integer) : {tuple, []}\n  AENS_CLAIM #AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== arg0 arg1 arg2 arg3\n  RETURNR {}\n\nFUNCTION transfer(address, address, {bytes, 32}) : {tuple, []}\n  AENS_TRANSFER #AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== arg0 arg1 arg2\n  RETURNR {}\n\nFUNCTION revoke(address, {bytes, 32}) : {tuple, []}\n  AENS_REVOKE #AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== arg0 arg1\n  RETURNR {}\n\nFUNCTION resolve(string, string) : {variant, [{tuple, []}, {tuple, [address]}]}\n  AENS_RESOLVE a arg0 arg1 'address\n  RETURN\n"
,"aebytecode/test/asm_code/immediates.fate":
";; CONTRACT immediates\n\nFUNCTION integer() : integer\n         RETURNR 42\n\nFUNCTION neg_integer() : integer\n         RETURNR -2374683271468723648732648736498712634876147\n\nFUNCTION hex_integer() : integer\n         RETURNR 0x0deadbeef0\n\nFUNCTION bool() : boolean\n         RETURNR true\n\nFUNCTION bool_f() : boolean\n         RETURNR false\n\nFUNCTION string() : string\n         RETURNR \"Hello\"\n\nFUNCTION map() : {map, integer, boolean}\n         RETURNR {}\n\nFUNCTION map2() : {map, integer, boolean}\n         RETURNR {1 => true}\n\nFUNCTION map3() : {map, integer, boolean}\n         RETURNR {1 => true,\n                  2 => false}\n\nFUNCTION map4() : {map, integer, {map, string, boolean}}\n         RETURNR {1 => { \"foo\" => true, \"bar\" => false},\n                  2 => {},\n                  3 => { \"foo\" => false}}\n\nFUNCTION nil() : {list, integer}\n         RETURNR []\n\nFUNCTION list1() : {list, integer}\n         RETURNR [1]\n\nFUNCTION list2() : {list, integer}\n         RETURNR [1, 2]\n\n\nFUNCTION no_bits() : bits\n         RETURNR <>\n\nFUNCTION all_bits() : bits\n         RETURNR !<>\n\nFUNCTION some_bits() : bits\n         RETURNR <101010>\n\nFUNCTION many_bits() : bits\n         RETURNR !<010101>\n\nFUNCTION group_bits() : bits\n         RETURNR <1010 1010 0011 1001>\n\nFUNCTION unit() : {tuple, []}\n         RETURNR ()\n\nFUNCTION tuple() : {tuple, [integer, boolean, string, {tuple, [integer, integer]}]}\n         RETURNR (42, true, \"FooBar\", (1, 2))\n\n\nFUNCTION address() : address\n         RETURNR @ak_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv\n\nFUNCTION oracle() : oracle\n         RETURNR @ok_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv\n\nFUNCTION contract() : contract\n         RETURNR @ct_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv\n\nFUNCTION channel() : channel\n         RETURNR @ch_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv\n\n;; Option(integer) = NONE | SOME(integer)\nFUNCTION variant_none() : {variant, [{tuple, []}, {tuple, [integer]}]}\n         RETURNR (| [0,1] | 0 | () |)\n\n;; Option(integer) = NONE | SOME(integer)\nFUNCTION variant_some() : {variant, [{tuple, []}, {tuple, [integer]}]}\n         RETURNR (| [0,1] | 1 | (42) |)\n"
,"aebytecode/test/asm_code/comp.fate":
";; CONTRACT comp\n\nFUNCTION lt(integer, integer) : boolean\n  LT a arg0 arg1\n  RETURN\n\nFUNCTION gt(integer, integer) : boolean\n  GT a arg0 arg1\n  RETURN\n\nFUNCTION egt(integer, integer) : boolean\n  EGT a arg0 arg1\n  RETURN\n\nFUNCTION elt(integer, integer) : boolean\n  ELT a arg0 arg1\n  RETURN\n\nFUNCTION eq(integer, integer) : boolean\n  EQ a arg0 arg1\n  RETURN\n\nFUNCTION neq(integer, integer) : boolean\n  NEQ a arg0 arg1\n  RETURN\n\n"
,"aebytecode/test/asm_code/arith.fate":
";; CONTRACT arith\n\nFUNCTION add (integer, integer) : integer\n  ADD a arg0 arg1\n  RETURN\n\nFUNCTION sub (integer, integer) : integer\n  SUB a arg0 arg1\n  RETURN\n\nFUNCTION mul (integer, integer) : integer\n  MUL a arg0 arg1\n  RETURN\n\nFUNCTION div (integer, integer) : integer\n  DIV a arg0 arg1\n  RETURN\n\nFUNCTION mod (integer, integer) : integer\n  MOD a arg0 arg1\n  RETURN\n\nFUNCTION pow (integer, integer) : integer\n  POW a arg0 arg1\n  RETURN\n\n"
,"aebytecode/test/asm_code/identity.fate":
";; CONTRACT: Identity\nFUNCTION id(integer) ->  integer\n  RETURN\n\n;; Test the code from the shell\n;; _build/default/rel/aessembler/bin/aessembler console\n\n;; aeb_aefa:file(\"../../../../test/asm_code/identity.fate\", []).\n"
,"aebytecode/test/asm_code/tuple.fate":
"FUNCTION make_0tuple():{tuple, []}\n;; BB : 0\n  TUPLE   a 0\n  RETURN\n\nFUNCTION make_2tuple(integer, integer):{tuple, [integer, integer]}\n;; BB : 0\n  PUSH       arg0\n  PUSH       arg1\n  TUPLE       a 2\n  RETURN\n\nFUNCTION make_5tuple(integer, integer, integer, integer, integer):\n                {tuple, [integer, integer, integer, integer, integer]}\n;; BB : 0\n  PUSH       arg0\n  PUSH       arg1\n  PUSH       arg2\n  PUSH       arg3\n  PUSH       arg4\n  TUPLE       a 5\n  RETURN\n\nFUNCTION element1(integer, integer): integer\n;; BB : 0\n  PUSH            arg0\n  PUSH            arg1\n  TUPLE            a 2\n  ELEMENT        a 1 a\n  RETURN\n\nFUNCTION element({tuple, [integer, integer]}, integer): integer\n;; BB : 0\n  ELEMENT  a arg1 arg0\n  RETURN\n"
,"aebytecode/test/asm_code/jumpif.fate":
";; CONTRACT jumpif\nFUNCTION skip(integer, integer) : integer\n;; BB : 0\n  PUSH arg1\n  PUSH 0\n  EQ a a arg0\n  JUMPIF a 2\n;; BB : 1\n  INCA\n  JUMP 2\n  RETURN\n"
,"aebytecode/test/asm_code/bool.fate":
";; CONTRACT bool\n\nFUNCTION and(boolean, boolean) : boolean\n         AND a arg0 arg1\n         RETURN\n\nFUNCTION or(boolean, boolean) : boolean\n         OR a arg0 arg1\n         RETURN\n\nFUNCTION not(boolean) : boolean\n         NOT a arg0\n         RETURN\n\n"
,"aebytecode/test/asm_code/oracles.fate":
";; CONTRACT oracles\n\nFUNCTION register (address, integer, {variant, [{tuple, [integer]}, {tuple, [integer]}]}) : oracle\n  ORACLE_REGISTER a #AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== arg0 arg1 arg2 'string '{variant, [{tuple, []}, {tuple, [integer]}]}\n  RETURN\n\nFUNCTION query (oracle, integer, string) : oracle_query\n  ORACLE_QUERY a arg0 arg1 arg2 (| [1,1] | 0 | (100) |) (| [1,1] | 0 | (100) |) 'string '{variant, [{tuple, []}, {tuple, [integer]}]}\n  RETURN\n\nFUNCTION bogus_query () : oracle_query\n  RETURNR @oq_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv\n\nFUNCTION respond (oracle, integer, string) : {tuple, []}\n  ORACLE_RESPOND #AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== arg0 arg1 arg2 'string '{variant, [{tuple, []}, {tuple, [integer]}]}\n  RETURNR {}\n\nFUNCTION extend (oracle, {variant, [{tuple, [integer]}, {tuple, [integer]}]}) : {tuple, []}\n  ORACLE_EXTEND #AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== arg0 arg1\n  RETURNR {}\n\nFUNCTION get_question (oracle, oracle_query) : string\n  ORACLE_GET_QUESTION a arg0 arg1 'string '{variant, [{tuple, []}, {tuple, [integer]}]}\n  RETURN\n\nFUNCTION get_answer (oracle, oracle_query) : {variant, [{tuple, []}, {tuple, [string]}]}\n  ORACLE_GET_ANSWER a arg1 arg2 'string '{variant, [{tuple, []}, {tuple, [integer]}]}\n  RETURN\n\nFUNCTION query_fee (oracle) : integer\n  ORACLE_QUERY_FEE a arg0\n  RETURN\n"
,"aebytecode/test/asm_code/memory.fate":
";; CONTRACT memory\nFUNCTION call(integer):integer\n  STORE var1 arg0\n  PUSH  0\n  CALL  \"write\"\n  PUSH  var1\n  RETURN\n\nFUNCTION write(integer):integer\n  STORE    var1 arg0\n  RETURNR  var1\n\nFUNCTION dest_add(integer, integer): integer\n  STORE var1 arg0\n  STORE var2 arg1\n  ADD   var3 var1 var2\n  PUSH  var3\n  RETURN\n\nFUNCTION dest_add_imm(integer):integer\n  STORE var1 arg0\n  ADD   var3 var1 2\n  PUSH  var3\n  RETURN\n\nFUNCTION dest_add_stack(integer, integer): integer\n  STORE var1 arg0\n  PUSH  arg1\n  ADD   var3 var1 a\n  PUSH  var3\n  RETURN\n"
,"aebytecode/test/asm_code/map.fate":
";; CONTRACT map\nFUNCTION make_empty_map():{map, integer, boolean}\n  MAP_EMPTY a\n  RETURN\n\nFUNCTION map_update({map, integer, boolean}, integer, boolean):{map, integer, boolean}\n  MAP_UPDATE a arg0 arg1 arg2\n  RETURN\n\nFUNCTION map_lookup({map, integer, boolean}, integer):boolean\n  MAP_LOOKUP a arg0 arg1\n  RETURN\n\nFUNCTION map_lookup_default({map, integer, boolean}, integer): boolean\n  MAP_LOOKUPD a arg0 arg1 false\n  RETURN\n\nFUNCTION map_member({map, integer, boolean}, integer):boolean\n  MAP_MEMBER a arg0 arg1\n  RETURN\n\nFUNCTION map_delete({map, integer, boolean}, integer):{map, integer, boolean}\n  MAP_DELETE a arg0 arg1\n  RETURN\n\nFUNCTION map_member({map, integer, boolean}, integer) : boolean\n        MAP_MEMBER a arg0 arg1\n        RETURN\n\nFUNCTION map_from_list({list, {tuple, [integer, boolean]}}) : {map, integer, boolean}\n        MAP_FROM_LIST a arg0\n        RETURN\n\n"
,"aebytecode/test/asm_code/all_instructions.fate":
";; CONTRACT all_instructions\n\n;; Dont expect this contract to typecheck or run.\n;; Just used to check assembler roundtrip of all instructions.\n\nFUNCTION foo () : {tuple, []}\n  RETURN\n\n  RETURNR a\n\n  CALL \"foo\"\n\n  CALL_R arg125 foo 0\n\n  CALL_T \"foo\"\n\n  CALL_TR arg245 foo 4711\n\n  CALL_GTR arg245 foo 0 100\n\n  CALL_GR arg245 foo 0 4711\n\n  JUMP 5514251025295783441695716053282666408426\n\n  JUMPIF arg196 0x12c651665\n\n  SWITCH_V2 a 63 33\n\n  SWITCH_V3 var4 0x1d61723dd 79 7\n\n  SWITCH_VN arg0 [1, 2, 3]\n\n  PUSH var80\n\n  DUPA\n\n  DUP a\n\n  POP a\n\n  STORE arg183 var225\n\n  INCA\n\n  INC a\n\n  DECA\n\n  DEC a\n\n  ADD a a a\n\n  SUB arg35 arg165 var74\n\n  MUL 44 35 \"foo\"\n\n  DIV 263838340369912686645632650718169038811 a a\n\n  MOD var113 arg80 arg207\n\n  POW a a a\n\n  LT a 78 var81\n\n  GT arg19 4729414120208894485838100532547810615352 var175\n\n  EQ 85 a arg164\n\n  ELT a arg226 a\n\n  EGT a 1 var250\n\n  NEQ a a a\n\n  AND var255 0x294a24f6 var189\n\n  OR (| [2,0] | 0 | ( (), (42) ) |) arg168 var107\n\n  NOT arg124 a\n\n  TUPLE var999 5019186157739257888756115213149493826410\n\n  ELEMENT arg148 var25 a\n\n  MAP_EMPTY a\n\n  MAP_LOOKUP a a a\n\n  MAP_LOOKUPD var112 arg35 a var112\n\n  MAP_UPDATE false a a a\n\n  MAP_DELETE arg180 a var1\n\n  MAP_MEMBER a { true => 4} 94\n\n  MAP_FROM_LIST () a\n\n  MAP_TO_LIST a { true => 4 }\n\n  MAP_SIZE a { true => 42 }\n\n  NIL arg91\n\n  IS_NIL a var6\n\n  CONS arg185 \"foo\" a\n\n  HD a var124\n\n  TL arg223 a\n\n  LENGTH var216 a\n\n  APPEND { 203961992615221001243597889146034217896 => 0x1f53a1843} 281217554184165828643225535776787296845 a\n\n  STR_JOIN a a 7144184027126178769820155907121270843348\n\n  INT_TO_STR var238 a\n\n  ADDR_TO_STR a arg216\n\n  STR_REVERSE a @ak_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv\n\n  STR_LENGTH a \"foo\"\n\n  INT_TO_ADDR arg127 var207\n\n  VARIANT a a 0x1f7b72200 a\n\n  VARIANT_TEST a arg217 a\n\n  VARIANT_ELEMENT a arg103 arg108\n\n  BITS_NONEA\n\n  BITS_NONE a\n\n  BITS_ALLA\n\n  BITS_ALL a\n\n  BITS_ALL_N a arg135\n\n  BITS_SET arg150 a { 0x1a715e2a6 => 3}\n\n  BITS_CLEAR arg98 a arg164\n\n  BITS_TEST a a (| [0,0,3] | 2 | (1, \"foo\", ()) |)\n\n  BITS_SUM a a\n\n  BITS_OR var20 var186 a\n\n  BITS_AND a 4 arg203\n\n  BITS_DIFF var200 arg247 var20\n\n  ADDRESS a\n\n  BALANCE a\n\n  ORIGIN arg216\n\n  CALLER a\n\n  GASPRICE arg119\n\n  BLOCKHASH a arg110\n\n  CALL_VALUE a\n\n  BENEFICIARY var163\n\n  TIMESTAMP a\n\n  GENERATION 242795038229506961431398379342231049652\n\n  MICROBLOCK arg43\n\n  DIFFICULTY var24\n\n  GASLIMIT arg220\n\n  GAS var35\n\n  LOG0 a\n\n  LOG1 arg86 arg208\n\n  LOG2 a a (| [0,1,3] | 2 | (1, \"foo\", ()) |)\n\n  LOG3 arg15 arg211 var139 arg44\n\n  LOG4 a a 9 a a\n\n  DEACTIVATE\n\n  SPEND @ak_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv var136\n\n  ORACLE_REGISTER arg29 48 ((| [0,1,3] | 2 | (1, \"foo\", ()) |)) arg65 { <> => false} <>\n\n  ORACLE_QUERY\n\n  ORACLE_RESPOND\n\n  ORACLE_EXTEND\n\n  ORACLE_GET_ANSWER\n\n  ORACLE_GET_QUESTION\n\n  ORACLE_QUERY_FEE\n\n  AENS_RESOLVE\n\n  AENS_PRECLAIM\n\n  AENS_CLAIM\n\n  AENS_UPDATE\n\n  AENS_TRANSFER\n\n  AENS_REVOKE\n\n  ECRECOVER_SECP256K1\n\n  VERIFY_SIG\n\n  VERIFY_SIG_SECP256K1\n\n  ECVERIFY_SECP256K1\n\n  SHA3 a\n\n  SHA256 a\n\n  BLAKE2B a\n\n  ABORT a\n\n  EXIT var120\n\n  NOP\n\n  RETURNR ()\n\n  BALANCE_OTHER a arg0\n\n  SETELEMENT a 2 (1, \"two\", 3) 2\n\n  AUTH_TX_HASH\n\n  CONTRACT_TO_ADDRESS @ct_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv\n\n  IS_ORACLE @ak_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv\n\n  IS_CONTRACT @ak_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv\n\n  IS_PAYABLE @ak_nv5B93FPzRHrGNmMdTDfGdd5xGZvep3MVSpJqzcQmMp59bBCv\n"
,"aebytecode/test/asm_code/mapofmap.fate":
";; CONTRACT mapofmap\nFUNCTION map() : {map, integer, {map, string, boolean}}\n         RETURNR {1 => { \"foo\" => true, \"bar\" => false},\n                  2 => {},\n                  3 => { \"foo\" => false}}\n\n\n"
,"aebytecode/test/asm_code/identity.aesm":
";; CONTRACT: Identity\n\n             PUSH1              0\n             CALLDATALOAD\n\n             DUP1\n             ;; Should be the hash of\n             ;; the signature of the\n             ;; first function (use 0 as placeholder)\n             PUSH32             0x0000000000000000000000000000\n             EQ\n             PUSH32             id_entry\n             JUMPI              \n\n             STOP\n\nid_entry:    JUMPDEST\n             ;; Skip the function name in the calldata\n             PUSH1              32\n             ;; Load argument on stack                               \n             CALLDATALOAD\n             ;; This function only takes one immidiate as argument.\n\n             ;; Call the local version of the function\n             ;; Get return address\n             PC\n             PUSH1              39\n             ADD\n             ;; Get Argument\n             SWAP1\n             PUSH32             id_local\n             JUMP\n\n\n             ;; return here from local call\n             ;; Store top of stack at mem[0]\n             JUMPDEST\n             PUSH1              0\n             MSTORE\n             ;; Return mem[0]-mem[32] \n             PUSH1             32\n             PUSH1              0\n             RETURN\n\n             ;; for local calls\n             ;; Stack:\n             ;; |        |\n             ;; | Arg    | <- SP\n             ;; | RetAdr |\n             ;;    ...\n\nid_local:    JUMPDEST\n\n             ;; Just return the argument\n             SWAP1\n             ;; Stack:\n             ;; |        |\n             ;; | RetAdr | <- SP\n             ;; | RetVal | (Arg in this case)\n             ;;    ...\n             \n             JUMP\n\n;; Test the code from the shell\n;; aevm_eeevm:eval(aevm_eeevm_state:init(#{ exec => #{ code => list_to_binary(aeb_asm:file(\"apps/aesophia/test/contracts/identity.aesm\", [])), address => 0, caller => 0, data => <<0:256, 42:256>>, gas => 1000000, gasPrice => 1, origin => 0, value => 0 }, env => #{currentCoinbase => 0, currentDifficulty => 0, currentGasLimit => 10000, currentNumber => 0, currentTimestamp => 0}, pre => #{}}, #{})).\n\n;; Test the code from the shell with tracing.\n;; aevm_eeevm:eval(aevm_eeevm_state:init(#{ exec => #{ code => aeb_asm:file(\"apps/aesophia/test/contracts/identity.aesm\", []), address => 0, caller => 0, data => <<0:256, 42:256>>, gas => 1000000, gasPrice => 1, origin => 0, value => 0 }, env => #{currentCoinbase => 0, currentDifficulty => 0, currentGasLimit => 10000, currentNumber => 0, currentTimestamp => 0}, pre => #{}}, #{ trace => true})).\n\n\n;; Test the code from the shell with tracing.\n;; aevm_eeevm:eval(aevm_eeevm_state:init(#{ exec => #{ code => aeb_asm:file(\"apps/aesophia/test/contracts/identity.aesm\", [pp_tokens, pp_opcodes, pp_patched_code, pp_hex_string]), address => 0, caller => 0, data => <<0:256, 42:256>>, gas => 1000000, gasPrice => 1, origin => 0, value => 0}, env => #{currentCoinbase => 0, currentDifficulty => 0, currentGasLimit => 10000, currentNumber => 0, currentTimestamp => 0}, pre => #{}}, #{ trace => true})).\n\n;; aec_conductor:stop_mining().\n"
,"aebytecode/test/asm_code/test.fate":
";; CONTRACT: Test\nFUNCTION id(integer) -> integer\n  RETURN\n\nFUNCTION jumps() -> integer\n  PUSH 0\n  JUMP 3\n  NOP\n  JUMP 2\n  NOP\n  RETURN\n  NOP\n  JUMP 1\n\nFUNCTION inc(integer) -> integer\n  INCA\n  INCA\n  RETURN\n\nFUNCTION call(integer) -> integer\n  INCA\n  CALL \"inc\"\n  INCA\n  RETURN\n\n\nFUNCTION tailcall(integer) -> integer\n  INCA\n  CALL_T \"inc\"\n\n;; FUNCTION remote_call(integer) : integer\n;;   PUSH arg0\n;;   CALL_R remote.add_five {tuple, [integer]} integer 0    ;; typereps don't parse\n;;   INCA\n;;   RETURN\n\n;; Test the code from the shell\n;; _build/default/rel/aessembler/bin/aessembler console\n\n;; aeb_aefa:file(\"../../../../test/asm_code/test.fate\", []).\n;; f(Asm), f(Env), f(BC), Asm = aefa_asm:read_file(\"../../../../test/asm_code/test.fate\"), {Env, BC} = aefa_asm:asm_to_bytecode(Asm, []), aefa_asm:bytecode_to_fate_code(BC, []).\n"
,"/":null}
