module Aeb.Asm(erlps__file__2, erlps__pp__1,
               erlps__to_hexstring__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__pp__1 :: ErlangFun
erlps__pp__1 [asm_0] =
  let    listing_2 = erlps__format__1 [asm_0]
  in let arg_3 = toErl "~s~n"
  in
    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
      [arg_3, ErlangCons listing_2 ErlangEmptyList]
erlps__pp__1 [arg_7] = EXC.function_clause unit
erlps__pp__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format__1 :: ErlangFun
erlps__format__1 [asm_0] =
  let arg_2 = toErl 0
  in erlps__format__2 [asm_0, arg_2]
erlps__format__1 [arg_3] = EXC.function_clause unit
erlps__format__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format__2 :: ErlangFun
erlps__format__2 [(ErlangCons (ErlangTuple [(ErlangAtom "comment"),
                                            comment_0]) rest_1),
                  address_2]
  =
  let    lop_3 = toErl ";; "
  in let lop_7 = toErl "\n"
  in let rop_8 = erlps__format__2 [rest_1, address_2]
  in let rop_6 = BIF.erlang__op_append [lop_7, rop_8]
  in let rop_4 = BIF.erlang__op_append [comment_0, rop_6]
  in BIF.erlang__op_append [lop_3, rop_4]
erlps__format__2 [(ErlangCons mnemonic_0 rest_1), address_2] =
  let   
    op_4 =
      BIF.do_remote_fun_call "Aeb.Opcodes" "erlps__m_to_op__1"
        [mnemonic_0]
  in let rop_8 = toErl 96
  in let lop_6 = BIF.erlang__op_greaterEq [op_4, rop_8]
  in let
    case_5 =
      case lop_6 of
        (ErlangAtom "false") -> ErlangAtom "false"
        (ErlangAtom "true") ->
          let rop_10 = toErl 127
          in BIF.erlang__op_lesserEq [op_4, rop_10]
        _ -> EXC.badarg1 lop_6
  in
    case case_5 of
      (ErlangAtom "true") ->
        let   
          lop_11 =
            BIF.do_remote_fun_call "Aeb.Opcodes" "erlps__op_size__1" [op_4]
        in let rop_13 = toErl 1
        in let arity_14 = BIF.erlang__op_minus [lop_11, rop_13]
        in let matchExpr_19 = erlps__get_args__2 [arity_14, rest_1]
        in
          case matchExpr_19 of
            (ErlangTuple [args_17, code_18]) ->
              let    lop_20 = toErl "        "
              in let lop_22 = BIF.erlang__atom_to_list__1 [mnemonic_0]
              in let lop_25 = toErl "        "
              in let lop_29 = toErl "\n"
              in let lop_33 = BIF.erlang__op_plus [address_2, arity_14]
              in let rop_36 = toErl 1
              in let arg_32 = BIF.erlang__op_plus [lop_33, rop_36]
              in let rop_30 = erlps__format__2 [code_18, arg_32]
              in let rop_28 = BIF.erlang__op_append [lop_29, rop_30]
              in let rop_26 = BIF.erlang__op_append [args_17, rop_28]
              in let rop_24 = BIF.erlang__op_append [lop_25, rop_26]
              in let rop_21 = BIF.erlang__op_append [lop_22, rop_24]
              in BIF.erlang__op_append [lop_20, rop_21]
            _ -> EXC.badmatch matchExpr_19
      (ErlangAtom "false") ->
        let    lop_37 = toErl "        "
        in let lop_39 = BIF.erlang__atom_to_list__1 [mnemonic_0]
        in let lop_42 = toErl "\n"
        in let rop_47 = toErl 1
        in let arg_45 = BIF.erlang__op_plus [address_2, rop_47]
        in let rop_43 = erlps__format__2 [rest_1, arg_45]
        in let rop_41 = BIF.erlang__op_append [lop_42, rop_43]
        in let rop_38 = BIF.erlang__op_append [lop_39, rop_41]
        in BIF.erlang__op_append [lop_37, rop_38]
      something_else -> EXC.case_clause something_else
erlps__format__2 [(ErlangEmptyList), _] = ErlangEmptyList
erlps__format__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__format__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_args__2 :: ErlangFun
erlps__get_args__2 [(ErlangInt num_0), (ErlangCons arg_1 code_2)]
  | (ErlangInt num_0) == (toErl 1) =
  let tup_el_3 = BIF.erlang__integer_to_list__1 [arg_1]
  in ErlangTuple [tup_el_3, code_2]
erlps__get_args__2 [n_0, (ErlangCons arg_1 code_2)] =
  let    rop_5 = toErl 1
  in let arg_3 = BIF.erlang__op_minus [n_0, rop_5]
  in let matchExpr_9 = erlps__get_args__2 [arg_3, code_2]
  in
    case matchExpr_9 of
      (ErlangTuple [args_7, rest_8]) ->
        let    lop_11 = BIF.erlang__integer_to_list__1 [arg_1]
        in let lop_14 = toErl ", "
        in let rop_13 = BIF.erlang__op_append [lop_14, args_7]
        in let tup_el_10 = BIF.erlang__op_append [lop_11, rop_13]
        in ErlangTuple [tup_el_10, rest_8]
      _ -> EXC.badmatch matchExpr_9
erlps__get_args__2 [arg_17, arg_18] = EXC.function_clause unit
erlps__get_args__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__file__2 :: ErlangFun
erlps__file__2 [filename_0, options_1] =
  let
    matchExpr_4 =
      BIF.do_remote_fun_call "File" "erlps__read_file__1" [filename_0]
  in
    case matchExpr_4 of
      (ErlangTuple [(ErlangAtom "ok"), file_3]) ->
        let    arg_5 = BIF.erlang__binary_to_list__1 [file_3]
        in let
          matchExpr_8 =
            BIF.do_remote_fun_call "Aeb.Asm.Scan" "erlps__scan__1" [arg_5]
        in
          case matchExpr_8 of
            (ErlangTuple [(ErlangAtom "ok"), tokens_7, _]) ->
              let   
                case_9 =
                  BIF.do_remote_fun_call "Proplists" "erlps__lookup__2"
                    [ErlangAtom "pp_tokens", options_1]
              in let
                _ =
                  case case_9 of
                    (ErlangTuple [(ErlangAtom "pp_tokens"),
                                  (ErlangAtom "true")]) ->
                      let arg_12 = toErl "Tokens ~p~n"
                      in
                        BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                          [arg_12, ErlangCons tokens_7 ErlangEmptyList]
                    (ErlangAtom "none") -> ErlangAtom "ok"
                    something_else -> EXC.case_clause something_else
              in let arg_17 = toErl 0
              in let arg_18 = ErlangMap Map.empty
              in let
                bytelist_21 =
                  erlps__to_bytecode__5
                    [tokens_7, arg_17, arg_18, ErlangEmptyList, options_1]
              in let
                case_22 =
                  BIF.do_remote_fun_call "Proplists" "erlps__lookup__2"
                    [ErlangAtom "pp_hex_string", options_1]
              in let
                _ =
                  case case_22 of
                    (ErlangTuple [(ErlangAtom "pp_hex_string"),
                                  (ErlangAtom "true")]) ->
                      let    arg_25 = toErl "Code: ~s~n"
                      in let head_27 = erlps__to_hexstring__1 [bytelist_21]
                      in
                        BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                          [arg_25, ErlangCons head_27 ErlangEmptyList]
                    (ErlangAtom "none") -> ErlangAtom "ok"
                    something_else -> EXC.case_clause something_else
              in BIF.erlang__list_to_binary__1 [bytelist_21]
            _ -> EXC.badmatch matchExpr_8
      _ -> EXC.badmatch matchExpr_4
erlps__file__2 [arg_31, arg_32] = EXC.function_clause unit
erlps__file__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_hexstring__1 :: ErlangFun
erlps__to_hexstring__1 [bytelist_0] =
  let    lop_1 = toErl "0x"
  in let
    arg_3 =
      flmap
        (\ lc_6 ->
           let    arg_8 = toErl "~2.16.0b"
           in let
             lcRet_7 =
               BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                 [arg_8, ErlangCons lc_6 ErlangEmptyList]
           in ErlangCons lcRet_7 ErlangEmptyList)
        bytelist_0
  in let
    rop_2 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_3]
  in BIF.erlang__op_append [lop_1, rop_2]
erlps__to_hexstring__1 [arg_12] = EXC.function_clause unit
erlps__to_hexstring__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_bytecode__5 :: ErlangFun
erlps__to_bytecode__5 [(ErlangCons (ErlangTuple [(ErlangAtom "mnemonic"),
                                                 _line_0, op_1]) rest_2),
                       address_3, env_4, code_5, opts_6]
  =
  let   
    opcode_8 =
      BIF.do_remote_fun_call "Aeb.Opcodes" "erlps__m_to_op__1" [op_1]
  in let
    opsize_10 =
      BIF.do_remote_fun_call "Aeb.Opcodes" "erlps__op_size__1"
        [opcode_8]
  in let arg_12 = BIF.erlang__op_plus [address_3, opsize_10]
  in
    erlps__to_bytecode__5
      [rest_2, arg_12, env_4, ErlangCons opcode_8 code_5, opts_6]
erlps__to_bytecode__5 [(ErlangCons (ErlangTuple [(ErlangAtom "int"),
                                                 _line_0, int_1]) rest_2),
                       address_3, env_4, code_5, opts_6]
  =
  erlps__to_bytecode__5
    [rest_2, address_3, env_4, ErlangCons int_1 code_5, opts_6]
erlps__to_bytecode__5 [(ErlangCons (ErlangTuple [(ErlangAtom "hash"),
                                                 _line_0, hash_1]) rest_2),
                       address_3, env_4, code_5, opts_6]
  =
  erlps__to_bytecode__5
    [rest_2, address_3, env_4, ErlangCons hash_1 code_5, opts_6]
erlps__to_bytecode__5 [(ErlangCons (ErlangTuple [(ErlangAtom "id"),
                                                 _line_0, id_1]) rest_2),
                       address_3, env_4, code_5, opts_6]
  =
  let head_11 = ErlangTuple [ErlangAtom "ref", id_1]
  in
    erlps__to_bytecode__5
      [rest_2, address_3, env_4, ErlangCons head_11 code_5, opts_6]
erlps__to_bytecode__5 [(ErlangCons (ErlangTuple [(ErlangAtom "label"),
                                                 _line_0, label_1]) rest_2),
                       address_3, env_4, code_5, opts_6]
  =
  let    mapExt_13 = ErlangMap (Map.singleton label_1 address_3)
  in let arg_9 = BIF.maps__merge__2 [env_4, mapExt_13]
  in
    erlps__to_bytecode__5 [rest_2, address_3, arg_9, code_5, opts_6]
erlps__to_bytecode__5 [(ErlangEmptyList), _address_0, env_1,
                       code_2, opts_3]
  =
  let   
    case_4 =
      BIF.do_remote_fun_call "Proplists" "erlps__lookup__2"
        [ErlangAtom "pp_opcodes", opts_3]
  in let
    _ =
      case case_4 of
        (ErlangTuple [(ErlangAtom "pp_opcodes"), (ErlangAtom "true")]) ->
          let    arg_7 = toErl "opcodes ~p~n"
          in let
            head_9 =
              BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [code_2]
          in
            BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
              [arg_7, ErlangCons head_9 ErlangEmptyList]
        (ErlangAtom "none") -> ErlangAtom "ok"
        something_else -> EXC.case_clause something_else
  in let
    patchedcode_15 =
      erlps__resolve_refs__3 [code_2, env_1, ErlangEmptyList]
  in let
    case_16 =
      BIF.do_remote_fun_call "Proplists" "erlps__lookup__2"
        [ErlangAtom "pp_patched_code", opts_3]
  in let
    _ =
      case case_16 of
        (ErlangTuple [(ErlangAtom "pp_patched_code"),
                      (ErlangAtom "true")]) ->
          let arg_19 = toErl "Patched Code: ~p~n"
          in
            BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
              [arg_19, ErlangCons patchedcode_15 ErlangEmptyList]
        (ErlangAtom "none") -> ErlangAtom "ok"
        something_else -> EXC.case_clause something_else
  in erlps__expand_args__1 [patchedcode_15]
erlps__to_bytecode__5 [arg_24, arg_25, arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__to_bytecode__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__resolve_refs__3 :: ErlangFun
erlps__resolve_refs__3 [(ErlangCons (ErlangTuple [(ErlangAtom "ref"),
                                                  id_0]) rest_1),
                        env_2, code_3]
  =
  let address_6 = BIF.maps__get__2 [id_0, env_2]
  in
    erlps__resolve_refs__3
      [rest_1, env_2, ErlangCons address_6 code_3]
erlps__resolve_refs__3 [(ErlangCons op_0 rest_1), env_2, code_3]
  =
  erlps__resolve_refs__3 [rest_1, env_2, ErlangCons op_0 code_3]
erlps__resolve_refs__3 [(ErlangEmptyList), _env_0, code_1] =
  code_1
erlps__resolve_refs__3 [arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__resolve_refs__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expand_args__1 :: ErlangFun
erlps__expand_args__1 [(ErlangCons op_0 (ErlangCons arg_1 rest_2))]
  | (weakGeq op_0 (toErl 96)) && (weakLeq op_0 (toErl 127)) =
  let   
    lop_4 =
      BIF.do_remote_fun_call "Aeb.Opcodes" "erlps__op_size__1" [op_0]
  in let rop_6 = toErl 1
  in let lop_3 = BIF.erlang__op_minus [lop_4, rop_6]
  in let rop_7 = toErl 8
  in let bitsize_8 = BIF.erlang__op_mult [lop_3, rop_7]
  in let
    bin_16 =
      BIN.concatErl
        (flmap
           (\ lc_13 ->
              let
                lcRet_14 = ErlangBinary (BIN.fromInt lc_13 bitsize_8 1 BIN.Big)
              in ErlangCons lcRet_14 ErlangEmptyList)
           (ErlangCons arg_1 ErlangEmptyList))
  in let argbytelist_18 = BIF.erlang__binary_to_list__1 [bin_16]
  in let rop_22 = erlps__expand_args__1 [rest_2]
  in BIF.erlang__op_append [ErlangCons op_0 argbytelist_18, rop_22]
erlps__expand_args__1 [(ErlangCons op_0 rest_1)] =
  let tail_3 = erlps__expand_args__1 [rest_1]
  in ErlangCons op_0 tail_3
erlps__expand_args__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__expand_args__1 [arg_0] = EXC.function_clause unit
erlps__expand_args__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args