module Getopt(erlps__parse__2, erlps__check__2,
              erlps__parse_and_check__2, erlps__format_error__2,
              erlps__usage__2, erlps__usage__3, erlps__usage__4,
              erlps__usage__6, erlps__tokenize__1,
              erlps__usage_cmd_line__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__parse_and_check__2 :: ErlangFun
erlps__parse_and_check__2 [optspeclist_0, cmdline_1]
  | ((isEList optspeclist_0) && (isEList cmdline_1)) =
  let case_2 = erlps__parse__2 [optspeclist_0, cmdline_1]
  in
    case case_2 of
      result_6@(ErlangTuple [(ErlangAtom "ok"),
                             (ErlangTuple [opts_5, _])]) ->
        let case_7 = erlps__check__2 [optspeclist_0, opts_5]
        in
          case case_7 of
            (ErlangAtom "ok") -> result_6
            error_10 -> error_10
      error_11 -> error_11
erlps__parse_and_check__2 [arg_12, arg_13] =
  EXC.function_clause unit
erlps__parse_and_check__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__check__2 :: ErlangFun
erlps__check__2 [optspeclist_0, parsedopts_1]
  | ((isEList optspeclist_0) && (isEList parsedopts_1)) =
  EXC.tryCatch
    (\ _ ->
       let   
         requiredopts_13 =
           flmap
             (\ lc_5 ->
                case lc_5 of
                  (ErlangTuple [name_3, _, _, arg_4, _]) ->
                    let    op_arg_8 = BIF.erlang__is_tuple__1 [arg_4]
                    in let lop_7 = BIF.erlang__not__1 [op_arg_8]
                    in let
                      cond_6 =
                        case lop_7 of
                          (ErlangAtom "false") -> ErlangAtom "false"
                          (ErlangAtom "true") ->
                            BIF.erlang__op_exactNeq
                              [arg_4, ErlangAtom "undefined"]
                          _ -> EXC.badarg1 lop_7
                    in
                      case cond_6 of
                        (ErlangAtom "true") -> ErlangCons name_3 ErlangEmptyList
                        _ -> ErlangEmptyList
                  _ -> ErlangEmptyList)
             optspeclist_0
       in let
         arg_14 =
           ErlangFun 1
             (let
                lambda_15 [option_17] =
                  let
                    case_18 =
                      BIF.do_remote_fun_call "Proplists" "erlps__is_defined__2"
                        [option_17, parsedopts_1]
                  in
                    case case_18 of
                      (ErlangAtom "true") -> ErlangAtom "ok"
                      (ErlangAtom "false") ->
                        let   
                          tup_el_23 =
                            ErlangTuple
                              [ErlangAtom "missing_required_option", option_17]
                        in let
                          arg_21 = ErlangTuple [ErlangAtom "error", tup_el_23]
                        in BIF.erlang__throw__1 [arg_21]
                      something_else -> EXC.case_clause something_else
                lambda_15 [arg_16] = EXC.function_clause unit
                lambda_15 args = EXC.badarity (ErlangFun 1 lambda_15) args
              in lambda_15)
       in
         BIF.do_remote_fun_call "Lists" "erlps__foreach__2"
           [arg_14, requiredopts_13])
    (\ ex_28 ->
       case ex_28 of
         (ErlangTuple [_, error_30, _]) -> error_30
         ex_29 -> EXC.raise ex_29)
erlps__check__2 [arg_31, arg_32] = EXC.function_clause unit
erlps__check__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse__2 :: ErlangFun
erlps__parse__2 [optspeclist_0, cmdline_1] | isEList cmdline_1 =
  EXC.tryCatch
    (\ _ ->
       let   
         args_5 =
           case ErlangAtom "true" of
             _ | ((ErlangAtom "true") ==
                    (falsifyErrors
                       (\ _ ->
                          let arg_2 = BIF.erlang__hd__1 [cmdline_1]
                          in BIF.erlang__is_integer__1 [arg_2]))) ->
               erlps__tokenize__1 [cmdline_1]
             _ -> cmdline_1
       in let arg_9 = toErl 0
       in
         erlps__parse__5
           [optspeclist_0, ErlangEmptyList, ErlangEmptyList, arg_9, args_5])
    (\ ex_12 ->
       case ex_12 of
         (ErlangTuple [(ErlangAtom "throw"),
                       error_16@(ErlangTuple [(ErlangAtom "error"),
                                              (ErlangTuple [_reason_14,
                                                            _data_15])]),
                       _]) ->
           error_16
         ex_13 -> EXC.raise ex_13)
erlps__parse__2 [arg_17, arg_18] = EXC.function_clause unit
erlps__parse__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse__5 :: ErlangFun
erlps__parse__5 [optspeclist_0, optacc_1, argacc_2, _argpos_3,
                 (ErlangCons (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangEmptyList))) tail_6)]
  | ((ErlangInt num_4) == (toErl 45))
  , ((ErlangInt num_5) == (toErl 45)) =
  let   
    arg_10 =
      erlps__append_default_options__2 [optspeclist_0, optacc_1]
  in let
    tup_el_9 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [arg_10]
  in let tup_el_13 = BIF.lists__reverse__2 [argacc_2, tail_6]
  in let tup_el_8 = ErlangTuple [tup_el_9, tup_el_13]
  in ErlangTuple [ErlangAtom "ok", tup_el_8]
erlps__parse__5 [optspeclist_0, optacc_1, argacc_2, argpos_3,
                 (ErlangCons optstr_7@(ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) optarg_6)) tail_8)]
  | ((ErlangInt num_4) == (toErl 45))
  , ((ErlangInt num_5) == (toErl 45)) =
  erlps__parse_long_option__7
    [optspeclist_0, optacc_1, argacc_2, argpos_3, tail_8, optstr_7,
     optarg_6]
erlps__parse__5 [optspeclist_0, optacc_1, argacc_2, argpos_3,
                 (ErlangCons optstr_7@(ErlangCons (ErlangInt num_4) optarg_6@(ErlangCons _char_5 _)) tail_8)]
  | ((ErlangInt num_4) == (toErl 45)) =
  erlps__parse_short_option__7
    [optspeclist_0, optacc_1, argacc_2, argpos_3, tail_8, optstr_7,
     optarg_6]
erlps__parse__5 [optspeclist_0, optacc_1, argacc_2, argpos_3,
                 (ErlangCons arg_4 tail_5)]
  =
  let
    case_6 = erlps__find_non_option_arg__2 [optspeclist_0, argpos_3]
  in
    case case_6 of
      (ErlangTuple [(ErlangAtom "value"), optspec_9]) | ((ErlangAtom
                                                            "true") ==
                                                           (falsifyErrors
                                                              (\ _ ->
                                                                 let   
                                                                   lop_10 =
                                                                     BIF.erlang__tuple_size__1
                                                                       [optspec_9]
                                                                 in let
                                                                   rop_12 =
                                                                     toErl 5
                                                                 in
                                                                   BIF.erlang__op_exactEq
                                                                     [lop_10,
                                                                      rop_12]))) ->
        let   
          arg_14 =
            erlps__add_option_with_arg__3 [optspec_9, arg_4, optacc_1]
        in let rop_21 = toErl 1
        in let arg_19 = BIF.erlang__op_plus [argpos_3, rop_21]
        in
          erlps__parse__5 [optspeclist_0, arg_14, argacc_2, arg_19, tail_5]
      (ErlangAtom "false") ->
        erlps__parse__5
          [optspeclist_0, optacc_1, ErlangCons arg_4 argacc_2, argpos_3,
           tail_5]
      something_else -> EXC.case_clause something_else
erlps__parse__5 [optspeclist_0, optacc_1, argacc_2, _argpos_3,
                 (ErlangEmptyList)]
  =
  let   
    arg_7 =
      erlps__append_default_options__2 [optspeclist_0, optacc_1]
  in let
    tup_el_6 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [arg_7]
  in let
    tup_el_10 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [argacc_2]
  in let tup_el_5 = ErlangTuple [tup_el_6, tup_el_10]
  in ErlangTuple [ErlangAtom "ok", tup_el_5]
erlps__parse__5 [arg_12, arg_13, arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__parse__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format_error__2 :: ErlangFun
erlps__format_error__2 [optspeclist_0,
                        (ErlangTuple [(ErlangAtom "error"), reason_1])]
  =
  erlps__format_error__2 [optspeclist_0, reason_1]
erlps__format_error__2 [optspeclist_0,
                        (ErlangTuple [(ErlangAtom "missing_required_option"),
                                      name_1])]
  =
  let    arg_4 = toErl 1
  in let
    case_2 = BIF.lists__keyfind__3 [name_1, arg_4, optspeclist_0]
  in let
    optstr_47 =
      case case_2 of
        (ErlangTuple [name_6, (ErlangAtom "undefined"),
                      (ErlangAtom "undefined"), _type_7, _help_8]) | (name_6 ==
                                                                        name_1) ->
          let    head_9 = toErl "<"
          in let head_11 = erlps__to_string__1 [name_1]
          in let head_14 = toErl ">"
          in
            ErlangCons head_9
              (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))
        (ErlangTuple [_name_16, (ErlangAtom "undefined"), long_17,
                      _type_18, _help_19]) ->
          let head_20 = toErl "--"
          in ErlangCons head_20 (ErlangCons long_17 ErlangEmptyList)
        (ErlangTuple [_name_24, short_25, (ErlangAtom "undefined"),
                      _type_26, _help_27]) ->
          let head_28 = toErl "-"
          in ErlangCons head_28 (ErlangCons short_25 ErlangEmptyList)
        (ErlangTuple [_name_32, short_33, long_34, _type_35,
                      _help_36]) ->
          let    head_37 = toErl "-"
          in let head_41 = toErl " ("
          in let head_45 = toErl ")"
          in
            ErlangCons head_37
              (ErlangCons short_33
                 (ErlangCons head_41
                    (ErlangCons long_34 (ErlangCons head_45 ErlangEmptyList))))
        something_else -> EXC.case_clause something_else
  in let head_49 = toErl "missing required option: "
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatten__1"
      [ErlangCons head_49 (ErlangCons optstr_47 ErlangEmptyList)]
erlps__format_error__2 [_optspeclist_0,
                        (ErlangTuple [(ErlangAtom "invalid_option"), optstr_1])]
  =
  let    head_3 = toErl "invalid option: "
  in let head_5 = erlps__to_string__1 [optstr_1]
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatten__1"
      [ErlangCons head_3 (ErlangCons head_5 ErlangEmptyList)]
erlps__format_error__2 [_optspeclist_0,
                        (ErlangTuple [(ErlangAtom "invalid_option_arg"),
                                      (ErlangTuple [name_1, arg_2])])]
  =
  let    head_4 = toErl "option \'"
  in let lop_7 = erlps__to_string__1 [name_1]
  in let rop_9 = toErl "\' has invalid argument: "
  in let head_6 = BIF.erlang__op_append [lop_7, rop_9]
  in let head_11 = erlps__to_string__1 [arg_2]
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatten__1"
      [ErlangCons head_4
         (ErlangCons head_6 (ErlangCons head_11 ErlangEmptyList))]
erlps__format_error__2 [_optspeclist_0,
                        (ErlangTuple [(ErlangAtom "invalid_option_arg"),
                                      optstr_1])]
  =
  let    head_3 = toErl "invalid option argument: "
  in let head_5 = erlps__to_string__1 [optstr_1]
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatten__1"
      [ErlangCons head_3 (ErlangCons head_5 ErlangEmptyList)]
erlps__format_error__2 [_optspeclist_0,
                        (ErlangTuple [reason_1, data_2])]
  =
  let    head_4 = erlps__to_string__1 [reason_1]
  in let head_7 = toErl " "
  in let head_9 = erlps__to_string__1 [data_2]
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatten__1"
      [ErlangCons head_4
         (ErlangCons head_7 (ErlangCons head_9 ErlangEmptyList))]
erlps__format_error__2 [arg_12, arg_13] =
  EXC.function_clause unit
erlps__format_error__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_long_option__7 :: ErlangFun
erlps__parse_long_option__7 [optspeclist_0, optacc_1, argacc_2,
                             argpos_3, args_4, optstr_5, optarg_6]
  =
  let case_7 = erlps__split_assigned_arg__1 [optarg_6]
  in
    case case_7 of
      (ErlangTuple [long_9, arg_10]) ->
        erlps__parse_long_option_assigned_arg__8
          [optspeclist_0, optacc_1, argacc_2, argpos_3, args_4, optstr_5,
           long_9, arg_10]
      long_19 ->
        let    arg_22 = toErl 3
        in let
          case_20 = BIF.lists__keyfind__3 [long_19, arg_22, optspeclist_0]
        in
          case case_20 of
            (ErlangTuple [name_24, _short_25, long_26,
                          (ErlangAtom "undefined"), _help_27]) | (long_26 ==
                                                                    long_19) ->
              erlps__parse__5
                [optspeclist_0, ErlangCons name_24 optacc_1, argacc_2, argpos_3,
                 args_4]
            optspec_40@(ErlangTuple [_name_35, _short_36, long_37,
                                     _argspec_38, _help_39]) | (long_37 ==
                                                                  long_19) ->
              erlps__parse_long_option_next_arg__6
                [optspeclist_0, optacc_1, argacc_2, argpos_3, args_4,
                 optspec_40]
            (ErlangAtom "false") ->
              let   
                tup_el_49 = ErlangTuple [ErlangAtom "invalid_option", optstr_5]
              in let arg_47 = ErlangTuple [ErlangAtom "error", tup_el_49]
              in BIF.erlang__throw__1 [arg_47]
            something_else -> EXC.case_clause something_else
erlps__parse_long_option__7 [arg_52, arg_53, arg_54, arg_55,
                             arg_56, arg_57, arg_58]
  =
  EXC.function_clause unit
erlps__parse_long_option__7 args =
  EXC.badarity (ErlangFun 7 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_long_option_assigned_arg__8 :: ErlangFun
erlps__parse_long_option_assigned_arg__8 [optspeclist_0,
                                          optacc_1, argacc_2, argpos_3, args_4,
                                          optstr_5, long_6, arg_7]
  =
  let    arg_10 = toErl 3
  in let
    case_8 = BIF.lists__keyfind__3 [long_6, arg_10, optspeclist_0]
  in
    case case_8 of
      optspec_17@(ErlangTuple [_name_12, _short_13, long_14,
                               argspec_15, _help_16]) | (long_14 == long_6) ->
        case argspec_15 of
          (ErlangAtom "undefined") ->
            let   
              tup_el_21 =
                ErlangTuple [ErlangAtom "invalid_option_arg", optstr_5]
            in let arg_19 = ErlangTuple [ErlangAtom "error", tup_el_21]
            in BIF.erlang__throw__1 [arg_19]
          _ ->
            let
              arg_25 =
                erlps__add_option_with_assigned_arg__3
                  [optspec_17, arg_7, optacc_1]
            in
              erlps__parse__5
                [optspeclist_0, arg_25, argacc_2, argpos_3, args_4]
      (ErlangAtom "false") ->
        let   
          tup_el_34 = ErlangTuple [ErlangAtom "invalid_option", optstr_5]
        in let arg_32 = ErlangTuple [ErlangAtom "error", tup_el_34]
        in BIF.erlang__throw__1 [arg_32]
      something_else -> EXC.case_clause something_else
erlps__parse_long_option_assigned_arg__8 [arg_37, arg_38, arg_39,
                                          arg_40, arg_41, arg_42, arg_43,
                                          arg_44]
  =
  EXC.function_clause unit
erlps__parse_long_option_assigned_arg__8 args =
  EXC.badarity (ErlangFun 8 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__split_assigned_arg__1 :: ErlangFun
erlps__split_assigned_arg__1 [optstr_0] =
  erlps__split_assigned_arg__3
    [optstr_0, optstr_0, ErlangEmptyList]
erlps__split_assigned_arg__1 [arg_4] = EXC.function_clause unit
erlps__split_assigned_arg__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__split_assigned_arg__3 :: ErlangFun
erlps__split_assigned_arg__3 [_optstr_0,
                              (ErlangCons (ErlangInt num_1) tail_2), acc_3]
  | ((ErlangInt num_1) == (toErl 61)) =
  let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_3]
  in ErlangTuple [tup_el_4, tail_2]
erlps__split_assigned_arg__3 [optstr_0,
                              (ErlangCons char_1 tail_2), acc_3]
  =
  erlps__split_assigned_arg__3
    [optstr_0, tail_2, ErlangCons char_1 acc_3]
erlps__split_assigned_arg__3 [optstr_0, (ErlangEmptyList),
                              _acc_1]
  =
  optstr_0
erlps__split_assigned_arg__3 [arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__split_assigned_arg__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_long_option_next_arg__6 :: ErlangFun
erlps__parse_long_option_next_arg__6 [optspeclist_0, optacc_1,
                                      argacc_2, argpos_3, args_4,
                                      optspec_10@(ErlangTuple [name_5, _short_6,
                                                               _long_7,
                                                               argspec_8,
                                                               _help_9])]
  =
  let    argspectype_12 = erlps__arg_spec_type__1 [argspec_8]
  in let lop_14 = BIF.erlang__op_exactEq [args_4, ErlangEmptyList]
  in let
    case_13 =
      case lop_14 of
        (ErlangAtom "true") -> ErlangAtom "true"
        (ErlangAtom "false") ->
          let arg_18 = BIF.erlang__hd__1 [args_4]
          in erlps__is_implicit_arg__2 [argspectype_12, arg_18]
        _ -> EXC.badarg1 lop_14
  in
    case case_13 of
      (ErlangAtom "true") ->
        let
          arg_21 =
            erlps__add_option_with_implicit_arg__2 [optspec_10, optacc_1]
        in
          erlps__parse__5
            [optspeclist_0, arg_21, argacc_2, argpos_3, args_4]
      (ErlangAtom "false") ->
        case args_4 of
          (ErlangCons arg_27 tail_28) ->
            EXC.tryCatch
              (\ _ ->
                 let    tup_el_34 = erlps__to_type__2 [argspectype_12, arg_27]
                 in let head_32 = ErlangTuple [name_5, tup_el_34]
                 in
                   erlps__parse__5
                     [optspeclist_0, ErlangCons head_32 optacc_1, argacc_2,
                      argpos_3, tail_28])
              (\ ex_42 ->
                 case ex_42 of
                   (ErlangTuple [(ErlangAtom "error"), _, _]) ->
                     let    tup_el_48 = ErlangTuple [name_5, arg_27]
                     in let
                       tup_el_46 =
                         ErlangTuple
                           [ErlangAtom "invalid_option_arg", tup_el_48]
                     in let arg_44 = ErlangTuple [ErlangAtom "error", tup_el_46]
                     in BIF.erlang__throw__1 [arg_44]
                   ex_43 -> EXC.raise ex_43)
          _ -> EXC.badmatch args_4
      something_else -> EXC.case_clause something_else
erlps__parse_long_option_next_arg__6 [arg_51, arg_52, arg_53,
                                      arg_54, arg_55, arg_56]
  =
  EXC.function_clause unit
erlps__parse_long_option_next_arg__6 args =
  EXC.badarity (ErlangFun 6 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_short_option__7 :: ErlangFun
erlps__parse_short_option__7 [optspeclist_0, optacc_1, argacc_2,
                              argpos_3, args_4, optstr_5, optarg_6]
  =
  erlps__parse_short_option__8
    [optspeclist_0, optacc_1, argacc_2, argpos_3, args_4, optstr_5,
     ErlangAtom "first", optarg_6]
erlps__parse_short_option__7 [arg_15, arg_16, arg_17, arg_18,
                              arg_19, arg_20, arg_21]
  =
  EXC.function_clause unit
erlps__parse_short_option__7 args =
  EXC.badarity (ErlangFun 7 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_short_option__8 :: ErlangFun
erlps__parse_short_option__8 [optspeclist_0, optacc_1, argacc_2,
                              argpos_3, args_4, optstr_5, optpos_6,
                              (ErlangCons short_7 arg_8)]
  =
  let    arg_11 = toErl 2
  in let
    case_9 = BIF.lists__keyfind__3 [short_7, arg_11, optspeclist_0]
  in
    case case_9 of
      (ErlangTuple [name_13, short_14, _long_15,
                    (ErlangAtom "undefined"), _help_16]) | (short_14 ==
                                                              short_7) ->
        erlps__parse_short_option__8
          [optspeclist_0, ErlangCons name_13 optacc_1, argacc_2, argpos_3,
           args_4, optstr_5, ErlangAtom "first", arg_8]
      optspec_32@(ErlangTuple [_name_27, short_28, _long_29,
                               argspec_30, _help_31]) | (short_28 == short_7) ->
        case arg_8 of
          (ErlangEmptyList) ->
            erlps__parse_short_option_next_arg__7
              [optspeclist_0, optacc_1, argacc_2, argpos_3, args_4, optspec_32,
               optpos_6]
          _ ->
            let case_41 = erlps__is_valid_arg__2 [argspec_30, arg_8]
            in
              case case_41 of
                (ErlangAtom "true") ->
                  let
                    arg_45 =
                      erlps__add_option_with_arg__3
                        [optspec_32, arg_8, optacc_1]
                  in
                    erlps__parse__5
                      [optspeclist_0, arg_45, argacc_2, argpos_3, args_4]
                _ ->
                  let
                    newoptacc_57 =
                      case optpos_6 of
                        (ErlangAtom "first") ->
                          erlps__add_option_with_implicit_arg__2
                            [optspec_32, optacc_1]
                        _ ->
                          erlps__add_option_with_implicit_incrementable_arg__2
                            [optspec_32, optacc_1]
                  in
                    erlps__parse_short_option__8
                      [optspeclist_0, newoptacc_57, argacc_2, argpos_3, args_4,
                       optstr_5, ErlangAtom "next", arg_8]
      (ErlangAtom "false") ->
        let   
          tup_el_68 = ErlangTuple [ErlangAtom "invalid_option", optstr_5]
        in let arg_66 = ErlangTuple [ErlangAtom "error", tup_el_68]
        in BIF.erlang__throw__1 [arg_66]
      something_else -> EXC.case_clause something_else
erlps__parse_short_option__8 [optspeclist_0, optacc_1, argacc_2,
                              argpos_3, args_4, _optstr_5, _optpos_6,
                              (ErlangEmptyList)]
  =
  erlps__parse__5
    [optspeclist_0, optacc_1, argacc_2, argpos_3, args_4]
erlps__parse_short_option__8 [arg_12, arg_13, arg_14, arg_15,
                              arg_16, arg_17, arg_18, arg_19]
  =
  EXC.function_clause unit
erlps__parse_short_option__8 args =
  EXC.badarity (ErlangFun 8 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_short_option_next_arg__7 :: ErlangFun
erlps__parse_short_option_next_arg__7 [optspeclist_0, optacc_1,
                                       argacc_2, argpos_3, args_4,
                                       optspec_10@(ErlangTuple [name_5,
                                                                _short_6,
                                                                _long_7,
                                                                argspec_8,
                                                                _help_9]),
                                       optpos_11]
  =
  let    lop_13 = BIF.erlang__op_exactEq [args_4, ErlangEmptyList]
  in let
    case_12 =
      case lop_13 of
        (ErlangAtom "true") -> ErlangAtom "true"
        (ErlangAtom "false") ->
          let arg_17 = BIF.erlang__hd__1 [args_4]
          in erlps__is_implicit_arg__2 [argspec_8, arg_17]
        _ -> EXC.badarg1 lop_13
  in
    case case_12 of
      (ErlangAtom "true") | (==) optpos_11 (ErlangAtom "first") ->
        let
          arg_20 =
            erlps__add_option_with_implicit_arg__2 [optspec_10, optacc_1]
        in
          erlps__parse__5
            [optspeclist_0, arg_20, argacc_2, argpos_3, args_4]
      (ErlangAtom "true") ->
        let
          arg_27 =
            erlps__add_option_with_implicit_incrementable_arg__2
              [optspec_10, optacc_1]
        in
          erlps__parse__5
            [optspeclist_0, arg_27, argacc_2, argpos_3, args_4]
      (ErlangAtom "false") ->
        case args_4 of
          (ErlangCons arg_33 tail_34) ->
            EXC.tryCatch
              (\ _ ->
                 let    tup_el_40 = erlps__to_type__2 [argspec_8, arg_33]
                 in let head_38 = ErlangTuple [name_5, tup_el_40]
                 in
                   erlps__parse__5
                     [optspeclist_0, ErlangCons head_38 optacc_1, argacc_2,
                      argpos_3, tail_34])
              (\ ex_48 ->
                 case ex_48 of
                   (ErlangTuple [(ErlangAtom "error"), _, _]) ->
                     let    tup_el_54 = ErlangTuple [name_5, arg_33]
                     in let
                       tup_el_52 =
                         ErlangTuple
                           [ErlangAtom "invalid_option_arg", tup_el_54]
                     in let arg_50 = ErlangTuple [ErlangAtom "error", tup_el_52]
                     in BIF.erlang__throw__1 [arg_50]
                   ex_49 -> EXC.raise ex_49)
          _ -> EXC.badmatch args_4
      something_else -> EXC.case_clause something_else
erlps__parse_short_option_next_arg__7 [arg_57, arg_58, arg_59,
                                       arg_60, arg_61, arg_62, arg_63]
  =
  EXC.function_clause unit
erlps__parse_short_option_next_arg__7 args =
  EXC.badarity (ErlangFun 7 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__find_non_option_arg__2 :: ErlangFun
erlps__find_non_option_arg__2 [(ErlangCons optspec_3@(ErlangTuple [_name_0,
                                                                   (ErlangAtom "undefined"),
                                                                   (ErlangAtom "undefined"),
                                                                   _argspec_1,
                                                                   _help_2]) _tail_4),
                               (ErlangInt num_5)]
  | ((ErlangInt num_5) == (toErl 0)) =
  ErlangTuple [ErlangAtom "value", optspec_3]
erlps__find_non_option_arg__2 [(ErlangCons (ErlangTuple [_name_0,
                                                         (ErlangAtom "undefined"),
                                                         (ErlangAtom "undefined"),
                                                         _argspec_1,
                                                         _help_2]) tail_3),
                               pos_4]
  =
  let    rop_8 = toErl 1
  in let arg_6 = BIF.erlang__op_minus [pos_4, rop_8]
  in erlps__find_non_option_arg__2 [tail_3, arg_6]
erlps__find_non_option_arg__2 [(ErlangCons _head_0 tail_1),
                               pos_2]
  =
  erlps__find_non_option_arg__2 [tail_1, pos_2]
erlps__find_non_option_arg__2 [(ErlangEmptyList), _pos_0] =
  ErlangAtom "false"
erlps__find_non_option_arg__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__find_non_option_arg__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__append_default_options__2 :: ErlangFun
erlps__append_default_options__2 [(ErlangCons (ErlangTuple [name_0,
                                                            _short_1, _long_2,
                                                            (ErlangTuple [_type_3,
                                                                          defaultarg_4]),
                                                            _help_5]) tail_6),
                                  optacc_7]
  =
  let    arg_12 = toErl 1
  in let
    case_10 = BIF.lists__keymember__3 [name_0, arg_12, optacc_7]
  in let
    arg_9 =
      case case_10 of
        (ErlangAtom "false") ->
          let head_14 = ErlangTuple [name_0, defaultarg_4]
          in ErlangCons head_14 optacc_7
        _ -> optacc_7
  in erlps__append_default_options__2 [tail_6, arg_9]
erlps__append_default_options__2 [(ErlangCons _head_0 tail_1),
                                  optacc_2]
  =
  erlps__append_default_options__2 [tail_1, optacc_2]
erlps__append_default_options__2 [(ErlangEmptyList), optacc_0] =
  optacc_0
erlps__append_default_options__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__append_default_options__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__add_option_with_arg__3 :: ErlangFun
erlps__add_option_with_arg__3 [optspec_5@(ErlangTuple [name_0,
                                                       _short_1, _long_2,
                                                       argspec_3, _help_4]),
                               arg_6, optacc_7]
  =
  let case_8 = erlps__is_valid_arg__2 [argspec_3, arg_6]
  in
    case case_8 of
      (ErlangAtom "true") ->
        EXC.tryCatch
          (\ _ ->
             let    tup_el_13 = erlps__to_type__2 [argspec_3, arg_6]
             in let head_11 = ErlangTuple [name_0, tup_el_13]
             in ErlangCons head_11 optacc_7)
          (\ ex_18 ->
             case ex_18 of
               (ErlangTuple [(ErlangAtom "error"), _, _]) ->
                 let    tup_el_24 = ErlangTuple [name_0, arg_6]
                 in let
                   tup_el_22 =
                     ErlangTuple [ErlangAtom "invalid_option_arg", tup_el_24]
                 in let arg_20 = ErlangTuple [ErlangAtom "error", tup_el_22]
                 in BIF.erlang__throw__1 [arg_20]
               ex_19 -> EXC.raise ex_19)
      (ErlangAtom "false") ->
        erlps__add_option_with_implicit_arg__2 [optspec_5, optacc_7]
      something_else -> EXC.case_clause something_else
erlps__add_option_with_arg__3 [arg_29, arg_30, arg_31] =
  EXC.function_clause unit
erlps__add_option_with_arg__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__add_option_with_assigned_arg__3 :: ErlangFun
erlps__add_option_with_assigned_arg__3 [(ErlangTuple [name_0,
                                                      _short_1, _long_2,
                                                      argspec_3, _help_4]),
                                        arg_5, optacc_6]
  =
  EXC.tryCatch
    (\ _ ->
       let    tup_el_9 = erlps__to_type__2 [argspec_3, arg_5]
       in let head_7 = ErlangTuple [name_0, tup_el_9]
       in ErlangCons head_7 optacc_6)
    (\ ex_14 ->
       case ex_14 of
         (ErlangTuple [(ErlangAtom "error"), _, _]) ->
           let    tup_el_20 = ErlangTuple [name_0, arg_5]
           in let
             tup_el_18 =
               ErlangTuple [ErlangAtom "invalid_option_arg", tup_el_20]
           in let arg_16 = ErlangTuple [ErlangAtom "error", tup_el_18]
           in BIF.erlang__throw__1 [arg_16]
         ex_15 -> EXC.raise ex_15)
erlps__add_option_with_assigned_arg__3 [arg_23, arg_24, arg_25] =
  EXC.function_clause unit
erlps__add_option_with_assigned_arg__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__add_option_with_implicit_arg__2 :: ErlangFun
erlps__add_option_with_implicit_arg__2 [(ErlangTuple [name_0,
                                                      _short_1, _long_2,
                                                      argspec_3, _help_4]),
                                        optacc_5]
  =
  let case_6 = erlps__arg_spec_type__1 [argspec_3]
  in
    case case_6 of
      (ErlangAtom "boolean") ->
        let head_8 = ErlangTuple [name_0, ErlangAtom "true"]
        in ErlangCons head_8 optacc_5
      (ErlangAtom "integer") ->
        let    tup_el_14 = toErl 1
        in let head_12 = ErlangTuple [name_0, tup_el_14]
        in ErlangCons head_12 optacc_5
      _ ->
        let   
          tup_el_18 = ErlangTuple [ErlangAtom "missing_option_arg", name_0]
        in let arg_16 = ErlangTuple [ErlangAtom "error", tup_el_18]
        in BIF.erlang__throw__1 [arg_16]
erlps__add_option_with_implicit_arg__2 [arg_21, arg_22] =
  EXC.function_clause unit
erlps__add_option_with_implicit_arg__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__add_option_with_implicit_incrementable_arg__2 :: ErlangFun
erlps__add_option_with_implicit_incrementable_arg__2 [(ErlangTuple [name_0,
                                                                    _short_1,
                                                                    _long_2,
                                                                    argspec_3,
                                                                    _help_4]),
                                                      optacc_5]
  =
  let case_6 = erlps__arg_spec_type__1 [argspec_3]
  in
    case case_6 of
      (ErlangAtom "boolean") ->
        let head_8 = ErlangTuple [name_0, ErlangAtom "true"]
        in ErlangCons head_8 optacc_5
      (ErlangAtom "integer") ->
        case optacc_5 of
          (ErlangCons (ErlangTuple [name_13,
                                    count_14]) tail_15) | (name_13 == name_0) ->
            let    rop_20 = toErl 1
            in let tup_el_18 = BIF.erlang__op_plus [count_14, rop_20]
            in let head_16 = ErlangTuple [name_0, tup_el_18]
            in ErlangCons head_16 tail_15
          _ ->
            let    tup_el_24 = toErl 1
            in let head_22 = ErlangTuple [name_0, tup_el_24]
            in ErlangCons head_22 optacc_5
      _ ->
        let   
          tup_el_28 = ErlangTuple [ErlangAtom "missing_option_arg", name_0]
        in let arg_26 = ErlangTuple [ErlangAtom "error", tup_el_28]
        in BIF.erlang__throw__1 [arg_26]
erlps__add_option_with_implicit_incrementable_arg__2 [arg_31,
                                                      arg_32]
  =
  EXC.function_clause unit
erlps__add_option_with_implicit_incrementable_arg__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__arg_spec_type__1 :: ErlangFun
erlps__arg_spec_type__1 [(ErlangTuple [type_0, _defaultarg_1])] =
  type_0
erlps__arg_spec_type__1 [type_0] | isEAtom type_0 = type_0
erlps__arg_spec_type__1 [arg_1] = EXC.function_clause unit
erlps__arg_spec_type__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_type__2 :: ErlangFun
erlps__to_type__2 [(ErlangTuple [type_0, _defaultarg_1]), arg_2]
  =
  erlps__to_type__2 [type_0, arg_2]
erlps__to_type__2 [(ErlangAtom "binary"), arg_0] =
  BIF.erlang__list_to_binary__1 [arg_0]
erlps__to_type__2 [(ErlangAtom "atom"), arg_0] =
  BIF.erlang__list_to_atom__1 [arg_0]
erlps__to_type__2 [(ErlangAtom "integer"), arg_0] =
  BIF.erlang__list_to_integer__1 [arg_0]
erlps__to_type__2 [(ErlangAtom "float"), arg_0] =
  BIF.erlang__list_to_float__1 [arg_0]
erlps__to_type__2 [(ErlangAtom "boolean"), arg_0] =
  let    lowerarg_2 = erlps__lowercase__1 [arg_0]
  in let case_3 = erlps__is_arg_true__1 [lowerarg_2]
  in
    case case_3 of
      (ErlangAtom "true") -> ErlangAtom "true"
      _ ->
        let case_5 = erlps__is_arg_false__1 [lowerarg_2]
        in
          case case_5 of
            (ErlangAtom "true") -> ErlangAtom "false"
            (ErlangAtom "false") ->
              BIF.erlang__error__1 [ErlangAtom "badarg"]
            something_else -> EXC.case_clause something_else
erlps__to_type__2 [_type_0, arg_1] = arg_1
erlps__to_type__2 [arg_2, arg_3] = EXC.function_clause unit
erlps__to_type__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_arg_true__1 :: ErlangFun
erlps__is_arg_true__1 [arg_0] =
  let    rop_3 = toErl "true"
  in let lop_1 = BIF.erlang__op_exactEq [arg_0, rop_3]
  in
    case lop_1 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") ->
        let    rop_6 = toErl "t"
        in let lop_4 = BIF.erlang__op_exactEq [arg_0, rop_6]
        in
          case lop_4 of
            (ErlangAtom "true") -> ErlangAtom "true"
            (ErlangAtom "false") ->
              let    rop_9 = toErl "yes"
              in let lop_7 = BIF.erlang__op_exactEq [arg_0, rop_9]
              in
                case lop_7 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    let    rop_12 = toErl "y"
                    in let lop_10 = BIF.erlang__op_exactEq [arg_0, rop_12]
                    in
                      case lop_10 of
                        (ErlangAtom "true") -> ErlangAtom "true"
                        (ErlangAtom "false") ->
                          let    rop_15 = toErl "on"
                          in let lop_13 = BIF.erlang__op_exactEq [arg_0, rop_15]
                          in
                            case lop_13 of
                              (ErlangAtom "true") -> ErlangAtom "true"
                              (ErlangAtom "false") ->
                                let    rop_18 = toErl "enabled"
                                in let
                                  lop_16 =
                                    BIF.erlang__op_exactEq [arg_0, rop_18]
                                in
                                  case lop_16 of
                                    (ErlangAtom "true") -> ErlangAtom "true"
                                    (ErlangAtom "false") ->
                                      let rop_20 = toErl "1"
                                      in BIF.erlang__op_exactEq [arg_0, rop_20]
                                    _ -> EXC.badarg1 lop_16
                              _ -> EXC.badarg1 lop_13
                        _ -> EXC.badarg1 lop_10
                  _ -> EXC.badarg1 lop_7
            _ -> EXC.badarg1 lop_4
      _ -> EXC.badarg1 lop_1
erlps__is_arg_true__1 [arg_21] = EXC.function_clause unit
erlps__is_arg_true__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_arg_false__1 :: ErlangFun
erlps__is_arg_false__1 [arg_0] =
  let    rop_3 = toErl "false"
  in let lop_1 = BIF.erlang__op_exactEq [arg_0, rop_3]
  in
    case lop_1 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") ->
        let    rop_6 = toErl "f"
        in let lop_4 = BIF.erlang__op_exactEq [arg_0, rop_6]
        in
          case lop_4 of
            (ErlangAtom "true") -> ErlangAtom "true"
            (ErlangAtom "false") ->
              let    rop_9 = toErl "no"
              in let lop_7 = BIF.erlang__op_exactEq [arg_0, rop_9]
              in
                case lop_7 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    let    rop_12 = toErl "n"
                    in let lop_10 = BIF.erlang__op_exactEq [arg_0, rop_12]
                    in
                      case lop_10 of
                        (ErlangAtom "true") -> ErlangAtom "true"
                        (ErlangAtom "false") ->
                          let    rop_15 = toErl "off"
                          in let lop_13 = BIF.erlang__op_exactEq [arg_0, rop_15]
                          in
                            case lop_13 of
                              (ErlangAtom "true") -> ErlangAtom "true"
                              (ErlangAtom "false") ->
                                let    rop_18 = toErl "disabled"
                                in let
                                  lop_16 =
                                    BIF.erlang__op_exactEq [arg_0, rop_18]
                                in
                                  case lop_16 of
                                    (ErlangAtom "true") -> ErlangAtom "true"
                                    (ErlangAtom "false") ->
                                      let rop_20 = toErl "0"
                                      in BIF.erlang__op_exactEq [arg_0, rop_20]
                                    _ -> EXC.badarg1 lop_16
                              _ -> EXC.badarg1 lop_13
                        _ -> EXC.badarg1 lop_10
                  _ -> EXC.badarg1 lop_7
            _ -> EXC.badarg1 lop_4
      _ -> EXC.badarg1 lop_1
erlps__is_arg_false__1 [arg_21] = EXC.function_clause unit
erlps__is_arg_false__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_valid_arg__2 :: ErlangFun
erlps__is_valid_arg__2 [(ErlangTuple [type_0, _defaultarg_1]),
                        arg_2]
  =
  erlps__is_valid_arg__2 [type_0, arg_2]
erlps__is_valid_arg__2 [(ErlangAtom "boolean"), arg_0] =
  erlps__is_boolean_arg__1 [arg_0]
erlps__is_valid_arg__2 [(ErlangAtom "integer"), arg_0] =
  erlps__is_non_neg_integer_arg__1 [arg_0]
erlps__is_valid_arg__2 [(ErlangAtom "float"), arg_0] =
  erlps__is_non_neg_float_arg__1 [arg_0]
erlps__is_valid_arg__2 [_type_0, _arg_1] = ErlangAtom "true"
erlps__is_valid_arg__2 [arg_2, arg_3] = EXC.function_clause unit
erlps__is_valid_arg__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_implicit_arg__2 :: ErlangFun
erlps__is_implicit_arg__2 [(ErlangTuple [type_0, _defaultarg_1]),
                           arg_2]
  =
  erlps__is_implicit_arg__2 [type_0, arg_2]
erlps__is_implicit_arg__2 [(ErlangAtom "boolean"), arg_0] =
  let op_arg_1 = erlps__is_boolean_arg__1 [arg_0]
  in BIF.erlang__not__1 [op_arg_1]
erlps__is_implicit_arg__2 [(ErlangAtom "integer"), arg_0] =
  let op_arg_1 = erlps__is_integer_arg__1 [arg_0]
  in BIF.erlang__not__1 [op_arg_1]
erlps__is_implicit_arg__2 [_type_0, _arg_1] = ErlangAtom "false"
erlps__is_implicit_arg__2 [arg_2, arg_3] =
  EXC.function_clause unit
erlps__is_implicit_arg__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_boolean_arg__1 :: ErlangFun
erlps__is_boolean_arg__1 [arg_0] =
  let    lowerarg_2 = erlps__lowercase__1 [arg_0]
  in let lop_3 = erlps__is_arg_true__1 [lowerarg_2]
  in
    case lop_3 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") -> erlps__is_arg_false__1 [lowerarg_2]
      _ -> EXC.badarg1 lop_3
erlps__is_boolean_arg__1 [arg_6] = EXC.function_clause unit
erlps__is_boolean_arg__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_integer_arg__1 :: ErlangFun
erlps__is_integer_arg__1 [(ErlangCons (ErlangInt num_0) tail_1)]
  | ((ErlangInt num_0) == (toErl 45)) =
  erlps__is_non_neg_integer_arg__1 [tail_1]
erlps__is_integer_arg__1 [arg_0] =
  erlps__is_non_neg_integer_arg__1 [arg_0]
erlps__is_integer_arg__1 [arg_2] = EXC.function_clause unit
erlps__is_integer_arg__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_non_neg_integer_arg__1 :: ErlangFun
erlps__is_non_neg_integer_arg__1 [(ErlangCons head_0 tail_1)]
  | ((weakGeq head_0 (toErl 48)) && (weakLeq head_0 (toErl 57))) =
  erlps__is_non_neg_integer_arg__1 [tail_1]
erlps__is_non_neg_integer_arg__1 [(ErlangCons _head_0 _tail_1)] =
  ErlangAtom "false"
erlps__is_non_neg_integer_arg__1 [(ErlangEmptyList)] =
  ErlangAtom "true"
erlps__is_non_neg_integer_arg__1 [arg_0] =
  EXC.function_clause unit
erlps__is_non_neg_integer_arg__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_non_neg_float_arg__1 :: ErlangFun
erlps__is_non_neg_float_arg__1 [(ErlangCons head_0 tail_1)]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_6 = toErl 48
             in let lop_4 = BIF.erlang__op_greaterEq [head_0, rop_6]
             in let
               lop_3 =
                 case lop_4 of
                   (ErlangAtom "false") -> ErlangAtom "false"
                   (ErlangAtom "true") ->
                     let rop_8 = toErl 57
                     in BIF.erlang__op_lesserEq [head_0, rop_8]
                   _ -> EXC.badarg1 lop_4
             in
               case lop_3 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   let rop_10 = toErl 46
                   in BIF.erlang__op_exactEq [head_0, rop_10]
                 _ -> EXC.badarg1 lop_3))) =
  erlps__is_non_neg_float_arg__1 [tail_1]
erlps__is_non_neg_float_arg__1 [(ErlangCons _head_0 _tail_1)] =
  ErlangAtom "false"
erlps__is_non_neg_float_arg__1 [(ErlangEmptyList)] =
  ErlangAtom "true"
erlps__is_non_neg_float_arg__1 [arg_0] = EXC.function_clause unit
erlps__is_non_neg_float_arg__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage__2 :: ErlangFun
erlps__usage__2 [optspeclist_0, programname_1] =
  erlps__usage__3
    [optspeclist_0, programname_1, ErlangAtom "standard_error"]
erlps__usage__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__usage__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage__3 :: ErlangFun
erlps__usage__3 [optspeclist_0, programname_1, outputstream_2]
  | isEAtom outputstream_2 =
  let    arg_4 = toErl "~ts~n~n~ts~n"
  in let
    arg_7 = erlps__usage_cmd_line__2 [programname_1, optspeclist_0]
  in let
    head_6 =
      BIF.do_remote_fun_call "Erlang.Unicode"
        "erlps__characters_to_list__1" [arg_7]
  in let arg_12 = erlps__usage_options__1 [optspeclist_0]
  in let
    head_11 =
      BIF.do_remote_fun_call "Erlang.Unicode"
        "erlps__characters_to_list__1" [arg_12]
  in
    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__3"
      [outputstream_2, arg_4,
       ErlangCons head_6 (ErlangCons head_11 ErlangEmptyList)]
erlps__usage__3 [optspeclist_0, programname_1, cmdlinetail_2] =
  erlps__usage__4
    [optspeclist_0, programname_1, cmdlinetail_2,
     ErlangAtom "standard_error"]
erlps__usage__3 [arg_7, arg_8, arg_9] = EXC.function_clause unit
erlps__usage__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage__4 :: ErlangFun
erlps__usage__4 [optspeclist_0, programname_1, cmdlinetail_2,
                 outputstream_3]
  | isEAtom outputstream_3 =
  let    arg_5 = toErl "~ts~n~n~ts~n"
  in let
    arg_8 =
      erlps__usage_cmd_line__3
        [programname_1, optspeclist_0, cmdlinetail_2]
  in let
    head_7 =
      BIF.do_remote_fun_call "Erlang.Unicode"
        "erlps__characters_to_list__1" [arg_8]
  in let arg_14 = erlps__usage_options__1 [optspeclist_0]
  in let
    head_13 =
      BIF.do_remote_fun_call "Erlang.Unicode"
        "erlps__characters_to_list__1" [arg_14]
  in
    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__3"
      [outputstream_3, arg_5,
       ErlangCons head_7 (ErlangCons head_13 ErlangEmptyList)]
erlps__usage__4 [optspeclist_0, programname_1, cmdlinetail_2,
                 optionstail_3]
  =
  erlps__usage__5
    [optspeclist_0, programname_1, cmdlinetail_2, optionstail_3,
     ErlangAtom "standard_error"]
erlps__usage__4 [arg_9, arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__usage__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage__5 :: ErlangFun
erlps__usage__5 [optspeclist_0, programname_1, cmdlinetail_2,
                 optionstail_3, outputstream_4]
  =
  let    arg_6 = toErl "~ts~n~n~ts~n"
  in let
    arg_9 =
      erlps__usage_cmd_line__3
        [programname_1, optspeclist_0, cmdlinetail_2]
  in let
    head_8 =
      BIF.do_remote_fun_call "Erlang.Unicode"
        "erlps__characters_to_list__1" [arg_9]
  in let
    arg_15 = erlps__usage_options__2 [optspeclist_0, optionstail_3]
  in let
    head_14 =
      BIF.do_remote_fun_call "Erlang.Unicode"
        "erlps__characters_to_list__1" [arg_15]
  in
    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__3"
      [outputstream_4, arg_6,
       ErlangCons head_8 (ErlangCons head_14 ErlangEmptyList)]
erlps__usage__5 [arg_19, arg_20, arg_21, arg_22, arg_23] =
  EXC.function_clause unit
erlps__usage__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage__6 :: ErlangFun
erlps__usage__6 [optspeclist_0, programname_1, cmdlinetail_2,
                 description_3, optionstail_4, outputstream_5]
  =
  let    arg_7 = toErl "~ts~n~n~ts~n~n~ts~n"
  in let
    arg_10 =
      erlps__usage_cmd_line__3
        [programname_1, optspeclist_0, cmdlinetail_2]
  in let
    head_9 =
      BIF.do_remote_fun_call "Erlang.Unicode"
        "erlps__characters_to_list__1" [arg_10]
  in let
    arg_18 = erlps__usage_options__2 [optspeclist_0, optionstail_4]
  in let
    head_17 =
      BIF.do_remote_fun_call "Erlang.Unicode"
        "erlps__characters_to_list__1" [arg_18]
  in
    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__3"
      [outputstream_5, arg_7,
       ErlangCons head_9
         (ErlangCons description_3 (ErlangCons head_17 ErlangEmptyList))]
erlps__usage__6 [arg_22, arg_23, arg_24, arg_25, arg_26, arg_27]
  =
  EXC.function_clause unit
erlps__usage__6 args =
  EXC.badarity (ErlangFun 6 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage_cmd_line__2 :: ErlangFun
erlps__usage_cmd_line__2 [programname_0, optspeclist_1] =
  let arg_4 = toErl ""
  in erlps__usage_cmd_line__3 [programname_0, optspeclist_1, arg_4]
erlps__usage_cmd_line__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__usage_cmd_line__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage_cmd_line__3 :: ErlangFun
erlps__usage_cmd_line__3 [programname_0, optspeclist_1,
                          cmdlinetail_2]
  =
  let    lop_3 = toErl "Usage: "
  in let prefix_5 = BIF.erlang__op_append [lop_3, programname_0]
  in let prefixlength_7 = BIF.erlang__length__1 [prefix_5]
  in let linelength_8 = erlps__line_length__0 []
  in
    case ErlangAtom "true" of
      _ | ((ErlangAtom "true") ==
             (falsifyErrors
                (\ _ ->
                   let   
                     lop_9 = BIF.erlang__op_minus [linelength_8, prefixlength_7]
                   in let rop_12 = toErl 25
                   in BIF.erlang__op_greater [lop_9, rop_12]))) ->
        let    arg_14 = toErl 32
        in let
          indentation_15 =
            BIF.do_remote_fun_call "Lists" "erlps__duplicate__2"
              [prefixlength_7, arg_14]
        in let
          arg_16 = BIF.erlang__op_minus [linelength_8, prefixlength_7]
        in let
          matchExpr_23 =
            erlps__usage_cmd_line_options__3
              [arg_16, optspeclist_1, cmdlinetail_2]
        in
          case matchExpr_23 of
            (ErlangCons firstoptline_21 optlines_22) ->
              let
                indentedoptlines_30 =
                  flmap
                    (\ lc_26 ->
                       ErlangCons (ErlangCons indentation_15 lc_26)
                         ErlangEmptyList)
                    optlines_22
              in
                ErlangCons prefix_5
                  (ErlangCons firstoptline_21 indentedoptlines_30)
            _ -> EXC.badmatch matchExpr_23
      _ ->
        let   
          lcSrc_35 =
            erlps__usage_cmd_line_options__3
              [linelength_8, optspeclist_1, cmdlinetail_2]
        in let
          indentedoptlines_44 =
            flmap
              (\ lc_40 ->
                 let head_42 = toErl " "
                 in ErlangCons (ErlangCons head_42 lc_40) ErlangEmptyList)
              lcSrc_35
        in let head_47 = toErl 10
        in
          ErlangCons prefix_5
            (ErlangCons head_47
               (ErlangCons indentedoptlines_44 ErlangEmptyList))
erlps__usage_cmd_line__3 [arg_51, arg_52, arg_53] =
  EXC.function_clause unit
erlps__usage_cmd_line__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage_cmd_line_options__3 :: ErlangFun
erlps__usage_cmd_line_options__3 [maxlinelength_0, optspeclist_1,
                                  cmdlinetail_2]
  =
  let    arg_8 = toErl " "
  in let rop_6 = erlps__lexemes__2 [cmdlinetail_2, arg_8]
  in let arg_4 = BIF.erlang__op_append [optspeclist_1, rop_6]
  in let arg_10 = toErl 0
  in
    erlps__usage_cmd_line_options__5
      [maxlinelength_0, arg_4, ErlangEmptyList, arg_10,
       ErlangEmptyList]
erlps__usage_cmd_line_options__3 [arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__usage_cmd_line_options__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage_cmd_line_options__5 :: ErlangFun
erlps__usage_cmd_line_options__5 [maxlinelength_0,
                                  (ErlangCons optspec_1 tail_2), lineacc_3,
                                  lineacclength_4, acc_5]
  =
  let    head_6 = toErl 32
  in let arg_8 = erlps__usage_cmd_line_option__1 [optspec_1]
  in let
    tail_7 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_8]
  in let
    optionlength_12 =
      BIF.erlang__length__1 [ErlangCons head_6 tail_7]
  in let
    newlineacclength_15 =
      BIF.erlang__op_plus [lineacclength_4, optionlength_12]
  in
    case ErlangAtom "true" of
      _ | weakLt newlineacclength_15 maxlinelength_0 ->
        erlps__usage_cmd_line_options__5
          [maxlinelength_0, tail_2,
           ErlangCons (ErlangCons head_6 tail_7) lineacc_3,
           newlineacclength_15, acc_5]
      _ ->
        let    rop_30 = toErl 1
        in let arg_28 = BIF.erlang__op_plus [optionlength_12, rop_30]
        in let head_34 = toErl 10
        in let
          head_32 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
              [ErlangCons head_34 lineacc_3]
        in
          erlps__usage_cmd_line_options__5
            [maxlinelength_0, tail_2,
             ErlangCons (ErlangCons head_6 tail_7) ErlangEmptyList, arg_28,
             ErlangCons head_32 acc_5]
erlps__usage_cmd_line_options__5 [maxlinelength_0,
                                  (ErlangEmptyList), lineacc_1@(ErlangCons _ _),
                                  _lineacclength_2, acc_3]
  =
  let    arg_7 = toErl 0
  in let
    head_9 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [lineacc_1]
  in
    erlps__usage_cmd_line_options__5
      [maxlinelength_0, ErlangEmptyList, ErlangEmptyList, arg_7,
       ErlangCons head_9 acc_3]
erlps__usage_cmd_line_options__5 [_maxlinelength_0,
                                  (ErlangEmptyList), (ErlangEmptyList),
                                  _lineacclength_1, acc_2]
  =
  BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_2]
erlps__usage_cmd_line_options__5 [arg_4, arg_5, arg_6, arg_7,
                                  arg_8]
  =
  EXC.function_clause unit
erlps__usage_cmd_line_options__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage_cmd_line_option__1 :: ErlangFun
erlps__usage_cmd_line_option__1 [(ErlangTuple [_name_0, short_1,
                                               _long_2,
                                               (ErlangAtom "undefined"),
                                               _help_3])]
  | (/=) short_1 (ErlangAtom "undefined") =
  let    head_4 = toErl 91
  in let head_6 = toErl 45
  in let head_10 = toErl 93
  in
    ErlangCons head_4
      (ErlangCons head_6
         (ErlangCons short_1 (ErlangCons head_10 ErlangEmptyList)))
erlps__usage_cmd_line_option__1 [(ErlangTuple [_name_0, _short_1,
                                               long_2, (ErlangAtom "undefined"),
                                               _help_3])]
  | (/=) long_2 (ErlangAtom "undefined") =
  let    head_4 = toErl 91
  in let head_6 = toErl 45
  in let head_8 = toErl 45
  in let head_12 = toErl 93
  in
    ErlangCons head_4
      (ErlangCons head_6
         (ErlangCons head_8
            (ErlangCons long_2 (ErlangCons head_12 ErlangEmptyList))))
erlps__usage_cmd_line_option__1 [(ErlangTuple [_name_0, _short_1,
                                               _long_2,
                                               (ErlangAtom "undefined"),
                                               _help_3])]
  =
  ErlangEmptyList
erlps__usage_cmd_line_option__1 [(ErlangTuple [name_0, short_1,
                                               long_2, argspec_3, _help_4])]
  | isEAtom argspec_3 =
  case ErlangAtom "true" of
    _ | (/=) short_1 (ErlangAtom "undefined") ->
      let    head_5 = toErl 91
      in let head_7 = toErl 45
      in let head_11 = toErl 32
      in let head_13 = toErl 60
      in let head_15 = BIF.erlang__atom_to_list__1 [name_0]
      in let head_18 = toErl 62
      in let head_20 = toErl 93
      in
        ErlangCons head_5
          (ErlangCons head_7
             (ErlangCons short_1
                (ErlangCons head_11
                   (ErlangCons head_13
                      (ErlangCons head_15
                         (ErlangCons head_18
                            (ErlangCons head_20 ErlangEmptyList)))))))
    _ | (/=) long_2 (ErlangAtom "undefined") ->
      let    head_22 = toErl 91
      in let head_24 = toErl 45
      in let head_26 = toErl 45
      in let head_30 = toErl 32
      in let head_32 = toErl 60
      in let head_34 = BIF.erlang__atom_to_list__1 [name_0]
      in let head_37 = toErl 62
      in let head_39 = toErl 93
      in
        ErlangCons head_22
          (ErlangCons head_24
             (ErlangCons head_26
                (ErlangCons long_2
                   (ErlangCons head_30
                      (ErlangCons head_32
                         (ErlangCons head_34
                            (ErlangCons head_37
                               (ErlangCons head_39 ErlangEmptyList))))))))
    _ ->
      let    head_41 = toErl 91
      in let head_43 = toErl 60
      in let head_45 = BIF.erlang__atom_to_list__1 [name_0]
      in let head_48 = toErl 62
      in let head_50 = toErl 93
      in
        ErlangCons head_41
          (ErlangCons head_43
             (ErlangCons head_45
                (ErlangCons head_48 (ErlangCons head_50 ErlangEmptyList))))
erlps__usage_cmd_line_option__1 [(ErlangTuple [name_0, short_1,
                                               long_2, argspec_3, _help_4])]
  | isETuple argspec_3 =
  case ErlangAtom "true" of
    _ | (/=) short_1 (ErlangAtom "undefined") ->
      let    head_5 = toErl 91
      in let head_7 = toErl 45
      in let head_11 = toErl 32
      in let head_13 = toErl 91
      in let head_15 = toErl 60
      in let head_17 = BIF.erlang__atom_to_list__1 [name_0]
      in let head_20 = toErl 62
      in let head_22 = toErl 93
      in let head_24 = toErl 93
      in
        ErlangCons head_5
          (ErlangCons head_7
             (ErlangCons short_1
                (ErlangCons head_11
                   (ErlangCons head_13
                      (ErlangCons head_15
                         (ErlangCons head_17
                            (ErlangCons head_20
                               (ErlangCons head_22
                                  (ErlangCons head_24 ErlangEmptyList)))))))))
    _ | (/=) long_2 (ErlangAtom "undefined") ->
      let    head_26 = toErl 91
      in let head_28 = toErl 45
      in let head_30 = toErl 45
      in let head_34 = toErl 32
      in let head_36 = toErl 91
      in let head_38 = toErl 60
      in let head_40 = BIF.erlang__atom_to_list__1 [name_0]
      in let head_43 = toErl 62
      in let head_45 = toErl 93
      in let head_47 = toErl 93
      in
        ErlangCons head_26
          (ErlangCons head_28
             (ErlangCons head_30
                (ErlangCons long_2
                   (ErlangCons head_34
                      (ErlangCons head_36
                         (ErlangCons head_38
                            (ErlangCons head_40
                               (ErlangCons head_43
                                  (ErlangCons head_45
                                     (ErlangCons head_47
                                        ErlangEmptyList))))))))))
    _ ->
      let    head_49 = toErl 91
      in let head_51 = toErl 60
      in let head_53 = BIF.erlang__atom_to_list__1 [name_0]
      in let head_56 = toErl 62
      in let head_58 = toErl 93
      in
        ErlangCons head_49
          (ErlangCons head_51
             (ErlangCons head_53
                (ErlangCons head_56 (ErlangCons head_58 ErlangEmptyList))))
erlps__usage_cmd_line_option__1 [option_0] | isEList option_0 =
  option_0
erlps__usage_cmd_line_option__1 [arg_1] =
  EXC.function_clause unit
erlps__usage_cmd_line_option__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage_options__1 :: ErlangFun
erlps__usage_options__1 [optspeclist_0] =
  erlps__usage_options__2 [optspeclist_0, ErlangEmptyList]
erlps__usage_options__1 [arg_3] = EXC.function_clause unit
erlps__usage_options__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage_options__2 :: ErlangFun
erlps__usage_options__2 [optspeclist_0, customhelp_1] =
  let    arg_3 = toErl 0
  in let
    matchExpr_7 =
      erlps__add_option_spec_help_lines__3
        [optspeclist_0, arg_3, ErlangEmptyList]
  in
    case matchExpr_7 of
      (ErlangTuple [maxoptionlength0_5, usagelines0_6]) ->
        let
          matchExpr_13 =
            erlps__add_custom_help_lines__3
              [customhelp_1, maxoptionlength0_5, usagelines0_6]
        in
          case matchExpr_13 of
            (ErlangTuple [maxoptionlength_11, usagelines_12]) ->
              let    maxlinelength_14 = erlps__line_length__0 []
              in let
                arg_15 =
                  flmap
                    (\ lc_18 ->
                       let    rop_22 = toErl 1
                       in let
                         arg_20 =
                           BIF.erlang__op_plus [maxoptionlength_11, rop_22]
                       in let
                         lcRet_19 =
                           erlps__format_usage_line__3
                             [arg_20, maxlinelength_14, lc_18]
                       in ErlangCons lcRet_19 ErlangEmptyList)
                    usagelines_12
              in BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [arg_15]
            _ -> EXC.badmatch matchExpr_13
      _ -> EXC.badmatch matchExpr_7
erlps__usage_options__2 [arg_25, arg_26] =
  EXC.function_clause unit
erlps__usage_options__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__add_option_spec_help_lines__3 :: ErlangFun
erlps__add_option_spec_help_lines__3 [(ErlangCons optspec_0 tail_1),
                                      prevmaxoptionlength_2, acc_3]
  =
  let    optiontext_5 = erlps__usage_option_text__1 [optspec_0]
  in let helptext_7 = erlps__usage_help_text__1 [optspec_0]
  in let arg_8 = ErlangTuple [optiontext_5, helptext_7]
  in let
    matchExpr_14 =
      erlps__get_max_option_length__2 [arg_8, prevmaxoptionlength_2]
  in
    case matchExpr_14 of
      (ErlangTuple [maxoptionlength_12, colswithlength_13]) ->
        erlps__add_option_spec_help_lines__3
          [tail_1, maxoptionlength_12, ErlangCons colswithlength_13 acc_3]
      _ -> EXC.badmatch matchExpr_14
erlps__add_option_spec_help_lines__3 [(ErlangEmptyList),
                                      maxoptionlength_0, acc_1]
  =
  ErlangTuple [maxoptionlength_0, acc_1]
erlps__add_option_spec_help_lines__3 [arg_4, arg_5, arg_6] =
  EXC.function_clause unit
erlps__add_option_spec_help_lines__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__add_custom_help_lines__3 :: ErlangFun
erlps__add_custom_help_lines__3 [(ErlangCons customcols_0 tail_1),
                                 prevmaxoptionlength_2, acc_3]
  =
  let
    matchExpr_8 =
      erlps__get_max_option_length__2
        [customcols_0, prevmaxoptionlength_2]
  in
    case matchExpr_8 of
      (ErlangTuple [maxoptionlength_6, colswithlength_7]) ->
        erlps__add_custom_help_lines__3
          [tail_1, maxoptionlength_6, ErlangCons colswithlength_7 acc_3]
      _ -> EXC.badmatch matchExpr_8
erlps__add_custom_help_lines__3 [(ErlangEmptyList),
                                 maxoptionlength_0, acc_1]
  =
  ErlangTuple [maxoptionlength_0, acc_1]
erlps__add_custom_help_lines__3 [arg_4, arg_5, arg_6] =
  EXC.function_clause unit
erlps__add_custom_help_lines__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage_option_text__1 :: ErlangFun
erlps__usage_option_text__1 [(ErlangTuple [name_0,
                                           (ErlangAtom "undefined"),
                                           (ErlangAtom "undefined"), _argspec_1,
                                           _help_2])]
  =
  let    lop_3 = toErl "<"
  in let lop_5 = BIF.erlang__atom_to_list__1 [name_0]
  in let rop_7 = toErl ">"
  in let rop_4 = BIF.erlang__op_append [lop_5, rop_7]
  in BIF.erlang__op_append [lop_3, rop_4]
erlps__usage_option_text__1 [(ErlangTuple [_name_0, short_1,
                                           (ErlangAtom "undefined"), _argspec_2,
                                           _help_3])]
  =
  let head_4 = toErl 45
  in ErlangCons head_4 (ErlangCons short_1 ErlangEmptyList)
erlps__usage_option_text__1 [(ErlangTuple [_name_0,
                                           (ErlangAtom "undefined"), long_1,
                                           _argspec_2, _help_3])]
  =
  let    head_4 = toErl 45
  in let head_6 = toErl 45
  in ErlangCons head_4 (ErlangCons head_6 long_1)
erlps__usage_option_text__1 [(ErlangTuple [_name_0, short_1,
                                           long_2, _argspec_3, _help_4])]
  =
  let    head_5 = toErl 45
  in let head_9 = toErl 44
  in let head_11 = toErl 32
  in let head_13 = toErl 45
  in let head_15 = toErl 45
  in
    ErlangCons head_5
      (ErlangCons short_1
         (ErlangCons head_9
            (ErlangCons head_11
               (ErlangCons head_13 (ErlangCons head_15 long_2)))))
erlps__usage_option_text__1 [arg_17] = EXC.function_clause unit
erlps__usage_option_text__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__usage_help_text__1 :: ErlangFun
erlps__usage_help_text__1 [(ErlangTuple [_name_0, _short_1,
                                         _long_2,
                                         (ErlangTuple [_argtype_3, argvalue_4]),
                                         help_5@(ErlangCons _ _)])]
  =
  let    lop_8 = toErl " [default: "
  in let
    lop_10 = erlps__default_arg_value_to_string__1 [argvalue_4]
  in let rop_12 = toErl "]"
  in let rop_9 = BIF.erlang__op_append [lop_10, rop_12]
  in let rop_7 = BIF.erlang__op_append [lop_8, rop_9]
  in BIF.erlang__op_append [help_5, rop_7]
erlps__usage_help_text__1 [(ErlangTuple [_name_0, _short_1,
                                         _long_2, _argspec_3, help_4])]
  =
  help_4
erlps__usage_help_text__1 [arg_5] = EXC.function_clause unit
erlps__usage_help_text__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_max_option_length__2 :: ErlangFun
erlps__get_max_option_length__2 [(ErlangTuple [optiontext_0,
                                               helptext_1]),
                                 prevmaxoptionlength_2]
  =
  let    optionlength_4 = BIF.erlang__length__1 [optiontext_0]
  in let
    tup_el_5 =
      BIF.erlang__max__2 [optionlength_4, prevmaxoptionlength_2]
  in let
    tup_el_8 = ErlangTuple [optionlength_4, optiontext_0, helptext_1]
  in ErlangTuple [tup_el_5, tup_el_8]
erlps__get_max_option_length__2 [arg_12, arg_13] =
  EXC.function_clause unit
erlps__get_max_option_length__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format_usage_line__3 :: ErlangFun
erlps__format_usage_line__3 [maxoptionlength_0, maxlinelength_1,
                             (ErlangTuple [optionlength_2, optiontext_3,
                                           helptext_4@(ErlangCons _ _)])]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_51 = toErl 2
             in let
               rop_49 = BIF.erlang__op_div_strict [maxlinelength_1, rop_51]
             in BIF.erlang__op_lesser [maxoptionlength_0, rop_49]))) =
  let   
    lop_6 = BIF.erlang__op_minus [maxlinelength_1, maxoptionlength_0]
  in let rop_9 = toErl 3
  in let arg_5 = BIF.erlang__op_minus [lop_6, rop_9]
  in let
    matchExpr_13 = erlps__wrap_text_line__2 [arg_5, helptext_4]
  in
    case matchExpr_13 of
      (ErlangCons head_11 tail_12) ->
        let   
          lop_15 = BIF.erlang__op_minus [maxoptionlength_0, optionlength_2]
        in let rop_18 = toErl 1
        in let arg_14 = BIF.erlang__op_plus [lop_15, rop_18]
        in let arg_19 = toErl 32
        in let
          firstlineindentation_20 =
            BIF.do_remote_fun_call "Lists" "erlps__duplicate__2"
              [arg_14, arg_19]
        in let head_21 = toErl 10
        in let rop_25 = toErl 3
        in let arg_23 = BIF.erlang__op_plus [maxoptionlength_0, rop_25]
        in let arg_26 = toErl 32
        in let
          tail_22 =
            BIF.do_remote_fun_call "Lists" "erlps__duplicate__2"
              [arg_23, arg_26]
        in let head_28 = toErl "  "
        in let
          head_36 =
            flmap
              (\ lc_39 ->
                 ErlangCons
                   (ErlangCons (ErlangCons head_21 tail_22)
                      (ErlangCons lc_39 ErlangEmptyList))
                   ErlangEmptyList)
              tail_12
        in let head_46 = toErl 10
        in
          ErlangCons head_28
            (ErlangCons optiontext_3
               (ErlangCons firstlineindentation_20
                  (ErlangCons head_11
                     (ErlangCons head_36
                        (ErlangCons head_46 ErlangEmptyList)))))
      _ -> EXC.badmatch matchExpr_13
erlps__format_usage_line__3 [_maxoptionlength_0, maxlinelength_1,
                             (ErlangTuple [_optionlength_2, optiontext_3,
                                           helptext_4@(ErlangCons _ _)])]
  =
  let    rop_7 = toErl 6
  in let arg_5 = BIF.erlang__op_minus [maxlinelength_1, rop_7]
  in let helplines_9 = erlps__wrap_text_line__2 [arg_5, helptext_4]
  in let head_10 = toErl "  "
  in let
    head_14 =
      flmap
        (\ lc_17 ->
           let head_19 = toErl "\n      "
           in
             ErlangCons
               (ErlangCons head_19 (ErlangCons lc_17 ErlangEmptyList))
               ErlangEmptyList)
        helplines_9
  in let head_24 = toErl 10
  in
    ErlangCons head_10
      (ErlangCons optiontext_3
         (ErlangCons head_14 (ErlangCons head_24 ErlangEmptyList)))
erlps__format_usage_line__3 [_maxoptionlength_0,
                             _maxlinelength_1,
                             (ErlangTuple [_optionlength_2, optiontext_3,
                                           _helptext_4])]
  =
  let    head_5 = toErl "  "
  in let head_9 = toErl 10
  in
    ErlangCons head_5
      (ErlangCons optiontext_3 (ErlangCons head_9 ErlangEmptyList))
erlps__format_usage_line__3 [arg_11, arg_12, arg_13] =
  EXC.function_clause unit
erlps__format_usage_line__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__wrap_text_line__2 :: ErlangFun
erlps__wrap_text_line__2 [length_0, text_1] =
  let arg_5 = toErl 0
  in
    erlps__wrap_text_line__5
      [length_0, text_1, ErlangEmptyList, arg_5, ErlangEmptyList]
erlps__wrap_text_line__2 [arg_7, arg_8] =
  EXC.function_clause unit
erlps__wrap_text_line__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__wrap_text_line__5 :: ErlangFun
erlps__wrap_text_line__5 [length_0, (ErlangCons char_1 tail_2),
                          acc_3, count_4, currentlineacc_5]
  | weakLt count_4 length_0 =
  let    rop_11 = toErl 1
  in let arg_9 = BIF.erlang__op_plus [count_4, rop_11]
  in
    erlps__wrap_text_line__5
      [length_0, tail_2, acc_3, arg_9,
       ErlangCons char_1 currentlineacc_5]
erlps__wrap_text_line__5 [length_0, help_1@(ErlangCons _ _),
                          acc_2, count_3, currentlineacc_4]
  =
  let    arg_7 = toErl " \t"
  in let case_5 = erlps__cspan__2 [currentlineacc_4, arg_7]
  in let
    matchExpr_15 =
      case case_5 of
        whitespacepos_8 | weakLt whitespacepos_8 count_3 ->
          BIF.do_remote_fun_call "Lists" "erlps__split__2"
            [whitespacepos_8, currentlineacc_4]
        _ -> ErlangTuple [ErlangEmptyList, currentlineacc_4]
  in
    case matchExpr_15 of
      (ErlangTuple [nextlineacc_13, wrappedline_14]) ->
        let   
          head_19 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
              [wrappedline_14]
        in let arg_22 = BIF.erlang__length__1 [nextlineacc_13]
        in
          erlps__wrap_text_line__5
            [length_0, help_1, ErlangCons head_19 acc_2, arg_22,
             nextlineacc_13]
      _ -> EXC.badmatch matchExpr_15
erlps__wrap_text_line__5 [_length_0, (ErlangEmptyList), acc_1,
                          _count_2, currentlineacc_3@(ErlangCons _ _)]
  =
  let
    head_5 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
        [currentlineacc_3]
  in
    BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
      [ErlangCons head_5 acc_1]
erlps__wrap_text_line__5 [_length_0, (ErlangEmptyList), acc_1,
                          _count_2, _currentlineacc_3]
  =
  BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_1]
erlps__wrap_text_line__5 [arg_5, arg_6, arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__wrap_text_line__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__default_arg_value_to_string__1 :: ErlangFun
erlps__default_arg_value_to_string__1 [value_0]
  | isEAtom value_0 =
  BIF.erlang__atom_to_list__1 [value_0]
erlps__default_arg_value_to_string__1 [value_0]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [value_0]))) =
  BIF.erlang__binary_to_list__1 [value_0]
erlps__default_arg_value_to_string__1 [value_0]
  | isEInt value_0 =
  BIF.erlang__integer_to_list__1 [value_0]
erlps__default_arg_value_to_string__1 [value_0]
  | isEFloat value_0 =
  let    arg_2 = toErl "~w"
  in let
    arg_1 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons value_0 ErlangEmptyList]
  in BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_1]
erlps__default_arg_value_to_string__1 [value_0] = value_0
erlps__default_arg_value_to_string__1 [arg_1] =
  EXC.function_clause unit
erlps__default_arg_value_to_string__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__tokenize__1 :: ErlangFun
erlps__tokenize__1 [cmdline_0] =
  erlps__tokenize__3 [cmdline_0, ErlangEmptyList, ErlangEmptyList]
erlps__tokenize__1 [arg_4] = EXC.function_clause unit
erlps__tokenize__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__tokenize__3 :: ErlangFun
erlps__tokenize__3 [(ErlangCons sep_0 tail_1), acc_2, argacc_3]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_14 = toErl 32
             in let lop_12 = BIF.erlang__op_exactEq [sep_0, rop_14]
             in
               case lop_12 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   let    rop_17 = toErl 9
                   in let lop_15 = BIF.erlang__op_exactEq [sep_0, rop_17]
                   in
                     case lop_15 of
                       (ErlangAtom "true") -> ErlangAtom "true"
                       (ErlangAtom "false") ->
                         let    rop_20 = toErl 10
                         in let lop_18 = BIF.erlang__op_exactEq [sep_0, rop_20]
                         in
                           case lop_18 of
                             (ErlangAtom "true") -> ErlangAtom "true"
                             (ErlangAtom "false") ->
                               let rop_22 = toErl 13
                               in BIF.erlang__op_exactEq [sep_0, rop_22]
                             _ -> EXC.badarg1 lop_18
                       _ -> EXC.badarg1 lop_15
                 _ -> EXC.badarg1 lop_12))) =
  let
    newacc_8 =
      case argacc_3 of
        (ErlangCons _ _) ->
          let
            head_5 =
              BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [argacc_3]
          in ErlangCons head_5 acc_2
        (ErlangEmptyList) -> acc_2
        something_else -> EXC.case_clause something_else
  in erlps__tokenize__3 [tail_1, newacc_8, ErlangEmptyList]
erlps__tokenize__3 [(ErlangCons quotationmark_0 tail_1), acc_2,
                    argacc_3]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_10 = toErl 34
             in let lop_8 = BIF.erlang__op_exactEq [quotationmark_0, rop_10]
             in
               case lop_8 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   let rop_12 = toErl 39
                   in BIF.erlang__op_exactEq [quotationmark_0, rop_12]
                 _ -> EXC.badarg1 lop_8))) =
  erlps__tokenize_quoted_arg__4
    [quotationmark_0, tail_1, acc_2, argacc_3]
erlps__tokenize__3 [cmdline_2@(ErlangCons char_0 _tail_1), acc_3,
                    argacc_4]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_16 = toErl 36
             in let lop_14 = BIF.erlang__op_exactEq [char_0, rop_16]
             in
               case lop_14 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   let rop_18 = toErl 37
                   in BIF.erlang__op_exactEq [char_0, rop_18]
                 _ -> EXC.badarg1 lop_14))) =
  let matchExpr_8 = erlps__expand_env_var__1 [cmdline_2]
  in
    case matchExpr_8 of
      (ErlangTuple [newcmdline_6, var_7]) ->
        let arg_11 = BIF.lists__reverse__2 [var_7, argacc_4]
        in erlps__tokenize__3 [newcmdline_6, acc_3, arg_11]
      _ -> EXC.badmatch matchExpr_8
erlps__tokenize__3 [(ErlangCons (ErlangInt num_0) (ErlangCons char_1 tail_2)),
                    acc_3, argacc_4]
  | ((ErlangInt num_0) == (toErl 92)) =
  erlps__tokenize__3 [tail_2, acc_3, ErlangCons char_1 argacc_4]
erlps__tokenize__3 [(ErlangCons char_0 tail_1), acc_2, argacc_3]
  =
  erlps__tokenize__3 [tail_1, acc_2, ErlangCons char_0 argacc_3]
erlps__tokenize__3 [(ErlangEmptyList), acc_0, (ErlangEmptyList)]
  =
  BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_0]
erlps__tokenize__3 [(ErlangEmptyList), acc_0, argacc_1] =
  let
    head_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [argacc_1]
  in
    BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
      [ErlangCons head_3 acc_0]
erlps__tokenize__3 [arg_6, arg_7, arg_8] =
  EXC.function_clause unit
erlps__tokenize__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__tokenize_quoted_arg__4 :: ErlangFun
erlps__tokenize_quoted_arg__4 [quotationmark_0,
                               (ErlangCons quotationmark_1 tail_2), acc_3,
                               argacc_4]
  | (quotationmark_1 == quotationmark_0) =
  erlps__tokenize__3 [tail_2, acc_3, argacc_4]
erlps__tokenize_quoted_arg__4 [quotationmark_0,
                               (ErlangCons (ErlangInt num_1) (ErlangCons char_2 tail_3)),
                               acc_4, argacc_5]
  | ((ErlangInt num_1) == (toErl 92)) =
  erlps__tokenize_quoted_arg__4
    [quotationmark_0, tail_3, acc_4, ErlangCons char_2 argacc_5]
erlps__tokenize_quoted_arg__4 [quotationmark_1@(ErlangInt num_0),
                               cmdline_4@(ErlangCons char_2 _tail_3), acc_5,
                               argacc_6]
  | ((ErlangInt num_0) == (toErl 34))
  , ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_19 = toErl 36
             in let lop_17 = BIF.erlang__op_exactEq [char_2, rop_19]
             in
               case lop_17 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   let rop_21 = toErl 37
                   in BIF.erlang__op_exactEq [char_2, rop_21]
                 _ -> EXC.badarg1 lop_17))) =
  let matchExpr_10 = erlps__expand_env_var__1 [cmdline_4]
  in
    case matchExpr_10 of
      (ErlangTuple [newcmdline_8, var_9]) ->
        let arg_14 = BIF.lists__reverse__2 [var_9, argacc_6]
        in
          erlps__tokenize_quoted_arg__4
            [quotationmark_1, newcmdline_8, acc_5, arg_14]
      _ -> EXC.badmatch matchExpr_10
erlps__tokenize_quoted_arg__4 [quotationmark_0,
                               (ErlangCons char_1 tail_2), acc_3, argacc_4]
  =
  erlps__tokenize_quoted_arg__4
    [quotationmark_0, tail_2, acc_3, ErlangCons char_1 argacc_4]
erlps__tokenize_quoted_arg__4 [_quotationmark_0, cmdline_1,
                               acc_2, argacc_3]
  =
  erlps__tokenize__3 [cmdline_1, acc_2, argacc_3]
erlps__tokenize_quoted_arg__4 [arg_7, arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__tokenize_quoted_arg__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expand_env_var__1 :: ErlangFun
erlps__expand_env_var__1 [cmdline_0] =
  case cmdline_0 of
    (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) tail_4)) | ((ErlangInt
                                                                               num_2) ==
                                                                              (toErl
                                                                                 36))
                                                                         , ((ErlangInt
                                                                               num_3) ==
                                                                              (toErl
                                                                                 123)) ->
      let    arg_5 = toErl "${"
      in let arg_6 = toErl 125
      in
        erlps__expand_env_var__4 [arg_5, arg_6, tail_4, ErlangEmptyList]
    (ErlangCons (ErlangInt num_9) tail_10) | ((ErlangInt num_9) ==
                                                (toErl 36)) ->
      let arg_11 = toErl "$"
      in erlps__expand_env_var__3 [arg_11, tail_10, ErlangEmptyList]
    (ErlangCons (ErlangInt num_14) tail_15) | ((ErlangInt num_14) ==
                                                 (toErl 37)) ->
      let    arg_16 = toErl "%"
      in let arg_17 = toErl 37
      in
        erlps__expand_env_var__4
          [arg_16, arg_17, tail_15, ErlangEmptyList]
    something_else -> EXC.case_clause something_else
erlps__expand_env_var__1 [arg_20] = EXC.function_clause unit
erlps__expand_env_var__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expand_env_var__4 :: ErlangFun
erlps__expand_env_var__4 [prefix_0, endmark_1,
                          (ErlangCons char_2 tail_3), acc_4]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_14 = toErl 65
             in let lop_12 = BIF.erlang__op_greaterEq [char_2, rop_14]
             in let
               lop_11 =
                 case lop_12 of
                   (ErlangAtom "false") -> ErlangAtom "false"
                   (ErlangAtom "true") ->
                     let rop_16 = toErl 90
                     in BIF.erlang__op_lesserEq [char_2, rop_16]
                   _ -> EXC.badarg1 lop_12
             in
               case lop_11 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   let    rop_20 = toErl 97
                   in let lop_18 = BIF.erlang__op_greaterEq [char_2, rop_20]
                   in let
                     lop_17 =
                       case lop_18 of
                         (ErlangAtom "false") -> ErlangAtom "false"
                         (ErlangAtom "true") ->
                           let rop_22 = toErl 122
                           in BIF.erlang__op_lesserEq [char_2, rop_22]
                         _ -> EXC.badarg1 lop_18
                   in
                     case lop_17 of
                       (ErlangAtom "true") -> ErlangAtom "true"
                       (ErlangAtom "false") ->
                         let    rop_26 = toErl 48
                         in let
                           lop_24 = BIF.erlang__op_greaterEq [char_2, rop_26]
                         in let
                           lop_23 =
                             case lop_24 of
                               (ErlangAtom "false") -> ErlangAtom "false"
                               (ErlangAtom "true") ->
                                 let rop_28 = toErl 57
                                 in BIF.erlang__op_lesserEq [char_2, rop_28]
                               _ -> EXC.badarg1 lop_24
                         in
                           case lop_23 of
                             (ErlangAtom "true") -> ErlangAtom "true"
                             (ErlangAtom "false") ->
                               let rop_30 = toErl 95
                               in BIF.erlang__op_exactEq [char_2, rop_30]
                             _ -> EXC.badarg1 lop_23
                       _ -> EXC.badarg1 lop_17
                 _ -> EXC.badarg1 lop_11))) =
  erlps__expand_env_var__4
    [prefix_0, endmark_1, tail_3, ErlangCons char_2 acc_4]
erlps__expand_env_var__4 [prefix_0, endmark_1,
                          (ErlangCons endmark_2 tail_3), acc_4]
  | (endmark_2 == endmark_1) =
  let
    tup_el_6 =
      erlps__get_env_var__3
        [prefix_0, ErlangCons endmark_1 ErlangEmptyList, acc_4]
  in ErlangTuple [tail_3, tup_el_6]
erlps__expand_env_var__4 [prefix_0, _endmark_1, cmdline_2, acc_3]
  =
  let   
    rop_7 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_3]
  in let tup_el_5 = BIF.erlang__op_append [prefix_0, rop_7]
  in ErlangTuple [cmdline_2, tup_el_5]
erlps__expand_env_var__4 [arg_9, arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__expand_env_var__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expand_env_var__3 :: ErlangFun
erlps__expand_env_var__3 [prefix_0, (ErlangCons char_1 tail_2),
                          acc_3]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_12 = toErl 65
             in let lop_10 = BIF.erlang__op_greaterEq [char_1, rop_12]
             in let
               lop_9 =
                 case lop_10 of
                   (ErlangAtom "false") -> ErlangAtom "false"
                   (ErlangAtom "true") ->
                     let rop_14 = toErl 90
                     in BIF.erlang__op_lesserEq [char_1, rop_14]
                   _ -> EXC.badarg1 lop_10
             in
               case lop_9 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   let    rop_18 = toErl 97
                   in let lop_16 = BIF.erlang__op_greaterEq [char_1, rop_18]
                   in let
                     lop_15 =
                       case lop_16 of
                         (ErlangAtom "false") -> ErlangAtom "false"
                         (ErlangAtom "true") ->
                           let rop_20 = toErl 122
                           in BIF.erlang__op_lesserEq [char_1, rop_20]
                         _ -> EXC.badarg1 lop_16
                   in
                     case lop_15 of
                       (ErlangAtom "true") -> ErlangAtom "true"
                       (ErlangAtom "false") ->
                         let    rop_24 = toErl 48
                         in let
                           lop_22 = BIF.erlang__op_greaterEq [char_1, rop_24]
                         in let
                           lop_21 =
                             case lop_22 of
                               (ErlangAtom "false") -> ErlangAtom "false"
                               (ErlangAtom "true") ->
                                 let rop_26 = toErl 57
                                 in BIF.erlang__op_lesserEq [char_1, rop_26]
                               _ -> EXC.badarg1 lop_22
                         in
                           case lop_21 of
                             (ErlangAtom "true") -> ErlangAtom "true"
                             (ErlangAtom "false") ->
                               let rop_28 = toErl 95
                               in BIF.erlang__op_exactEq [char_1, rop_28]
                             _ -> EXC.badarg1 lop_21
                       _ -> EXC.badarg1 lop_15
                 _ -> EXC.badarg1 lop_9))) =
  erlps__expand_env_var__3
    [prefix_0, tail_2, ErlangCons char_1 acc_3]
erlps__expand_env_var__3 [prefix_0, cmdline_1, acc_2] =
  let    arg_6 = toErl ""
  in let tup_el_4 = erlps__get_env_var__3 [prefix_0, arg_6, acc_2]
  in ErlangTuple [cmdline_1, tup_el_4]
erlps__expand_env_var__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__expand_env_var__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_env_var__3 :: ErlangFun
erlps__get_env_var__3 [prefix_0, suffix_1,
                       acc_2@(ErlangCons _ _)]
  =
  let   
    name_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_2]
  in let
    case_5 = BIF.do_remote_fun_call "Os" "erlps__getenv__1" [name_4]
  in
    case case_5 of
      (ErlangAtom "false") ->
        let rop_8 = BIF.erlang__op_append [name_4, suffix_1]
        in BIF.erlang__op_append [prefix_0, rop_8]
      value_11 -> value_11
erlps__get_env_var__3 [prefix_0, suffix_1, (ErlangEmptyList)] =
  BIF.erlang__op_append [prefix_0, suffix_1]
erlps__get_env_var__3 [arg_4, arg_5, arg_6] =
  EXC.function_clause unit
erlps__get_env_var__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__line_length__0 :: ErlangFun
erlps__line_length__0 [] =
  let
    case_0 =
      BIF.do_remote_fun_call "Erlang.Io" "erlps__columns__0" []
  in
    case case_0 of
      (ErlangTuple [(ErlangAtom "ok"), columns_1]) | weakLt columns_1
                                                       (toErl 75) ->
        let rop_3 = toErl 1
        in BIF.erlang__op_minus [columns_1, rop_3]
      _ -> toErl 75
erlps__line_length__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_string__1 :: ErlangFun
erlps__to_string__1 [list_0] | isEList list_0 =
  let
    case_1 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__printable_list__1"
        [list_0]
  in
    case case_1 of
      (ErlangAtom "true") -> list_0
      (ErlangAtom "false") ->
        let arg_3 = toErl "~p"
        in
          BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
            [arg_3, ErlangCons list_0 ErlangEmptyList]
      something_else -> EXC.case_clause something_else
erlps__to_string__1 [atom_0] | isEAtom atom_0 =
  BIF.erlang__atom_to_list__1 [atom_0]
erlps__to_string__1 [value_0] =
  let arg_1 = toErl "~p"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons value_0 ErlangEmptyList]
erlps__to_string__1 [arg_5] = EXC.function_clause unit
erlps__to_string__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lowercase__1 :: ErlangFun
erlps__lowercase__1 [str_0] =
  BIF.do_remote_fun_call "String" "erlps__lowercase__1" [str_0]
erlps__lowercase__1 [arg_2] = EXC.function_clause unit
erlps__lowercase__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lexemes__2 :: ErlangFun
erlps__lexemes__2 [str_0, separators_1] =
  BIF.do_remote_fun_call "String" "erlps__lexemes__2"
    [str_0, separators_1]
erlps__lexemes__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__lexemes__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__cspan__2 :: ErlangFun
erlps__cspan__2 [str_0, chars_1] =
  let    arg_3 = toErl 1
  in let
    arg_4 =
      BIF.do_remote_fun_call "String" "erlps__take__3"
        [str_0, chars_1, ErlangAtom "true"]
  in let arg_2 = BIF.erlang__element__2 [arg_3, arg_4]
  in BIF.erlang__length__1 [arg_2]
erlps__cspan__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__cspan__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args