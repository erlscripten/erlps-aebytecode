module Aeb.Fate.Code(erlps__annotations__1,
                     erlps__deserialize__1, erlps__functions__1,
                     erlps__insert_annotation__4, erlps__insert_fun__5,
                     erlps__insert_symbol__2, erlps__new__0,
                     erlps__serialize__1, erlps__serialize__2,
                     erlps__serialize__3, erlps__serialize_code__1,
                     erlps__serialize_signature__1,
                     erlps__strip_init_function__1, erlps__symbol_identifier__1,
                     erlps__symbols__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__new__0 :: ErlangFun
erlps__new__0 [] =
  let    tup_el_1 = ErlangMap Map.empty
  in let tup_el_2 = ErlangMap Map.empty
  in let tup_el_3 = ErlangMap Map.empty
  in ErlangTuple [ErlangAtom "fcode", tup_el_1, tup_el_2, tup_el_3]
erlps__new__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__annotations__1 :: ErlangFun
erlps__annotations__1 [(ErlangTuple [(ErlangAtom "fcode"), _, _,
                                     as_0])]
  =
  as_0
erlps__annotations__1 [arg_1] = EXC.function_clause unit
erlps__annotations__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__functions__1 :: ErlangFun
erlps__functions__1 [(ErlangTuple [(ErlangAtom "fcode"), fs_0, _,
                                   _])]
  =
  fs_0
erlps__functions__1 [arg_1] = EXC.function_clause unit
erlps__functions__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__symbols__1 :: ErlangFun
erlps__symbols__1 [(ErlangTuple [(ErlangAtom "fcode"), _, ss_0,
                                 _])]
  =
  ss_0
erlps__symbols__1 [arg_1] = EXC.function_clause unit
erlps__symbols__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__update_annotations__2 :: ErlangFun
erlps__update_annotations__2 [fcode_1@(ErlangTuple [(ErlangAtom "fcode"),
                                                    _, _, as_0]),
                              anns_2]
  =
  let record_updt_4 = BIF.maps__merge__2 [as_0, anns_2]
  in
    case fcode_1 of
      (ErlangTuple [(ErlangAtom "fcode"), functions_7, symbols_8,
                    annotations_9]) ->
        ErlangTuple
          [ErlangAtom "fcode", functions_7, symbols_8, record_updt_4]
      _ -> EXC.badrecord (ErlangAtom "fcode")
erlps__update_annotations__2 [arg_10, arg_11] =
  EXC.function_clause unit
erlps__update_annotations__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__update_functions__2 :: ErlangFun
erlps__update_functions__2 [fcode_1@(ErlangTuple [(ErlangAtom "fcode"),
                                                  fs_0, _, _]),
                            funs_2]
  =
  let record_updt_4 = BIF.maps__merge__2 [fs_0, funs_2]
  in
    case fcode_1 of
      (ErlangTuple [(ErlangAtom "fcode"), functions_7, symbols_8,
                    annotations_9]) ->
        ErlangTuple
          [ErlangAtom "fcode", record_updt_4, symbols_8, annotations_9]
      _ -> EXC.badrecord (ErlangAtom "fcode")
erlps__update_functions__2 [arg_10, arg_11] =
  EXC.function_clause unit
erlps__update_functions__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__update_symbols__2 :: ErlangFun
erlps__update_symbols__2 [fcode_1@(ErlangTuple [(ErlangAtom "fcode"),
                                                _, ss_0, _]),
                          symbs_2]
  =
  let record_updt_4 = BIF.maps__merge__2 [ss_0, symbs_2]
  in
    case fcode_1 of
      (ErlangTuple [(ErlangAtom "fcode"), functions_7, symbols_8,
                    annotations_9]) ->
        ErlangTuple
          [ErlangAtom "fcode", functions_7, record_updt_4, annotations_9]
      _ -> EXC.badrecord (ErlangAtom "fcode")
erlps__update_symbols__2 [arg_10, arg_11] =
  EXC.function_clause unit
erlps__update_symbols__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__symbol_identifier__1 :: ErlangFun
erlps__symbol_identifier__1 [bin_0] =
  let    arg_1 = toErl 32
  in let
    matchExpr_7 =
      BIF.do_remote_fun_call "Eblake2" "erlps__blake2b__2"
        [arg_1, bin_0]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "ok"),
                    (ErlangBinary binSeg_3)]) | (ErlangInt size_4) <- (toErl 4)
                                              , (BIN.Ok x_6 bin_5) <-
                                                  (BIN.chopBin binSeg_3 size_4
                                                     8) ->
        x_6
      _ -> EXC.badmatch matchExpr_7
erlps__symbol_identifier__1 [arg_8] = EXC.function_clause unit
erlps__symbol_identifier__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__insert_fun__5 :: ErlangFun
erlps__insert_fun__5 [name_0, attrs_1,
                      (ErlangTuple [argtype_2, rettype_3]),
                      bbs_5@(ErlangMap map_4), fcode_6]
  =
  let matchExpr_11 = erlps__insert_symbol__2 [name_0, fcode_6]
  in
    case matchExpr_11 of
      (ErlangTuple [f1_9, id_10]) ->
        let    tup_el_17 = ErlangTuple [argtype_2, rettype_3]
        in let val_15 = ErlangTuple [attrs_1, tup_el_17, bbs_5]
        in let arg_13 = ErlangMap (Map.singleton id_10 val_15)
        in erlps__update_functions__2 [f1_9, arg_13]
      _ -> EXC.badmatch matchExpr_11
erlps__insert_fun__5 [arg_21, arg_22, arg_23, arg_24, arg_25] =
  EXC.function_clause unit
erlps__insert_fun__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__insert_symbol__2 :: ErlangFun
erlps__insert_symbol__2 [name_0,
                         f_2@(ErlangTuple [(ErlangAtom "fcode"), _, syms_1, _])]
  =
  let    id_4 = erlps__symbol_identifier__1 [name_0]
  in let case_5 = BIF.maps__find__2 [id_4, syms_1]
  in
    case case_5 of
      (ErlangTuple [(ErlangAtom "ok"), name_8]) | (name_8 == name_0) ->
        ErlangTuple [f_2, id_4]
      (ErlangTuple [(ErlangAtom "ok"), x_11]) ->
        let
          arg_12 =
            ErlangTuple
              [ErlangAtom "two_symbols_with_same_hash", name_0, x_11]
        in BIF.erlang__error__1 [arg_12]
      (ErlangAtom "error") ->
        let    arg_18 = ErlangMap (Map.singleton id_4 name_0)
        in let tup_el_16 = erlps__update_symbols__2 [f_2, arg_18]
        in ErlangTuple [tup_el_16, id_4]
      something_else -> EXC.case_clause something_else
erlps__insert_symbol__2 [arg_22, arg_23] =
  EXC.function_clause unit
erlps__insert_symbol__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__insert_annotation__4 :: ErlangFun
erlps__insert_annotation__4 [_type_0@(ErlangAtom "comment"),
                             line_1, comment_2, fcode_3]
  =
  let    arg_6 = toErl "comment"
  in let
    tup_el_5 =
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_string__1"
        [arg_6]
  in let arg_4 = ErlangTuple [tup_el_5, line_1]
  in let
    key_8 =
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_tuple__1"
        [arg_4]
  in let
    value_10 =
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_string__1"
        [comment_2]
  in let arg_12 = ErlangMap (Map.singleton key_8 value_10)
  in erlps__update_annotations__2 [fcode_3, arg_12]
erlps__insert_annotation__4 [arg_15, arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__insert_annotation__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__strip_init_function__1 :: ErlangFun
erlps__strip_init_function__1 [fcode_2@(ErlangTuple [(ErlangAtom "fcode"),
                                                     funs_0, syms_1, _])]
  =
  let    bin_el_4 = toErl 105
  in let bin_el_5 = toErl 110
  in let bin_el_6 = toErl 105
  in let bin_el_7 = toErl 116
  in let
    arg_3 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_4 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_5 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_6 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_7 (toErl 8) 1 BIN.Big])
  in let id_8 = erlps__symbol_identifier__1 [arg_3]
  in let funs1_11 = BIF.maps__remove__2 [id_8, funs_0]
  in let syms1_14 = BIF.maps__remove__2 [id_8, syms_1]
  in
    case fcode_2 of
      (ErlangTuple [(ErlangAtom "fcode"), functions_18, symbols_19,
                    annotations_20]) ->
        ErlangTuple
          [ErlangAtom "fcode", funs1_11, syms1_14, annotations_20]
      _ -> EXC.badrecord (ErlangAtom "fcode")
erlps__strip_init_function__1 [arg_21] = EXC.function_clause unit
erlps__strip_init_function__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize__1 :: ErlangFun
erlps__serialize__1 [f_0@(ErlangTuple [(ErlangAtom "fcode"), _,
                                       _, _])]
  =
  erlps__serialize__2 [f_0, ErlangEmptyList]
erlps__serialize__1 [arg_3] = EXC.function_clause unit
erlps__serialize__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize__2 :: ErlangFun
erlps__serialize__2 [f_0@(ErlangTuple [(ErlangAtom "fcode"), _,
                                       _, _]),
                     options_1]
  =
  let    _ = erlps__sanity_check__1 [f_0]
  in let arg_4 = erlps__serialize_functions__1 [f_0]
  in erlps__serialize__3 [f_0, arg_4, options_1]
erlps__serialize__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__serialize__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize__3 :: ErlangFun
erlps__serialize__3 [f_0@(ErlangTuple [(ErlangAtom "fcode"), _,
                                       _, _]),
                     functions_1, options_2]
  =
  let    symboltable_4 = erlps__serialize_symbol_table__1 [f_0]
  in let annotatations_6 = erlps__serialize_annotations__1 [f_0]
  in let
    bin_el_7 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__encode__1"
        [functions_1]
  in let
    bin_el_9 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__encode__1"
        [symboltable_4]
  in let
    bin_el_11 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__encode__1"
        [annotatations_6]
  in let
    bytecode_13 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_7 (BIN.packedSize bin_el_7) 8,
            BIN.binPrefix bin_el_9 (BIN.packedSize bin_el_9) 8,
            BIN.binPrefix bin_el_11 (BIN.packedSize bin_el_11) 8])
  in let
    case_14 =
      BIF.do_remote_fun_call "Proplists" "erlps__lookup__2"
        [ErlangAtom "pp_hex_string", options_2]
  in let
    _ =
      case case_14 of
        (ErlangTuple [(ErlangAtom "pp_hex_string"),
                      (ErlangAtom "true")]) ->
          let    arg_17 = toErl "Code: ~s~n"
          in let head_19 = erlps__to_hexstring__1 [functions_1]
          in
            BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
              [arg_17, ErlangCons head_19 ErlangEmptyList]
        (ErlangAtom "none") -> ErlangAtom "ok"
        something_else -> EXC.case_clause something_else
  in bytecode_13
erlps__serialize__3 [arg_22, arg_23, arg_24] =
  EXC.function_clause unit
erlps__serialize__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_hexstring__1 :: ErlangFun
erlps__to_hexstring__1 [bytelist_0] =
  let    lop_1 = toErl "0x"
  in let
    arg_3 =
      flmap
        (\ lc_6 ->
           let    arg_8 = toErl "~2.16.0b"
           in let
             lcRet_7 =
               BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                 [arg_8, ErlangCons lc_6 ErlangEmptyList]
           in ErlangCons lcRet_7 ErlangEmptyList)
        bytelist_0
  in let
    rop_2 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_3]
  in BIF.erlang__op_append [lop_1, rop_2]
erlps__to_hexstring__1 [arg_12] = EXC.function_clause unit
erlps__to_hexstring__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_functions__1 :: ErlangFun
erlps__serialize_functions__1 [(ErlangTuple [(ErlangAtom "fcode"),
                                             functions_0, _, _])]
  =
  let   
    arg_2 =
      ErlangFun 2
        (let
           lambda_3 [(ErlangTuple [id_6,
                                   (ErlangTuple [attrs_7, sig_8, c_9])]),
                     acc_10]
             =
             let    head_12 = toErl 254
             in let head_16 = erlps__serialize_attributes__1 [attrs_7]
             in let head_19 = erlps__serialize_signature__1 [sig_8]
             in let head_22 = erlps__serialize_bbs__1 [c_9]
             in
               ErlangCons
                 (ErlangCons head_12
                    (ErlangCons id_6
                       (ErlangCons head_16
                          (ErlangCons head_19
                             (ErlangCons head_22 ErlangEmptyList)))))
                 acc_10
           lambda_3 [arg_4, arg_5] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 2 lambda_3) args
         in lambda_3)
  in let arg_28 = BIF.maps__to_list__1 [functions_0]
  in let
    arg_27 = BIF.do_remote_fun_call "Lists" "erlps__sort__1" [arg_28]
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
        [arg_2, ErlangEmptyList, arg_27]
  in BIF.erlang__iolist_to_binary__1 [arg_1]
erlps__serialize_functions__1 [arg_30] = EXC.function_clause unit
erlps__serialize_functions__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_attributes__1 :: ErlangFun
erlps__serialize_attributes__1 [attrs_0] =
  let   
    arg_1 =
      flmap
        (\ lc_4 ->
           let lcRet_5 = erlps__attr_value__1 [lc_4]
           in ErlangCons lcRet_5 ErlangEmptyList)
        attrs_0
  in let
    attrval_7 =
      BIF.do_remote_fun_call "Lists" "erlps__sum__1" [arg_1]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Encoding" "erlps__serialize__1"
      [attrval_7]
erlps__serialize_attributes__1 [arg_9] = EXC.function_clause unit
erlps__serialize_attributes__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__attr_value__1 :: ErlangFun
erlps__attr_value__1 [(ErlangAtom "private")] = toErl 1
erlps__attr_value__1 [(ErlangAtom "payable")] = toErl 2
erlps__attr_value__1 [arg_0] = EXC.function_clause unit
erlps__attr_value__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_signature__1 :: ErlangFun
erlps__serialize_signature__1 [(ErlangTuple [args_0, rettype_1])]
  =
  let    arg_3 = ErlangTuple [ErlangAtom "tuple", args_0]
  in let
    head_2 =
      BIF.do_remote_fun_call "Aeb.Fate.Encoding"
        "erlps__serialize_type__1" [arg_3]
  in let
    tail_6 =
      BIF.do_remote_fun_call "Aeb.Fate.Encoding"
        "erlps__serialize_type__1" [rettype_1]
  in ErlangCons head_2 tail_6
erlps__serialize_signature__1 [arg_8] = EXC.function_clause unit
erlps__serialize_signature__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_symbol_table__1 :: ErlangFun
erlps__serialize_symbol_table__1 [(ErlangTuple [(ErlangAtom "fcode"),
                                                _, symbols_0, _])]
  =
  let
    arg_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_map__1"
        [symbols_0]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Encoding" "erlps__serialize__1"
      [arg_1]
erlps__serialize_symbol_table__1 [arg_3] =
  EXC.function_clause unit
erlps__serialize_symbol_table__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_annotations__1 :: ErlangFun
erlps__serialize_annotations__1 [(ErlangTuple [(ErlangAtom "fcode"),
                                               _, _, annotations_0])]
  =
  let
    arg_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_map__1"
        [annotations_0]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Encoding" "erlps__serialize__1"
      [arg_1]
erlps__serialize_annotations__1 [arg_3] =
  EXC.function_clause unit
erlps__serialize_annotations__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_bbs__1 :: ErlangFun
erlps__serialize_bbs__1 [bbs_1@(ErlangMap map_0)] =
  let arg_3 = toErl 0
  in erlps__serialize_bbs__3 [bbs_1, arg_3, ErlangEmptyList]
erlps__serialize_bbs__1 [arg_5] = EXC.function_clause unit
erlps__serialize_bbs__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_bbs__3 :: ErlangFun
erlps__serialize_bbs__3 [bbs_0, n_1, acc_2] =
  let
    case_3 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [n_1, bbs_0, ErlangAtom "none"]
  in
    case case_3 of
      (ErlangAtom "none") ->
        BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_2]
      bb_8 ->
        let    rop_12 = toErl 1
        in let arg_10 = BIF.erlang__op_plus [n_1, rop_12]
        in let head_14 = erlps__serialize_bb__2 [bb_8, ErlangEmptyList]
        in
          erlps__serialize_bbs__3 [bbs_0, arg_10, ErlangCons head_14 acc_2]
erlps__serialize_bbs__3 [arg_18, arg_19, arg_20] =
  EXC.function_clause unit
erlps__serialize_bbs__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_bb__2 :: ErlangFun
erlps__serialize_bb__2 [(ErlangCons op_0 (ErlangEmptyList)),
                        acc_1]
  =
  let head_3 = erlps__serialize_op__1 [op_0]
  in
    BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
      [ErlangCons head_3 acc_1]
erlps__serialize_bb__2 [(ErlangCons op_0 rest_1), acc_2] =
  let head_5 = erlps__serialize_op__1 [op_0]
  in erlps__serialize_bb__2 [rest_1, ErlangCons head_5 acc_2]
erlps__serialize_bb__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__serialize_bb__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_op__1 :: ErlangFun
erlps__serialize_op__1 [op_0] =
  let    case_1 = BIF.erlang__is_tuple__1 [op_0]
  in let
    matchExpr_8 =
      case case_1 of
        (ErlangAtom "true") -> BIF.erlang__tuple_to_list__1 [op_0]
        (ErlangAtom "false") -> ErlangCons op_0 ErlangEmptyList
        something_else -> EXC.case_clause something_else
  in
    case matchExpr_8 of
      (ErlangCons mnemonic_6 args_7) ->
        let   
          head_9 =
            BIF.do_remote_fun_call "Aeb.Fate.Opcodes" "erlps__m_to_op__1"
              [mnemonic_6]
        in let tail_11 = erlps__serialize_code__1 [args_7]
        in ErlangCons head_9 tail_11
      _ -> EXC.badmatch matchExpr_8
erlps__serialize_op__1 [arg_13] = EXC.function_clause unit
erlps__serialize_op__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__sanity_check__1 :: ErlangFun
erlps__sanity_check__1 [(ErlangTuple [(ErlangAtom "fcode"),
                                      funs_0, _, _])]
  =
  let    lcSrc_1 = BIF.maps__to_list__1 [funs_0]
  in let
    matchExpr_16 =
      flmap
        (\ lc_5 ->
           case lc_5 of
             (ErlangTuple [id_3, def_4]) ->
               let
                 lcRet_6 =
                   case def_4 of
                     (ErlangTuple [_, _, bbs_8]) | ((ErlangAtom "true") ==
                                                      (falsifyErrors
                                                         (\ _ ->
                                                            let   
                                                              lop_9 =
                                                                BIF.erlang__byte_size__1
                                                                  [id_3]
                                                            in let
                                                              rop_11 = toErl 4
                                                            in
                                                              BIF.erlang__op_eq
                                                                [lop_9,
                                                                 rop_11]))) ->
                       erlps__sanity_check_bbs__1 [bbs_8]
                     _ ->
                       let
                         arg_13 =
                           ErlangTuple [ErlangAtom "illegal_function_id", id_3]
                       in BIF.erlang__error__1 [arg_13]
               in ErlangCons lcRet_6 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_1
  in ErlangAtom "ok"
erlps__sanity_check__1 [arg_17] = EXC.function_clause unit
erlps__sanity_check__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__sanity_check_bbs__1 :: ErlangFun
erlps__sanity_check_bbs__1 [bbs_1@(ErlangMap map_0)] =
  let arg_3 = toErl 0
  in erlps__sanity_check_bbs__2 [bbs_1, arg_3]
erlps__sanity_check_bbs__1 [arg_4] = EXC.function_clause unit
erlps__sanity_check_bbs__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__sanity_check_bbs__2 :: ErlangFun
erlps__sanity_check_bbs__2 [bbs_0, n_1] =
  let
    case_2 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [n_1, bbs_0, ErlangAtom "none"]
  in
    case case_2 of
      (ErlangAtom "none") ->
        let   
          lop_7 = BIF.do_remote_fun_call "Maps" "erlps__size__1" [bbs_0]
        in let case_6 = BIF.erlang__op_exactEq [lop_7, n_1]
        in
          case case_6 of
            (ErlangAtom "true") -> ErlangAtom "ok"
            (ErlangAtom "false") ->
              let    arg_13 = BIF.maps__keys__1 [bbs_0]
              in let
                tup_el_12 =
                  BIF.do_remote_fun_call "Lists" "erlps__sort__1" [arg_13]
              in let
                arg_10 =
                  ErlangTuple [ErlangAtom "not_contiguous_labels", tup_el_12]
              in BIF.erlang__error__1 [arg_10]
            something_else -> EXC.case_clause something_else
      (ErlangEmptyList) ->
        let arg_15 = ErlangTuple [ErlangAtom "empty_code_block", n_1]
        in BIF.erlang__error__1 [arg_15]
      bb_18 ->
        let    _ = erlps__sanity_check_bb__1 [bb_18]
        in let rop_23 = toErl 1
        in let arg_21 = BIF.erlang__op_plus [n_1, rop_23]
        in erlps__sanity_check_bbs__2 [bbs_0, arg_21]
erlps__sanity_check_bbs__2 [arg_24, arg_25] =
  EXC.function_clause unit
erlps__sanity_check_bbs__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__sanity_check_bb__1 :: ErlangFun
erlps__sanity_check_bb__1 [(ErlangCons op_0 (ErlangEmptyList))] =
  erlps__sanity_check_op__2 [ErlangAtom "true", op_0]
erlps__sanity_check_bb__1 [(ErlangCons op_0 rest_1)] =
  let _ = erlps__sanity_check_op__2 [ErlangAtom "false", op_0]
  in erlps__sanity_check_bb__1 [rest_1]
erlps__sanity_check_bb__1 [arg_5] = EXC.function_clause unit
erlps__sanity_check_bb__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__sanity_check_op__2 :: ErlangFun
erlps__sanity_check_op__2 [islast_0, op_1] =
  let    case_2 = BIF.erlang__is_tuple__1 [op_1]
  in let
    matchExpr_9 =
      case case_2 of
        (ErlangAtom "true") -> BIF.erlang__tuple_to_list__1 [op_1]
        (ErlangAtom "false") -> ErlangCons op_1 ErlangEmptyList
        something_else -> EXC.case_clause something_else
  in
    case matchExpr_9 of
      (ErlangCons mnemonic_7 args_8) ->
        let
          arg_11 =
            BIF.do_remote_fun_call "Aeb.Fate.Opcodes" "erlps__m_to_op__1"
              [mnemonic_7]
        in erlps__safe_sanity_check__3 [islast_0, arg_11, args_8]
      _ -> EXC.badmatch matchExpr_9
erlps__sanity_check_op__2 [arg_14, arg_15] =
  EXC.function_clause unit
erlps__sanity_check_op__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__safe_sanity_check__3 :: ErlangFun
erlps__safe_sanity_check__3 [islast_0, op_1, args_2] =
  let    lop_4 = BIF.erlang__length__1 [args_2]
  in let
    rop_6 =
      BIF.do_remote_fun_call "Aeb.Fate.Opcodes" "erlps__args__1" [op_1]
  in let case_3 = BIF.erlang__op_eq [lop_4, rop_6]
  in
    case case_3 of
      (ErlangAtom "true") ->
        let   
          rop_10 =
            BIF.do_remote_fun_call "Aeb.Fate.Opcodes" "erlps__end_bb__1"
              [op_1]
        in let case_8 = BIF.erlang__op_eq [islast_0, rop_10]
        in
          case case_8 of
            (ErlangAtom "true") -> ErlangAtom "ok"
            (ErlangAtom "false") ->
              let arg_12 = ErlangTuple [ErlangAtom "wrong_opcode_in_bb", op_1]
              in BIF.erlang__error__1 [arg_12]
            something_else -> EXC.case_clause something_else
      (ErlangAtom "false") ->
        let
          arg_15 = ErlangTuple [ErlangAtom "wrong_nr_args_opcode", op_1]
        in BIF.erlang__error__1 [arg_15]
      something_else -> EXC.case_clause something_else
erlps__safe_sanity_check__3 [arg_18, arg_19, arg_20] =
  EXC.function_clause unit
erlps__safe_sanity_check__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_code__1 :: ErlangFun
erlps__serialize_code__1 [list_0@(ErlangCons (ErlangTuple [_,
                                                           _]) _)]
  =
  let   
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [_, _])] = ErlangAtom "true"
           lambda_2 [_] = ErlangAtom "false"
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let
    matchExpr_7 =
      BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
        [arg_1, list_0]
  in
    case matchExpr_7 of
      (ErlangTuple [args_5, rest_6]) ->
        let   
          buildmods_27 =
            ErlangFun 2
              (let
                 buildmods_8 [(ErlangEmptyList), acc_11] = acc_11
                 buildmods_8 [(ErlangCons (ErlangTuple [type_12, x_13]) t_14),
                              acc_15]
                   =
                   let    rop_20 = toErl 2
                   in let lop_18 = BIF.erlang__bsl__2 [acc_15, rop_20]
                   in let lop_22 = erlps__modifier_bits__2 [type_12, x_13]
                   in let rop_25 = toErl 3
                   in let rop_21 = BIF.erlang__band__2 [lop_22, rop_25]
                   in let arg_17 = BIF.erlang__bor__2 [lop_18, rop_21]
                   in buildmods_8 [t_14, arg_17]
                 buildmods_8 [arg_9, arg_10] = EXC.function_clause unit
                 buildmods_8 args =
                   EXC.badarity
                     (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks")) args
               in buildmods_8)
        in let
          arg_28 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [args_5]
        in let padded_30 = erlps__pad_args__1 [arg_28]
        in let
          arg_32 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [args_5]
        in let arg_31 = erlps__pad_args__1 [arg_32]
        in let arg_34 = toErl 0
        in let
          modsunpadded_36 =
            BIF.erlang__apply__2
              [buildmods_27,
               ErlangCons arg_31 (ErlangCons arg_34 ErlangEmptyList)]
        in let case_37 = BIF.erlang__length__1 [padded_30]
        in let
          mods_43 =
            case case_37 of
              (ErlangInt num_39) | ((ErlangInt num_39) == (toErl 4)) ->
                ErlangBinary (BIN.fromInt modsunpadded_36 (toErl 8) 1 BIN.Big)
              (ErlangInt num_41) | ((ErlangInt num_41) == (toErl 8)) ->
                ErlangBinary (BIN.fromInt modsunpadded_36 (toErl 16) 1 BIN.Big)
              something_else -> EXC.case_clause something_else
        in
          case mods_43 of
            (ErlangBinary binSeg_45) | (ErlangInt size_46) <- (toErl 8)
                                     , (BIN.Ok m1_48 bin_47) <-
                                         (BIN.chopInt binSeg_45 size_46 1
                                            BIN.Big BIN.Unsigned)
                                     , (ErlangInt size_49) <- (toErl 8)
                                     , (BIN.Ok m2_51 bin_50) <-
                                         (BIN.chopInt bin_47 size_49 1 BIN.Big
                                            BIN.Unsigned)
                                     , BIN.empty bin_50 ->
              let   
                tail_56 =
                  flmap
                    (\ lc_60 ->
                       case lc_60 of
                         (ErlangTuple [type_58, arg_59]) ->
                           let
                             cond_61 =
                               BIF.erlang__op_exactNeq
                                 [type_58, ErlangAtom "stack"]
                           in
                             case cond_61 of
                               (ErlangAtom "true") ->
                                 let
                                   lcRet_64 =
                                     erlps__serialize_data__2 [type_58, arg_59]
                                 in ErlangCons lcRet_64 ErlangEmptyList
                               _ -> ErlangEmptyList
                         _ -> ErlangEmptyList)
                    args_5
              in let rop_67 = erlps__serialize_code__1 [rest_6]
              in
                BIF.erlang__op_append
                  [ErlangCons m1_48 (ErlangCons m2_51 tail_56), rop_67]
            (ErlangBinary binSeg_69) | (ErlangInt size_70) <- (toErl 8)
                                     , (BIN.Ok m1_72 bin_71) <-
                                         (BIN.chopInt binSeg_69 size_70 1
                                            BIN.Big BIN.Unsigned)
                                     , BIN.empty bin_71 ->
              let   
                tail_75 =
                  flmap
                    (\ lc_79 ->
                       case lc_79 of
                         (ErlangTuple [type_77, arg_78]) ->
                           let
                             cond_80 =
                               BIF.erlang__op_exactNeq
                                 [type_77, ErlangAtom "stack"]
                           in
                             case cond_80 of
                               (ErlangAtom "true") ->
                                 let
                                   lcRet_83 =
                                     erlps__serialize_data__2 [type_77, arg_78]
                                 in ErlangCons lcRet_83 ErlangEmptyList
                               _ -> ErlangEmptyList
                         _ -> ErlangEmptyList)
                    args_5
              in let rop_86 = erlps__serialize_code__1 [rest_6]
              in BIF.erlang__op_append [ErlangCons m1_72 tail_75, rop_86]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_7
erlps__serialize_code__1 [(ErlangCons op_0 rest_1)] =
  let tail_3 = erlps__serialize_code__1 [rest_1]
  in ErlangCons op_0 tail_3
erlps__serialize_code__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__serialize_code__1 [arg_0] = EXC.function_clause unit
erlps__serialize_code__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pad_args__1 :: ErlangFun
erlps__pad_args__1 [list_0] =
  let case_1 = BIF.erlang__length__1 [list_0]
  in
    case case_1 of
      (ErlangInt num_3) | ((ErlangInt num_3) == (toErl 0)) -> list_0
      n_4 | weakLeq n_4 (toErl 4) ->
        let    lop_7 = toErl 4
        in let arg_6 = BIF.erlang__op_minus [lop_7, n_4]
        in let tup_el_11 = toErl 0
        in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
        in let
          lop_5 =
            BIF.do_remote_fun_call "Lists" "erlps__duplicate__2"
              [arg_6, arg_9]
        in BIF.erlang__op_append [lop_5, list_0]
      n_13 | weakLeq n_13 (toErl 8) ->
        let    lop_16 = toErl 8
        in let arg_15 = BIF.erlang__op_minus [lop_16, n_13]
        in let tup_el_20 = toErl 0
        in let arg_18 = ErlangTuple [ErlangAtom "stack", tup_el_20]
        in let
          lop_14 =
            BIF.do_remote_fun_call "Lists" "erlps__duplicate__2"
              [arg_15, arg_18]
        in BIF.erlang__op_append [lop_14, list_0]
      something_else -> EXC.case_clause something_else
erlps__pad_args__1 [arg_22] = EXC.function_clause unit
erlps__pad_args__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_data__2 :: ErlangFun
erlps__serialize_data__2 [_, data_0] =
  BIF.do_remote_fun_call "Aeb.Fate.Encoding" "erlps__serialize__1"
    [data_0]
erlps__serialize_data__2 [arg_2, arg_3] =
  EXC.function_clause unit
erlps__serialize_data__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__modifier_bits__2 :: ErlangFun
erlps__modifier_bits__2 [(ErlangAtom "immediate"), _] = toErl 3
erlps__modifier_bits__2 [(ErlangAtom "var"), _] = toErl 2
erlps__modifier_bits__2 [(ErlangAtom "arg"), _] = toErl 1
erlps__modifier_bits__2 [(ErlangAtom "stack"), (ErlangInt num_0)]
  | ((ErlangInt num_0) == (toErl 0)) =
  toErl 0
erlps__modifier_bits__2 [type_0, x_1] =
  let
    arg_2 = ErlangTuple [ErlangAtom "illegal_argument", type_0, x_1]
  in BIF.erlang__error__1 [arg_2]
erlps__modifier_bits__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__modifier_bits__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__bits_to_modifier__1 :: ErlangFun
erlps__bits_to_modifier__1 [(ErlangInt num_0)]
  | ((ErlangInt num_0) == (toErl 3)) =
  ErlangAtom "immediate"
erlps__bits_to_modifier__1 [(ErlangInt num_0)]
  | ((ErlangInt num_0) == (toErl 2)) =
  ErlangAtom "var"
erlps__bits_to_modifier__1 [(ErlangInt num_0)]
  | ((ErlangInt num_0) == (toErl 1)) =
  ErlangAtom "arg"
erlps__bits_to_modifier__1 [(ErlangInt num_0)]
  | ((ErlangInt num_0) == (toErl 0)) =
  ErlangAtom "stack"
erlps__bits_to_modifier__1 [arg_1] = EXC.function_clause unit
erlps__bits_to_modifier__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize__1 :: ErlangFun
erlps__deserialize__1 [bytes_0] =
  let
    matchExpr_4 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__decode_one__1"
        [bytes_0]
  in
    case matchExpr_4 of
      (ErlangTuple [bytecode_2, rest1_3]) ->
        let
          matchExpr_8 =
            BIF.do_remote_fun_call "Aeser.Rlp" "erlps__decode_one__1"
              [rest1_3]
        in
          case matchExpr_8 of
            (ErlangTuple [symboltable_6, rest2_7]) ->
              let
                matchExpr_12 =
                  BIF.do_remote_fun_call "Aeser.Rlp" "erlps__decode_one__1"
                    [rest2_7]
              in
                case matchExpr_12 of
                  (ErlangTuple [annotations_10,
                                (ErlangBinary binEnd_11)]) | BIN.empty
                                                               binEnd_11 ->
                    let    val_19 = toErl 0
                    in let val_21 = ErlangMap Map.empty
                    in let val_22 = ErlangMap Map.empty
                    in let
                      env_23 =
                        ErlangMap
                          (Map.fromFoldable
                             [DT.Tuple (ErlangAtom "function")
                                (ErlangAtom "none"),
                              DT.Tuple (ErlangAtom "bb") val_19,
                              DT.Tuple (ErlangAtom "current_bb_code")
                                ErlangEmptyList,
                              DT.Tuple (ErlangAtom "functions") val_21,
                              DT.Tuple (ErlangAtom "code") val_22])
                    in let
                      tup_el_25 =
                        erlps__deserialize_functions__2 [bytecode_2, env_23]
                    in let
                      tup_el_28 = erlps__deserialize_symbols__1 [symboltable_6]
                    in let
                      tup_el_30 =
                        erlps__deserialize_annotations__1 [annotations_10]
                    in let
                      fcode_32 =
                        ErlangTuple
                          [ErlangAtom "fcode", tup_el_25, tup_el_28, tup_el_30]
                    in let _ = erlps__sanity_check__1 [fcode_32]
                    in fcode_32
                  _ -> EXC.badmatch matchExpr_12
            _ -> EXC.badmatch matchExpr_8
      _ -> EXC.badmatch matchExpr_4
erlps__deserialize__1 [arg_34] = EXC.function_clause unit
erlps__deserialize__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_functions__2 :: ErlangFun
erlps__deserialize_functions__2 [(ErlangBinary binSeg_0),
                                 env_21@(ErlangMap map_19)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 254))
  , (ErlangInt size_4) <- (toErl 8)
  , (BIN.Ok a_6 bin_5) <-
      (BIN.chopInt bin_2 size_4 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_7) <- (toErl 8)
  , (BIN.Ok b_9 bin_8) <-
      (BIN.chopInt bin_5 size_7 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_10) <- (toErl 8)
  , (BIN.Ok c_12 bin_11) <-
      (BIN.chopInt bin_8 size_10 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_13) <- (toErl 8)
  , (BIN.Ok d_15 bin_14) <-
      (BIN.chopInt bin_11 size_13 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_16) <- (BIN.size bin_14)
  , (BIN.Ok rest_18 bin_17) <- (BIN.chopBin bin_14 size_16 8)
  , BIN.empty bin_17
  , (DM.Just (ErlangEmptyList)) <-
      (Map.lookup (ErlangAtom "current_bb_code") map_19)
  , (DM.Just (ErlangInt num_20)) <-
      (Map.lookup (ErlangAtom "bb") map_19)
  , ((ErlangInt num_20) == (toErl 0))
  , (DM.Just (ErlangAtom "none")) <-
      (Map.lookup (ErlangAtom "function") map_19) =
  let matchExpr_25 = erlps__deserialize_attributes__1 [rest_18]
  in
    case matchExpr_25 of
      (ErlangTuple [attrs_23, rest2_24]) ->
        let matchExpr_29 = erlps__deserialize_signature__1 [rest2_24]
        in
          case matchExpr_29 of
            (ErlangTuple [sig_27, rest3_28]) ->
              let   
                tup_el_33 =
                  ErlangBinary
                    (BIN.concat
                       [BIN.fromInt a_6 (toErl 8) 1 BIN.Big,
                        BIN.fromInt b_9 (toErl 8) 1 BIN.Big,
                        BIN.fromInt c_12 (toErl 8) 1 BIN.Big,
                        BIN.fromInt d_15 (toErl 8) 1 BIN.Big])
              in let val_32 = ErlangTuple [tup_el_33, attrs_23, sig_27]
              in let
                mapExt_40 =
                  ErlangMap (Map.singleton (ErlangAtom "function") val_32)
              in let env2_42 = BIF.maps__merge__2 [env_21, mapExt_40]
              in erlps__deserialize_functions__2 [rest3_28, env2_42]
            _ -> EXC.badmatch matchExpr_29
      _ -> EXC.badmatch matchExpr_25
erlps__deserialize_functions__2 [(ErlangBinary binSeg_0),
                                 env_27@(ErlangMap map_19)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 254))
  , (ErlangInt size_4) <- (toErl 8)
  , (BIN.Ok a_6 bin_5) <-
      (BIN.chopInt bin_2 size_4 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_7) <- (toErl 8)
  , (BIN.Ok b_9 bin_8) <-
      (BIN.chopInt bin_5 size_7 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_10) <- (toErl 8)
  , (BIN.Ok c_12 bin_11) <-
      (BIN.chopInt bin_8 size_10 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_13) <- (toErl 8)
  , (BIN.Ok d_15 bin_14) <-
      (BIN.chopInt bin_11 size_13 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_16) <- (BIN.size bin_14)
  , (BIN.Ok rest_18 bin_17) <- (BIN.chopBin bin_14 size_16 8)
  , BIN.empty bin_17
  , (DM.Just funs_26) <-
      (Map.lookup (ErlangAtom "functions") map_19)
  , (DM.Just program_25) <- (Map.lookup (ErlangAtom "code") map_19)
  , (DM.Just code_24) <-
      (Map.lookup (ErlangAtom "current_bb_code") map_19)
  , (DM.Just bb_23) <- (Map.lookup (ErlangAtom "bb") map_19)
  , (DM.Just (ErlangTuple [f_20, attrs_21, sig_22])) <-
      (Map.lookup (ErlangAtom "function") map_19) =
  let matchExpr_31 = erlps__deserialize_attributes__1 [rest_18]
  in
    case matchExpr_31 of
      (ErlangTuple [newattrs_29, rest2_30]) ->
        let matchExpr_35 = erlps__deserialize_signature__1 [rest2_30]
        in
          case matchExpr_35 of
            (ErlangTuple [newsig_33, rest3_34]) ->
              case code_24 of
                (ErlangEmptyList) ->
                  let    val_43 = toErl 0
                  in let
                    tup_el_46 =
                      ErlangBinary
                        (BIN.concat
                           [BIN.fromInt a_6 (toErl 8) 1 BIN.Big,
                            BIN.fromInt b_9 (toErl 8) 1 BIN.Big,
                            BIN.fromInt c_12 (toErl 8) 1 BIN.Big,
                            BIN.fromInt d_15 (toErl 8) 1 BIN.Big])
                  in let
                    val_45 = ErlangTuple [tup_el_46, newattrs_29, newsig_33]
                  in let val_53 = ErlangMap Map.empty
                  in let val_57 = ErlangTuple [attrs_21, sig_22, program_25]
                  in let mapExt_61 = ErlangMap (Map.singleton f_20 val_57)
                  in let val_54 = BIF.maps__merge__2 [funs_26, mapExt_61]
                  in let
                    mapExt_63 =
                      ErlangMap
                        (Map.fromFoldable
                           [DT.Tuple (ErlangAtom "bb") val_43,
                            DT.Tuple (ErlangAtom "current_bb_code")
                              ErlangEmptyList,
                            DT.Tuple (ErlangAtom "function") val_45,
                            DT.Tuple (ErlangAtom "code") val_53,
                            DT.Tuple (ErlangAtom "functions") val_54])
                  in let env2_65 = BIF.maps__merge__2 [env_27, mapExt_63]
                  in erlps__deserialize_functions__2 [rest3_34, env2_65]
                _ ->
                  let    val_74 = toErl 0
                  in let
                    tup_el_77 =
                      ErlangBinary
                        (BIN.concat
                           [BIN.fromInt a_6 (toErl 8) 1 BIN.Big,
                            BIN.fromInt b_9 (toErl 8) 1 BIN.Big,
                            BIN.fromInt c_12 (toErl 8) 1 BIN.Big,
                            BIN.fromInt d_15 (toErl 8) 1 BIN.Big])
                  in let
                    val_76 = ErlangTuple [tup_el_77, newattrs_29, newsig_33]
                  in let val_84 = ErlangMap Map.empty
                  in let
                    val_94 =
                      BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
                        [code_24]
                  in let mapExt_96 = ErlangMap (Map.singleton bb_23 val_94)
                  in let tup_el_91 = BIF.maps__merge__2 [program_25, mapExt_96]
                  in let val_88 = ErlangTuple [attrs_21, sig_22, tup_el_91]
                  in let mapExt_98 = ErlangMap (Map.singleton f_20 val_88)
                  in let val_85 = BIF.maps__merge__2 [funs_26, mapExt_98]
                  in let
                    mapExt_100 =
                      ErlangMap
                        (Map.fromFoldable
                           [DT.Tuple (ErlangAtom "bb") val_74,
                            DT.Tuple (ErlangAtom "current_bb_code")
                              ErlangEmptyList,
                            DT.Tuple (ErlangAtom "function") val_76,
                            DT.Tuple (ErlangAtom "code") val_84,
                            DT.Tuple (ErlangAtom "functions") val_85])
                  in let env2_102 = BIF.maps__merge__2 [env_27, mapExt_100]
                  in erlps__deserialize_functions__2 [rest3_34, env2_102]
            _ -> EXC.badmatch matchExpr_35
      _ -> EXC.badmatch matchExpr_31
erlps__deserialize_functions__2 [(ErlangBinary binSeg_0),
                                 (ErlangMap map_7)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok _op_3 bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok _rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5
  , (DM.Just (ErlangAtom "none")) <-
      (Map.lookup (ErlangAtom "function") map_7) =
  let arg_8 = ErlangTuple [ErlangAtom "code_without_function"]
  in BIF.erlang__error__1 [arg_8]
erlps__deserialize_functions__2 [(ErlangBinary binSeg_0),
                                 env_11@(ErlangMap map_7)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok op_3 bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5
  , (DM.Just program_10) <- (Map.lookup (ErlangAtom "code") map_7)
  , (DM.Just code_9) <-
      (Map.lookup (ErlangAtom "current_bb_code") map_7)
  , (DM.Just bb_8) <- (Map.lookup (ErlangAtom "bb") map_7) =
  let
    matchExpr_17 = erlps__deserialize_op__3 [op_3, rest_6, code_9]
  in
    case matchExpr_17 of
      (ErlangTuple [rest2_15, opcode_16]) ->
        let
          case_18 =
            BIF.do_remote_fun_call "Aeb.Fate.Opcodes" "erlps__end_bb__1"
              [op_3]
        in
          case case_18 of
            (ErlangAtom "true") ->
              let    rop_28 = toErl 1
              in let val_26 = BIF.erlang__op_plus [bb_8, rop_28]
              in let
                val_33 =
                  BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [opcode_16]
              in let mapExt_35 = ErlangMap (Map.singleton bb_8 val_33)
              in let val_30 = BIF.maps__merge__2 [program_10, mapExt_35]
              in let
                mapExt_37 =
                  ErlangMap
                    (Map.fromFoldable
                       [DT.Tuple (ErlangAtom "bb") val_26,
                        DT.Tuple (ErlangAtom "current_bb_code") ErlangEmptyList,
                        DT.Tuple (ErlangAtom "code") val_30])
              in let arg_21 = BIF.maps__merge__2 [env_11, mapExt_37]
              in erlps__deserialize_functions__2 [rest2_15, arg_21]
            (ErlangAtom "false") ->
              let   
                mapExt_44 =
                  ErlangMap
                    (Map.singleton (ErlangAtom "current_bb_code") opcode_16)
              in let arg_40 = BIF.maps__merge__2 [env_11, mapExt_44]
              in erlps__deserialize_functions__2 [rest2_15, arg_40]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_17
erlps__deserialize_functions__2 [(ErlangBinary binEnd_0),
                                 (ErlangMap map_1)]
  | BIN.empty binEnd_0
  , (DM.Just funs_2) <- (Map.lookup (ErlangAtom "functions") map_1)
  , (DM.Just (ErlangAtom "none")) <-
      (Map.lookup (ErlangAtom "function") map_1) =
  funs_2
erlps__deserialize_functions__2 [(ErlangBinary binEnd_0),
                                 (ErlangMap map_1)]
  | BIN.empty binEnd_0
  , (DM.Just funs_8) <- (Map.lookup (ErlangAtom "functions") map_1)
  , (DM.Just program_7) <- (Map.lookup (ErlangAtom "code") map_1)
  , (DM.Just code_6) <-
      (Map.lookup (ErlangAtom "current_bb_code") map_1)
  , (DM.Just bb_5) <- (Map.lookup (ErlangAtom "bb") map_1)
  , (DM.Just (ErlangTuple [f_2, attrs_3, sig_4])) <-
      (Map.lookup (ErlangAtom "function") map_1) =
  let   
    functioncode_16 =
      case code_6 of
        (ErlangEmptyList) -> program_7
        _ ->
          let   
            val_12 =
              BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [code_6]
          in let mapExt_14 = ErlangMap (Map.singleton bb_5 val_12)
          in BIF.maps__merge__2 [program_7, mapExt_14]
  in let val_19 = ErlangTuple [attrs_3, sig_4, functioncode_16]
  in let mapExt_23 = ErlangMap (Map.singleton f_2 val_19)
  in BIF.maps__merge__2 [funs_8, mapExt_23]
erlps__deserialize_functions__2 [arg_25, arg_26] =
  EXC.function_clause unit
erlps__deserialize_functions__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_op__3 :: ErlangFun
erlps__deserialize_op__3 [op_0, rest_1, code_2] =
  let   
    opname_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Opcodes" "erlps__mnemonic__1"
        [op_0]
  in let
    case_5 =
      BIF.do_remote_fun_call "Aeb.Fate.Opcodes" "erlps__args__1" [op_0]
  in
    case case_5 of
      (ErlangInt num_7) | ((ErlangInt num_7) == (toErl 0)) ->
        ErlangTuple [rest_1, ErlangCons opname_4 code_2]
      n_12 ->
        let matchExpr_17 = erlps__deserialize_n_args__2 [n_12, rest_1]
        in
          case matchExpr_17 of
            (ErlangTuple [args_15, rest1_16]) ->
              let
                head_20 =
                  BIF.erlang__list_to_tuple__1 [ErlangCons opname_4 args_15]
              in ErlangTuple [rest1_16, ErlangCons head_20 code_2]
            _ -> EXC.badmatch matchExpr_17
erlps__deserialize_op__3 [arg_25, arg_26, arg_27] =
  EXC.function_clause unit
erlps__deserialize_op__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_n_args__2 :: ErlangFun
erlps__deserialize_n_args__2 [n_0, (ErlangBinary binSeg_1)]
  | (ErlangInt size_2) <- (toErl 8)
  , (BIN.Ok bin_4 bin_3) <-
      (BIN.chopInt binSeg_1 size_2 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_5) <- (BIN.size bin_3)
  , (BIN.Ok rest_7 bin_6) <- (BIN.chopBin bin_3 size_5 8)
  , BIN.empty bin_6
  , weakLeq n_0 (toErl 4) =
  let    rop_10 = toErl 192
  in let lop_8 = BIF.erlang__band__2 [bin_4, rop_10]
  in let rop_11 = toErl 6
  in let m3_12 = BIF.erlang__bsr__2 [lop_8, rop_11]
  in let rop_15 = toErl 48
  in let lop_13 = BIF.erlang__band__2 [bin_4, rop_15]
  in let rop_16 = toErl 4
  in let m2_17 = BIF.erlang__bsr__2 [lop_13, rop_16]
  in let rop_20 = toErl 12
  in let lop_18 = BIF.erlang__band__2 [bin_4, rop_20]
  in let rop_21 = toErl 2
  in let m1_22 = BIF.erlang__bsr__2 [lop_18, rop_21]
  in let rop_24 = toErl 3
  in let m0_25 = BIF.erlang__band__2 [bin_4, rop_24]
  in let
    matchExpr_38 =
      BIF.do_remote_fun_call "Lists" "erlps__split__2"
        [n_0,
         ErlangCons m0_25
           (ErlangCons m1_22
              (ErlangCons m2_17 (ErlangCons m3_12 ErlangEmptyList)))]
  in
    case matchExpr_38 of
      (ErlangTuple [argmods_36, zeros_37]) ->
        let    _ = erlps__assert_zero__1 [zeros_37]
        in let
          arg_40 =
            ErlangFun 2
              (let
                 lambda_41 [m_44, acc_45] =
                   let case_46 = erlps__bits_to_modifier__1 [m_44]
                   in
                     case case_46 of
                       (ErlangAtom "stack") ->
                         let    tup_el_50 = toErl 0
                         in let
                           tup_el_48 =
                             ErlangTuple [ErlangAtom "stack", tup_el_50]
                         in ErlangTuple [tup_el_48, acc_45]
                       modifier_52 ->
                         let
                           matchExpr_56 =
                             BIF.do_remote_fun_call "Aeb.Fate.Encoding"
                               "erlps__deserialize_one__1" [acc_45]
                         in
                           case matchExpr_56 of
                             (ErlangTuple [arg_54, acc2_55]) ->
                               let tup_el_57 = ErlangTuple [modifier_52, arg_54]
                               in ErlangTuple [tup_el_57, acc2_55]
                             _ -> EXC.badmatch matchExpr_56
                 lambda_41 [arg_42, arg_43] = EXC.function_clause unit
                 lambda_41 args = EXC.badarity (ErlangFun 2 lambda_41) args
               in lambda_41)
        in
          BIF.do_remote_fun_call "Lists" "erlps__mapfoldl__3"
            [arg_40, rest_7, argmods_36]
      _ -> EXC.badmatch matchExpr_38
erlps__deserialize_n_args__2 [n_0, (ErlangBinary binSeg_1)]
  | (ErlangInt size_2) <- (toErl 16)
  , (BIN.Ok bin_4 bin_3) <-
      (BIN.chopInt binSeg_1 size_2 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_5) <- (BIN.size bin_3)
  , (BIN.Ok rest_7 bin_6) <- (BIN.chopBin bin_3 size_5 8)
  , BIN.empty bin_6
  , weakLeq n_0 (toErl 8) =
  let    rop_10 = toErl 49152
  in let lop_8 = BIF.erlang__band__2 [bin_4, rop_10]
  in let rop_11 = toErl 14
  in let m7_12 = BIF.erlang__bsr__2 [lop_8, rop_11]
  in let rop_15 = toErl 12288
  in let lop_13 = BIF.erlang__band__2 [bin_4, rop_15]
  in let rop_16 = toErl 12
  in let m6_17 = BIF.erlang__bsr__2 [lop_13, rop_16]
  in let rop_20 = toErl 3072
  in let lop_18 = BIF.erlang__band__2 [bin_4, rop_20]
  in let rop_21 = toErl 10
  in let m5_22 = BIF.erlang__bsr__2 [lop_18, rop_21]
  in let rop_25 = toErl 768
  in let lop_23 = BIF.erlang__band__2 [bin_4, rop_25]
  in let rop_26 = toErl 8
  in let m4_27 = BIF.erlang__bsr__2 [lop_23, rop_26]
  in let rop_30 = toErl 192
  in let lop_28 = BIF.erlang__band__2 [bin_4, rop_30]
  in let rop_31 = toErl 6
  in let m3_32 = BIF.erlang__bsr__2 [lop_28, rop_31]
  in let rop_35 = toErl 48
  in let lop_33 = BIF.erlang__band__2 [bin_4, rop_35]
  in let rop_36 = toErl 4
  in let m2_37 = BIF.erlang__bsr__2 [lop_33, rop_36]
  in let rop_40 = toErl 12
  in let lop_38 = BIF.erlang__band__2 [bin_4, rop_40]
  in let rop_41 = toErl 2
  in let m1_42 = BIF.erlang__bsr__2 [lop_38, rop_41]
  in let rop_44 = toErl 3
  in let m0_45 = BIF.erlang__band__2 [bin_4, rop_44]
  in let
    matchExpr_66 =
      BIF.do_remote_fun_call "Lists" "erlps__split__2"
        [n_0,
         ErlangCons m0_45
           (ErlangCons m1_42
              (ErlangCons m2_37
                 (ErlangCons m3_32
                    (ErlangCons m4_27
                       (ErlangCons m5_22
                          (ErlangCons m6_17
                             (ErlangCons m7_12 ErlangEmptyList)))))))]
  in
    case matchExpr_66 of
      (ErlangTuple [argmods_64, zeros_65]) ->
        let    _ = erlps__assert_zero__1 [zeros_65]
        in let
          arg_68 =
            ErlangFun 2
              (let
                 lambda_69 [m_72, acc_73] =
                   let case_74 = erlps__bits_to_modifier__1 [m_72]
                   in
                     case case_74 of
                       (ErlangAtom "stack") ->
                         let    tup_el_78 = toErl 0
                         in let
                           tup_el_76 =
                             ErlangTuple [ErlangAtom "stack", tup_el_78]
                         in ErlangTuple [tup_el_76, acc_73]
                       modifier_80 ->
                         let
                           matchExpr_84 =
                             BIF.do_remote_fun_call "Aeb.Fate.Encoding"
                               "erlps__deserialize_one__1" [acc_73]
                         in
                           case matchExpr_84 of
                             (ErlangTuple [arg_82, acc2_83]) ->
                               let tup_el_85 = ErlangTuple [modifier_80, arg_82]
                               in ErlangTuple [tup_el_85, acc2_83]
                             _ -> EXC.badmatch matchExpr_84
                 lambda_69 [arg_70, arg_71] = EXC.function_clause unit
                 lambda_69 args = EXC.badarity (ErlangFun 2 lambda_69) args
               in lambda_69)
        in
          BIF.do_remote_fun_call "Lists" "erlps__mapfoldl__3"
            [arg_68, rest_7, argmods_64]
      _ -> EXC.badmatch matchExpr_66
erlps__deserialize_n_args__2 [arg_91, arg_92] =
  EXC.function_clause unit
erlps__deserialize_n_args__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_attributes__1 :: ErlangFun
erlps__deserialize_attributes__1 [binary_0] =
  let
    matchExpr_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Encoding"
        "erlps__deserialize_one__1" [binary_0]
  in
    case matchExpr_4 of
      (ErlangTuple [attrval_2, rest_3]) ->
        let    arg_6 = toErl 1
        in let lcSrc_5 = erlps__attr_vals__2 [arg_6, attrval_2]
        in let
          attrs_12 =
            flmap
              (\ lc_9 ->
                 let lcRet_10 = erlps__attr__1 [lc_9]
                 in ErlangCons lcRet_10 ErlangEmptyList)
              lcSrc_5
        in let
          tup_el_13 =
            BIF.do_remote_fun_call "Lists" "erlps__sort__1" [attrs_12]
        in ErlangTuple [tup_el_13, rest_3]
      _ -> EXC.badmatch matchExpr_4
erlps__deserialize_attributes__1 [arg_16] =
  EXC.function_clause unit
erlps__deserialize_attributes__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__attr_vals__2 :: ErlangFun
erlps__attr_vals__2 [_, (ErlangInt num_0)]
  | ((ErlangInt num_0) == (toErl 0)) =
  ErlangEmptyList
erlps__attr_vals__2 [x_0, n_1]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_10 = toErl 2
             in let lop_8 = BIF.erlang__op_rem_strict [n_1, rop_10]
             in let rop_11 = toErl 0
             in BIF.erlang__op_eq [lop_8, rop_11]))) =
  let    rop_4 = toErl 1
  in let arg_2 = BIF.erlang__op_plus [x_0, rop_4]
  in let rop_7 = toErl 2
  in let arg_5 = BIF.erlang__op_div_strict [n_1, rop_7]
  in erlps__attr_vals__2 [arg_2, arg_5]
erlps__attr_vals__2 [x_0, n_1] =
  let    rop_6 = toErl 1
  in let arg_4 = BIF.erlang__op_plus [x_0, rop_6]
  in let rop_9 = toErl 2
  in let arg_7 = BIF.erlang__op_div_strict [n_1, rop_9]
  in let tail_3 = erlps__attr_vals__2 [arg_4, arg_7]
  in ErlangCons x_0 tail_3
erlps__attr_vals__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__attr_vals__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__attr__1 :: ErlangFun
erlps__attr__1 [(ErlangInt num_0)]
  | ((ErlangInt num_0) == (toErl 1)) =
  ErlangAtom "private"
erlps__attr__1 [(ErlangInt num_0)]
  | ((ErlangInt num_0) == (toErl 2)) =
  ErlangAtom "payable"
erlps__attr__1 [arg_1] = EXC.function_clause unit
erlps__attr__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_signature__1 :: ErlangFun
erlps__deserialize_signature__1 [binary_0] =
  let
    matchExpr_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Encoding"
        "erlps__deserialize_type__1" [binary_0]
  in
    case matchExpr_4 of
      (ErlangTuple [(ErlangTuple [(ErlangAtom "tuple"), args_2]),
                    rest_3]) ->
        let
          matchExpr_8 =
            BIF.do_remote_fun_call "Aeb.Fate.Encoding"
              "erlps__deserialize_type__1" [rest_3]
        in
          case matchExpr_8 of
            (ErlangTuple [rettype_6, rest2_7]) ->
              let tup_el_9 = ErlangTuple [args_2, rettype_6]
              in ErlangTuple [tup_el_9, rest2_7]
            _ -> EXC.badmatch matchExpr_8
      _ -> EXC.badmatch matchExpr_4
erlps__deserialize_signature__1 [arg_13] =
  EXC.function_clause unit
erlps__deserialize_signature__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_symbols__1 :: ErlangFun
erlps__deserialize_symbols__1 [table_0] =
  let
    symboltable_2 =
      BIF.do_remote_fun_call "Aeb.Fate.Encoding"
        "erlps__deserialize__1" [table_0]
  in symboltable_2
erlps__deserialize_symbols__1 [arg_3] = EXC.function_clause unit
erlps__deserialize_symbols__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_annotations__1 :: ErlangFun
erlps__deserialize_annotations__1 [annotationsbin_0] =
  let
    annotations_2 =
      BIF.do_remote_fun_call "Aeb.Fate.Encoding"
        "erlps__deserialize__1" [annotationsbin_0]
  in annotations_2
erlps__deserialize_annotations__1 [arg_3] =
  EXC.function_clause unit
erlps__deserialize_annotations__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assert_zero__1 :: ErlangFun
erlps__assert_zero__1 [(ErlangEmptyList)] = ErlangAtom "true"
erlps__assert_zero__1 [(ErlangCons (ErlangInt num_0) rest_1)]
  | ((ErlangInt num_0) == (toErl 0)) =
  erlps__assert_zero__1 [rest_1]
erlps__assert_zero__1 [(ErlangCons _ _)] =
  BIF.erlang__error__1
    [ErlangAtom "argument_defined_outside_range"]
erlps__assert_zero__1 [arg_1] = EXC.function_clause unit
erlps__assert_zero__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args