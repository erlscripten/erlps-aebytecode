module Aeb.Fate.Encoding(erlps__deserialize__1,
                         erlps__deserialize_one__1, erlps__deserialize_type__1,
                         erlps__serialize__1, erlps__serialize_type__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__serialize__1 :: ErlangFun
erlps__serialize__1 [(ErlangAtom "true")] =
  let bin_el_0 = toErl 255
  in ErlangBinary (BIN.fromInt bin_el_0 (toErl 8) 1 BIN.Big)
erlps__serialize__1 [(ErlangAtom "false")] =
  let bin_el_0 = toErl 127
  in ErlangBinary (BIN.fromInt bin_el_0 (toErl 8) 1 BIN.Big)
erlps__serialize__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                   (ErlangTuple [])])]
  =
  let bin_el_0 = toErl 63
  in ErlangBinary (BIN.fromInt bin_el_0 (toErl 8) 1 BIN.Big)
erlps__serialize__1 [(ErlangBinary binEnd_0)]
  | BIN.empty binEnd_0 =
  let bin_el_1 = toErl 95
  in ErlangBinary (BIN.fromInt bin_el_1 (toErl 8) 1 BIN.Big)
erlps__serialize__1 [i_0] | isEInt i_0 =
  erlps__serialize_integer__1 [i_0]
erlps__serialize__1 args = erlps__serialize__1__p1 args

erlps__serialize__1__p1 :: ErlangFun
erlps__serialize__1__p1 [(ErlangTuple [(ErlangAtom "bits"),
                                       bits_0])]
  | isEInt bits_0 =
  erlps__serialize_bits__1 [bits_0]
erlps__serialize__1__p1 [string_0]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    lop_16 = BIF.erlang__is_binary__1 [string_0]
             in let
               lop_15 =
                 case lop_16 of
                   (ErlangAtom "false") -> ErlangAtom "false"
                   (ErlangAtom "true") ->
                     let    lop_18 = BIF.erlang__byte_size__1 [string_0]
                     in let rop_20 = toErl 0
                     in BIF.erlang__op_greater [lop_18, rop_20]
                   _ -> EXC.badarg1 lop_16
             in
               case lop_15 of
                 (ErlangAtom "false") -> ErlangAtom "false"
                 (ErlangAtom "true") ->
                   let    lop_21 = BIF.erlang__byte_size__1 [string_0]
                   in let rop_23 = toErl 64
                   in BIF.erlang__op_lesser [lop_21, rop_23]
                 _ -> EXC.badarg1 lop_15))) =
  let    size_2 = BIF.erlang__byte_size__1 [string_0]
  in let rop_7 = toErl 2
  in let lop_5 = BIF.erlang__bsl__2 [size_2, rop_7]
  in let rop_8 = toErl 252
  in let lop_4 = BIF.erlang__band__2 [lop_5, rop_8]
  in let lop_10 = toErl 1
  in let rop_11 = toErl 3
  in let rop_9 = BIF.erlang__band__2 [lop_10, rop_11]
  in let bin_12 = BIF.erlang__bor__2 [lop_4, rop_9]
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_12 (toErl 8) 1 BIN.Big,
          BIN.binPrefix string_0 (BIN.packedSize string_0) 8])
erlps__serialize__1__p1 [string_0]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    lop_10 = BIF.erlang__is_binary__1 [string_0]
             in let
               lop_9 =
                 case lop_10 of
                   (ErlangAtom "false") -> ErlangAtom "false"
                   (ErlangAtom "true") ->
                     let    lop_12 = BIF.erlang__byte_size__1 [string_0]
                     in let rop_14 = toErl 0
                     in BIF.erlang__op_greater [lop_12, rop_14]
                   _ -> EXC.badarg1 lop_10
             in
               case lop_9 of
                 (ErlangAtom "false") -> ErlangAtom "false"
                 (ErlangAtom "true") ->
                   let    lop_15 = BIF.erlang__byte_size__1 [string_0]
                   in let rop_17 = toErl 64
                   in BIF.erlang__op_greaterEq [lop_15, rop_17]
                 _ -> EXC.badarg1 lop_9))) =
  let    bin_el_2 = toErl 1
  in let lop_5 = BIF.erlang__byte_size__1 [string_0]
  in let rop_7 = toErl 64
  in let arg_4 = BIF.erlang__op_minus [lop_5, rop_7]
  in let bin_el_3 = erlps__serialize_integer__1 [arg_4]
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
          BIN.binPrefix bin_el_3 (BIN.packedSize bin_el_3) 8,
          BIN.binPrefix string_0 (BIN.packedSize string_0) 8])
erlps__serialize__1__p1 [(ErlangTuple [(ErlangAtom "bytes"),
                                       bytes_0])]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [bytes_0]))) =
  let    bin_el_1 = toErl 159
  in let bin_el_2 = toErl 1
  in let bin_el_3 = erlps__serialize__1 [bytes_0]
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_el_1 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
          BIN.binPrefix bin_el_3 (BIN.packedSize bin_el_3) 8])
erlps__serialize__1__p1 [(ErlangTuple [(ErlangAtom "address"),
                                       address_0])]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [address_0]))) =
  let    bin_el_1 = toErl 159
  in let bin_el_2 = toErl 0
  in let
    bin_el_3 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__encode__1" [address_0]
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_el_1 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
          BIN.binPrefix bin_el_3 (BIN.packedSize bin_el_3) 8])
erlps__serialize__1__p1 args = erlps__serialize__1__p2 args

erlps__serialize__1__p2 :: ErlangFun
erlps__serialize__1__p2 [(ErlangTuple [(ErlangAtom "contract"),
                                       address_0])]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [address_0]))) =
  let    bin_el_1 = toErl 159
  in let bin_el_2 = toErl 2
  in let
    bin_el_3 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__encode__1" [address_0]
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_el_1 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
          BIN.binPrefix bin_el_3 (BIN.packedSize bin_el_3) 8])
erlps__serialize__1__p2 [(ErlangTuple [(ErlangAtom "oracle"),
                                       address_0])]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [address_0]))) =
  let    bin_el_1 = toErl 159
  in let bin_el_2 = toErl 3
  in let
    bin_el_3 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__encode__1" [address_0]
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_el_1 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
          BIN.binPrefix bin_el_3 (BIN.packedSize bin_el_3) 8])
erlps__serialize__1__p2 [(ErlangTuple [(ErlangAtom "oracle_query"),
                                       address_0])]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [address_0]))) =
  let    bin_el_1 = toErl 159
  in let bin_el_2 = toErl 4
  in let
    bin_el_3 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__encode__1" [address_0]
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_el_1 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
          BIN.binPrefix bin_el_3 (BIN.packedSize bin_el_3) 8])
erlps__serialize__1__p2 [(ErlangTuple [(ErlangAtom "channel"),
                                       address_0])]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [address_0]))) =
  let    bin_el_1 = toErl 159
  in let bin_el_2 = toErl 5
  in let
    bin_el_3 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__encode__1" [address_0]
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_el_1 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
          BIN.binPrefix bin_el_3 (BIN.packedSize bin_el_3) 8])
erlps__serialize__1__p2 [(ErlangTuple [(ErlangAtom "tuple"),
                                       t_0])]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    lop_30 = BIF.erlang__size__1 [t_0]
             in let rop_32 = toErl 0
             in BIF.erlang__op_greater [lop_30, rop_32]))) =
  let    s_2 = BIF.erlang__size__1 [t_0]
  in let l_4 = BIF.erlang__tuple_to_list__1 [t_0]
  in let
    rest_11 =
      BIN.concatErl
        (flmap
           (\ lc_7 ->
              let    bin_el_9 = erlps__serialize__1 [lc_7]
              in let
                lcRet_8 =
                  ErlangBinary
                    (BIN.binPrefix bin_el_9 (BIN.packedSize bin_el_9) 8)
              in ErlangCons lcRet_8 ErlangEmptyList)
           l_4)
  in
    case ErlangAtom "true" of
      _ | weakLt s_2 (toErl 16) ->
        let    rop_15 = toErl 4
        in let lop_13 = BIF.erlang__bsl__2 [s_2, rop_15]
        in let rop_16 = toErl 240
        in let lop_12 = BIF.erlang__band__2 [lop_13, rop_16]
        in let lop_18 = toErl 11
        in let rop_19 = toErl 15
        in let rop_17 = BIF.erlang__band__2 [lop_18, rop_19]
        in let bin_20 = BIF.erlang__bor__2 [lop_12, rop_17]
        in
          ErlangBinary
            (BIN.concat
               [BIN.fromInt bin_20 (toErl 8) 1 BIN.Big,
                BIN.binPrefix rest_11 (BIN.packedSize rest_11) 8])
      _ ->
        let    rop_25 = toErl 16
        in let arg_23 = BIF.erlang__op_minus [s_2, rop_25]
        in let size_26 = erlps__rlp_encode_int__1 [arg_23]
        in let bin_el_27 = toErl 11
        in
          ErlangBinary
            (BIN.concat
               [BIN.fromInt bin_el_27 (toErl 8) 1 BIN.Big,
                BIN.binPrefix size_26 (BIN.packedSize size_26) 8,
                BIN.binPrefix rest_11 (BIN.packedSize rest_11) 8])
erlps__serialize__1__p2 args = erlps__serialize__1__p3 args

erlps__serialize__1__p3 :: ErlangFun
erlps__serialize__1__p3 [l_0] | isEList l_0 =
  let    s_3 = BIF.erlang__length__1 [l_0]
  in let
    rest_10 =
      BIN.concatErl
        (flmap
           (\ lc_6 ->
              let    bin_el_8 = erlps__serialize__1 [lc_6]
              in let
                lcRet_7 =
                  ErlangBinary
                    (BIN.binPrefix bin_el_8 (BIN.packedSize bin_el_8) 8)
              in ErlangCons lcRet_7 ErlangEmptyList)
           l_0)
  in
    case ErlangAtom "true" of
      _ | weakLt s_3 (toErl 16) ->
        let    rop_14 = toErl 4
        in let lop_12 = BIF.erlang__bsl__2 [s_3, rop_14]
        in let rop_15 = toErl 240
        in let lop_11 = BIF.erlang__band__2 [lop_12, rop_15]
        in let lop_17 = toErl 3
        in let rop_18 = toErl 15
        in let rop_16 = BIF.erlang__band__2 [lop_17, rop_18]
        in let bin_19 = BIF.erlang__bor__2 [lop_11, rop_16]
        in
          ErlangBinary
            (BIN.concat
               [BIN.fromInt bin_19 (toErl 8) 1 BIN.Big,
                BIN.binPrefix rest_10 (BIN.packedSize rest_10) 8])
      _ ->
        let    rop_24 = toErl 16
        in let arg_22 = BIF.erlang__op_minus [s_3, rop_24]
        in let val_25 = erlps__rlp_encode_int__1 [arg_22]
        in let bin_el_26 = toErl 31
        in
          ErlangBinary
            (BIN.concat
               [BIN.fromInt bin_el_26 (toErl 8) 1 BIN.Big,
                BIN.binPrefix val_25 (BIN.packedSize val_25) 8,
                BIN.binPrefix rest_10 (BIN.packedSize rest_10) 8])
erlps__serialize__1__p3 [map_0] | isEMap map_0 =
  let    l_2 = BIF.maps__to_list__1 [map_0]
  in let size_4 = BIF.erlang__length__1 [l_2]
  in let lcSrc_6 = erlps__sort_and_check__1 [l_2]
  in let
    arg_5 =
      flmap
        (\ lc_10 ->
           case lc_10 of
             (ErlangTuple [k_8, v_9]) ->
               let    bin_el_12 = erlps__serialize__1 [k_8]
               in let bin_el_14 = erlps__serialize__1 [v_9]
               in let
                 lcRet_11 =
                   ErlangBinary
                     (BIN.concat
                        [BIN.binPrefix bin_el_12 (BIN.packedSize bin_el_12) 8,
                         BIN.binPrefix bin_el_14 (BIN.packedSize bin_el_14) 8])
               in ErlangCons lcRet_11 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_6
  in let elements_16 = BIF.erlang__list_to_binary__1 [arg_5]
  in let bin_el_17 = toErl 47
  in let bin_el_18 = erlps__rlp_encode_int__1 [size_4]
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_el_17 (toErl 8) 1 BIN.Big,
          BIN.binPrefix bin_el_18 (BIN.packedSize bin_el_18) 8,
          BIN.binPrefix elements_16 (BIN.packedSize elements_16) 8])
erlps__serialize__1__p3 [(ErlangTuple [(ErlangAtom "store_map"),
                                       cache_0, id_1])]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let rop_6 = ErlangMap Map.empty
             in BIF.erlang__op_exactEq [cache_0, rop_6]))) =
  let    bin_el_2 = toErl 191
  in let bin_el_3 = erlps__rlp_encode_int__1 [id_1]
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
          BIN.binPrefix bin_el_3 (BIN.packedSize bin_el_3) 8])
erlps__serialize__1__p3 [(ErlangTuple [(ErlangAtom "variant"),
                                       arities_0, tag_1, values_2])]
  =
  let
    matchExpr_13 =
      flmap
        (\ lc_5 ->
           let cond_6 = BIF.erlang__is_integer__1 [lc_5]
           in
             case cond_6 of
               (ErlangAtom "true") ->
                 let    rop_10 = toErl 256
                 in let cond_8 = BIF.erlang__op_lesser [lc_5, rop_10]
                 in
                   case cond_8 of
                     (ErlangAtom "true") -> ErlangCons lc_5 ErlangEmptyList
                     _ -> ErlangEmptyList
               _ -> ErlangEmptyList)
        arities_0
  in
    case matchExpr_13 of
      arities_12 | (arities_12 == arities_0) ->
        let size_15 = BIF.erlang__length__1 [arities_0]
        in
          case ErlangAtom "true" of
            _ | ((((isEInt tag_1) && (weakLeq (toErl 0) tag_1)) &&
                    (weakLt tag_1 size_15)) &&
                   (isETuple values_2)) ->
              let    rop_18 = toErl 1
              in let arg_16 = BIF.erlang__op_plus [tag_1, rop_18]
              in let
                arity_20 =
                  BIF.do_remote_fun_call "Lists" "erlps__nth__2"
                    [arg_16, arities_0]
              in
                case ErlangAtom "true" of
                  _ | ((ErlangAtom "true") ==
                         (falsifyErrors
                            (\ _ ->
                               let lop_21 = BIF.erlang__size__1 [values_2]
                               in
                                 BIF.erlang__op_exactEq [lop_21, arity_20]))) ->
                    let    arg_24 = BIF.erlang__list_to_binary__1 [arities_0]
                    in let
                      encodedarities_26 =
                        BIF.do_remote_fun_call "Aeser.Rlp" "erlps__encode__1"
                          [arg_24]
                    in let bin_el_27 = toErl 175
                    in let arg_31 = ErlangTuple [ErlangAtom "tuple", values_2]
                    in let bin_el_30 = erlps__serialize__1 [arg_31]
                    in
                      ErlangBinary
                        (BIN.concat
                           [BIN.fromInt bin_el_27 (toErl 8) 1 BIN.Big,
                            BIN.binPrefix encodedarities_26
                              (BIN.packedSize encodedarities_26) 8,
                            BIN.fromInt tag_1 (toErl 8) 1 BIN.Big,
                            BIN.binPrefix bin_el_30 (BIN.packedSize bin_el_30)
                              8])
                  _ -> EXC.if_clause unit
            _ -> EXC.if_clause unit
      _ -> EXC.badmatch matchExpr_13
erlps__serialize__1__p3 [(ErlangTuple [(ErlangAtom "typerep"),
                                       t_0])]
  =
  let arg_1 = erlps__serialize_type__1 [t_0]
  in BIF.erlang__iolist_to_binary__1 [arg_1]
erlps__serialize__1__p3 [arg_3] = EXC.function_clause unit
erlps__serialize__1__p3 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_type__1 :: ErlangFun
erlps__serialize_type__1 [(ErlangAtom "integer")] =
  let head_0 = toErl 7
  in ErlangCons head_0 ErlangEmptyList
erlps__serialize_type__1 [(ErlangAtom "boolean")] =
  let head_0 = toErl 23
  in ErlangCons head_0 ErlangEmptyList
erlps__serialize_type__1 [(ErlangAtom "any")] =
  let head_0 = toErl 247
  in ErlangCons head_0 ErlangEmptyList
erlps__serialize_type__1 [(ErlangTuple [(ErlangAtom "tvar"),
                                        n_0])]
  | ((weakLeq (toErl 0) n_0) && (weakLeq n_0 (toErl 255))) =
  let head_1 = toErl 231
  in ErlangCons head_1 (ErlangCons n_0 ErlangEmptyList)
erlps__serialize_type__1 [(ErlangTuple [(ErlangAtom "list"),
                                        t_0])]
  =
  let    head_1 = toErl 39
  in let tail_2 = erlps__serialize_type__1 [t_0]
  in ErlangCons head_1 tail_2
erlps__serialize_type__1 args =
  erlps__serialize_type__1__p1 args

erlps__serialize_type__1__p1 :: ErlangFun
erlps__serialize_type__1__p1 [(ErlangTuple [(ErlangAtom "tuple"),
                                            ts_0])]
  =
  let case_1 = BIF.erlang__length__1 [ts_0]
  in
    case case_1 of
      n_3 | weakLeq n_3 (toErl 255) ->
        let    head_4 = toErl 55
        in let
          tail_7 =
            flmap
              (\ lc_10 ->
                 let lcRet_11 = erlps__serialize_type__1 [lc_10]
                 in ErlangCons lcRet_11 ErlangEmptyList)
              ts_0
        in ErlangCons head_4 (ErlangCons n_3 tail_7)
      something_else -> EXC.case_clause something_else
erlps__serialize_type__1__p1 [(ErlangTuple [(ErlangAtom "bytes"),
                                            n_0])]
  | weakLeq (toErl 0) n_0 =
  let    head_1 = toErl 151
  in let arg_3 = erlps__serialize_integer__1 [n_0]
  in let tail_2 = BIF.erlang__binary_to_list__1 [arg_3]
  in ErlangCons head_1 tail_2
erlps__serialize_type__1__p1 [(ErlangAtom "address")] =
  let    head_0 = toErl 71
  in let head_2 = toErl 0
  in ErlangCons head_0 (ErlangCons head_2 ErlangEmptyList)
erlps__serialize_type__1__p1 [(ErlangAtom "contract")] =
  let    head_0 = toErl 71
  in let head_2 = toErl 2
  in ErlangCons head_0 (ErlangCons head_2 ErlangEmptyList)
erlps__serialize_type__1__p1 [(ErlangAtom "oracle")] =
  let    head_0 = toErl 71
  in let head_2 = toErl 3
  in ErlangCons head_0 (ErlangCons head_2 ErlangEmptyList)
erlps__serialize_type__1__p1 args =
  erlps__serialize_type__1__p2 args

erlps__serialize_type__1__p2 :: ErlangFun
erlps__serialize_type__1__p2 [(ErlangAtom "oracle_query")] =
  let    head_0 = toErl 71
  in let head_2 = toErl 4
  in ErlangCons head_0 (ErlangCons head_2 ErlangEmptyList)
erlps__serialize_type__1__p2 [(ErlangAtom "channel")] =
  let    head_0 = toErl 71
  in let head_2 = toErl 5
  in ErlangCons head_0 (ErlangCons head_2 ErlangEmptyList)
erlps__serialize_type__1__p2 [(ErlangAtom "bits")] =
  let head_0 = toErl 87
  in ErlangCons head_0 ErlangEmptyList
erlps__serialize_type__1__p2 [(ErlangTuple [(ErlangAtom "map"),
                                            k_0, v_1])]
  =
  let    head_2 = toErl 103
  in let lop_4 = erlps__serialize_type__1 [k_0]
  in let rop_6 = erlps__serialize_type__1 [v_1]
  in let tail_3 = BIF.erlang__op_append [lop_4, rop_6]
  in ErlangCons head_2 tail_3
erlps__serialize_type__1__p2 [(ErlangAtom "string")] =
  let head_0 = toErl 119
  in ErlangCons head_0 ErlangEmptyList
erlps__serialize_type__1__p2 args =
  erlps__serialize_type__1__p3 args

erlps__serialize_type__1__p3 :: ErlangFun
erlps__serialize_type__1__p3 [(ErlangTuple [(ErlangAtom "variant"),
                                            listofvariants_0])]
  =
  let size_2 = BIF.erlang__length__1 [listofvariants_0]
  in
    case ErlangAtom "true" of
      _ | weakLt size_2 (toErl 256) ->
        let    head_3 = toErl 135
        in let
          tail_6 =
            flmap
              (\ lc_9 ->
                 let lcRet_10 = erlps__serialize_type__1 [lc_9]
                 in ErlangCons lcRet_10 ErlangEmptyList)
              listofvariants_0
        in ErlangCons head_3 (ErlangCons size_2 tail_6)
      _ -> EXC.if_clause unit
erlps__serialize_type__1__p3 [arg_12] = EXC.function_clause unit
erlps__serialize_type__1__p3 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_type__1 :: ErlangFun
erlps__deserialize_type__1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 7))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  ErlangTuple [ErlangAtom "integer", rest_6]
erlps__deserialize_type__1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 23))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  ErlangTuple [ErlangAtom "boolean", rest_6]
erlps__deserialize_type__1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 247))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  ErlangTuple [ErlangAtom "any", rest_6]
erlps__deserialize_type__1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 231))
  , (ErlangInt size_4) <- (toErl 8)
  , (BIN.Ok id_6 bin_5) <-
      (BIN.chopInt bin_2 size_4 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_7) <- (BIN.size bin_5)
  , (BIN.Ok rest_9 bin_8) <- (BIN.chopBin bin_5 size_7 8)
  , BIN.empty bin_8 =
  let tup_el_10 = ErlangTuple [ErlangAtom "tvar", id_6]
  in ErlangTuple [tup_el_10, rest_9]
erlps__deserialize_type__1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 39))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__deserialize_type__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [t_8, rest2_9]) ->
        let tup_el_11 = ErlangTuple [ErlangAtom "list", t_8]
        in ErlangTuple [tup_el_11, rest2_9]
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize_type__1 args =
  erlps__deserialize_type__1__p1 args

erlps__deserialize_type__1__p1 :: ErlangFun
erlps__deserialize_type__1__p1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 55))
  , (ErlangInt size_4) <- (toErl 8)
  , (BIN.Ok n_6 bin_5) <-
      (BIN.chopInt bin_2 size_4 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_7) <- (BIN.size bin_5)
  , (BIN.Ok rest_9 bin_8) <- (BIN.chopBin bin_5 size_7 8)
  , BIN.empty bin_8 =
  let
    matchExpr_15 =
      erlps__deserialize_types__3 [n_6, rest_9, ErlangEmptyList]
  in
    case matchExpr_15 of
      (ErlangTuple [ts_13, rest2_14]) ->
        let tup_el_16 = ErlangTuple [ErlangAtom "tuple", ts_13]
        in ErlangTuple [tup_el_16, rest2_14]
      _ -> EXC.badmatch matchExpr_15
erlps__deserialize_type__1__p1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 151))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__deserialize_one__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [n_8, rest2_9]) ->
        let    lop_11 = BIF.erlang__is_integer__1 [n_8]
        in let
          matchExpr_15 =
            case lop_11 of
              (ErlangAtom "false") -> ErlangAtom "false"
              (ErlangAtom "true") ->
                let rop_14 = toErl 0
                in BIF.erlang__op_greaterEq [n_8, rop_14]
              _ -> EXC.badarg1 lop_11
        in
          case matchExpr_15 of
            (ErlangAtom "true") ->
              let tup_el_16 = ErlangTuple [ErlangAtom "bytes", n_8]
              in ErlangTuple [tup_el_16, rest2_9]
            _ -> EXC.badmatch matchExpr_15
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize_type__1__p1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 71))
  , (ErlangInt size_4) <- (toErl 8)
  , (BIN.Ok objecttype_6 bin_5) <-
      (BIN.chopInt bin_2 size_4 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_7) <- (BIN.size bin_5)
  , (BIN.Ok rest_9 bin_8) <- (BIN.chopBin bin_5 size_7 8)
  , BIN.empty bin_8 =
  case objecttype_6 of
    (ErlangInt num_11) | ((ErlangInt num_11) == (toErl 0)) ->
      ErlangTuple [ErlangAtom "address", rest_9]
    (ErlangInt num_14) | ((ErlangInt num_14) == (toErl 2)) ->
      ErlangTuple [ErlangAtom "contract", rest_9]
    (ErlangInt num_17) | ((ErlangInt num_17) == (toErl 3)) ->
      ErlangTuple [ErlangAtom "oracle", rest_9]
    (ErlangInt num_20) | ((ErlangInt num_20) == (toErl 4)) ->
      ErlangTuple [ErlangAtom "oracle_query", rest_9]
    (ErlangInt num_23) | ((ErlangInt num_23) == (toErl 5)) ->
      ErlangTuple [ErlangAtom "channel", rest_9]
    something_else -> EXC.case_clause something_else
erlps__deserialize_type__1__p1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 87))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  ErlangTuple [ErlangAtom "bits", rest_6]
erlps__deserialize_type__1__p1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 103))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__deserialize_type__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [k_8, rest2_9]) ->
        let matchExpr_14 = erlps__deserialize_type__1 [rest2_9]
        in
          case matchExpr_14 of
            (ErlangTuple [v_12, rest3_13]) ->
              let tup_el_15 = ErlangTuple [ErlangAtom "map", k_8, v_12]
              in ErlangTuple [tup_el_15, rest3_13]
            _ -> EXC.badmatch matchExpr_14
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize_type__1__p1 args =
  erlps__deserialize_type__1__p2 args

erlps__deserialize_type__1__p2 :: ErlangFun
erlps__deserialize_type__1__p2 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 119))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  ErlangTuple [ErlangAtom "string", rest_6]
erlps__deserialize_type__1__p2 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 135))
  , (ErlangInt size_4) <- (toErl 8)
  , (BIN.Ok size_6 bin_5) <-
      (BIN.chopInt bin_2 size_4 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_7) <- (BIN.size bin_5)
  , (BIN.Ok rest_9 bin_8) <- (BIN.chopBin bin_5 size_7 8)
  , BIN.empty bin_8 =
  let
    matchExpr_15 =
      erlps__deserialize_variants__3 [size_6, rest_9, ErlangEmptyList]
  in
    case matchExpr_15 of
      (ErlangTuple [variants_13, rest2_14]) ->
        let tup_el_16 = ErlangTuple [ErlangAtom "variant", variants_13]
        in ErlangTuple [tup_el_16, rest2_14]
      _ -> EXC.badmatch matchExpr_15
erlps__deserialize_type__1__p2 [arg_20] =
  EXC.function_clause unit
erlps__deserialize_type__1__p2 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_variants__3 :: ErlangFun
erlps__deserialize_variants__3 [(ErlangInt num_0), rest_1,
                                variants_2]
  | ((ErlangInt num_0) == (toErl 0)) =
  let
    tup_el_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [variants_2]
  in ErlangTuple [tup_el_3, rest_1]
erlps__deserialize_variants__3 [n_0, rest_1, variants_2] =
  let matchExpr_6 = erlps__deserialize_type__1 [rest_1]
  in
    case matchExpr_6 of
      (ErlangTuple [t_4, rest2_5]) ->
        let    rop_9 = toErl 1
        in let arg_7 = BIF.erlang__op_minus [n_0, rop_9]
        in
          erlps__deserialize_variants__3
            [arg_7, rest2_5, ErlangCons t_4 variants_2]
      _ -> EXC.badmatch matchExpr_6
erlps__deserialize_variants__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__deserialize_variants__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_types__3 :: ErlangFun
erlps__deserialize_types__3 [(ErlangInt num_0), binary_1, acc_2]
  | ((ErlangInt num_0) == (toErl 0)) =
  let
    tup_el_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_2]
  in ErlangTuple [tup_el_3, binary_1]
erlps__deserialize_types__3 [n_0, binary_1, acc_2] =
  let matchExpr_6 = erlps__deserialize_type__1 [binary_1]
  in
    case matchExpr_6 of
      (ErlangTuple [t_4, rest_5]) ->
        let    rop_9 = toErl 1
        in let arg_7 = BIF.erlang__op_minus [n_0, rop_9]
        in
          erlps__deserialize_types__3 [arg_7, rest_5, ErlangCons t_4 acc_2]
      _ -> EXC.badmatch matchExpr_6
erlps__deserialize_types__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__deserialize_types__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__rlp_encode_int__1 :: ErlangFun
erlps__rlp_encode_int__1 [s_0] | weakGeq s_0 (toErl 0) =
  let arg_1 = BIF.binary__encode_unsigned__1 [s_0]
  in BIF.do_remote_fun_call "Aeser.Rlp" "erlps__encode__1" [arg_1]
erlps__rlp_encode_int__1 [arg_3] = EXC.function_clause unit
erlps__rlp_encode_int__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__rlp_decode_int__1 :: ErlangFun
erlps__rlp_decode_int__1 [binary_0] =
  let
    matchExpr_4 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__decode_one__1"
        [binary_0]
  in
    case matchExpr_4 of
      (ErlangTuple [bin1_2, rest_3]) ->
        let    int_6 = BIF.binary__decode_unsigned__1 [bin1_2]
        in let reencode_8 = erlps__rlp_encode_int__1 [int_6]
        in let
          lop_10 =
            ErlangBinary
              (BIN.concat
                 [BIN.binPrefix reencode_8 (BIN.packedSize reencode_8) 8,
                  BIN.binPrefix rest_3 (BIN.packedSize rest_3) 8])
        in let case_9 = BIF.erlang__op_eq [lop_10, binary_0]
        in
          case case_9 of
            (ErlangAtom "true") -> ErlangTuple [int_6, rest_3]
            (ErlangAtom "false") ->
              let
                arg_16 =
                  ErlangTuple
                    [ErlangAtom "none_unique_encoding", bin1_2, reencode_8]
              in BIF.erlang__error__1 [arg_16]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_4
erlps__rlp_decode_int__1 [arg_20] = EXC.function_clause unit
erlps__rlp_decode_int__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_integer__1 :: ErlangFun
erlps__serialize_integer__1 [i_0] | isEInt i_0 =
  let    abs_3 = BIF.erlang__abs__1 [i_0]
  in let rop_6 = toErl 0
  in let case_4 = BIF.erlang__op_lesser [i_0, rop_6]
  in let
    sign_7 =
      case case_4 of
        (ErlangAtom "true") -> toErl 1
        (ErlangAtom "false") -> toErl 0
        something_else -> EXC.case_clause something_else
  in
    case ErlangAtom "true" of
      _ | weakLt abs_3 (toErl 64) ->
        let    rop_12 = toErl 7
        in let lop_10 = BIF.erlang__bsl__2 [sign_7, rop_12]
        in let rop_13 = toErl 128
        in let lop_9 = BIF.erlang__band__2 [lop_10, rop_13]
        in let rop_17 = toErl 1
        in let lop_15 = BIF.erlang__bsl__2 [abs_3, rop_17]
        in let rop_18 = toErl 126
        in let rop_14 = BIF.erlang__band__2 [lop_15, rop_18]
        in let lop_8 = BIF.erlang__bor__2 [lop_9, rop_14]
        in let lop_20 = toErl 0
        in let rop_21 = toErl 1
        in let rop_19 = BIF.erlang__band__2 [lop_20, rop_21]
        in let bin_22 = BIF.erlang__bor__2 [lop_8, rop_19]
        in ErlangBinary (BIN.fromInt bin_22 (toErl 8) 1 BIN.Big)
      _ | (==) sign_7 (toErl 1) ->
        let    bin_el_24 = toErl 239
        in let rop_28 = toErl 64
        in let arg_26 = BIF.erlang__op_minus [abs_3, rop_28]
        in let bin_el_25 = erlps__rlp_encode_int__1 [arg_26]
        in
          ErlangBinary
            (BIN.concat
               [BIN.fromInt bin_el_24 (toErl 8) 1 BIN.Big,
                BIN.binPrefix bin_el_25 (BIN.packedSize bin_el_25) 8])
      _ | (==) sign_7 (toErl 0) ->
        let    bin_el_29 = toErl 111
        in let rop_33 = toErl 64
        in let arg_31 = BIF.erlang__op_minus [abs_3, rop_33]
        in let bin_el_30 = erlps__rlp_encode_int__1 [arg_31]
        in
          ErlangBinary
            (BIN.concat
               [BIN.fromInt bin_el_29 (toErl 8) 1 BIN.Big,
                BIN.binPrefix bin_el_30 (BIN.packedSize bin_el_30) 8])
      _ -> EXC.if_clause unit
erlps__serialize_integer__1 [arg_34] = EXC.function_clause unit
erlps__serialize_integer__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__serialize_bits__1 :: ErlangFun
erlps__serialize_bits__1 [b_0] | isEInt b_0 =
  let abs_2 = BIF.erlang__abs__1 [b_0]
  in
    case ErlangAtom "true" of
      _ | weakLt b_0 (toErl 0) ->
        let    bin_el_3 = toErl 207
        in let bin_el_4 = erlps__rlp_encode_int__1 [abs_2]
        in
          ErlangBinary
            (BIN.concat
               [BIN.fromInt bin_el_3 (toErl 8) 1 BIN.Big,
                BIN.binPrefix bin_el_4 (BIN.packedSize bin_el_4) 8])
      _ | weakGeq b_0 (toErl 0) ->
        let    bin_el_6 = toErl 79
        in let bin_el_7 = erlps__rlp_encode_int__1 [abs_2]
        in
          ErlangBinary
            (BIN.concat
               [BIN.fromInt bin_el_6 (toErl 8) 1 BIN.Big,
                BIN.binPrefix bin_el_7 (BIN.packedSize bin_el_7) 8])
      _ -> EXC.if_clause unit
erlps__serialize_bits__1 [arg_9] = EXC.function_clause unit
erlps__serialize_bits__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize__1 :: ErlangFun
erlps__deserialize__1 [b_0] =
  let matchExpr_4 = erlps__deserialize2__1 [b_0]
  in
    case matchExpr_4 of
      (ErlangTuple [t_2, (ErlangBinary binEnd_3)]) | BIN.empty
                                                       binEnd_3 ->
        t_2
      _ -> EXC.badmatch matchExpr_4
erlps__deserialize__1 [arg_5] = EXC.function_clause unit
erlps__deserialize__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_one__1 :: ErlangFun
erlps__deserialize_one__1 [b_0] = erlps__deserialize2__1 [b_0]
erlps__deserialize_one__1 [arg_2] = EXC.function_clause unit
erlps__deserialize_one__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize2__1 :: ErlangFun
erlps__deserialize2__1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok bin_3 bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5
  , ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_18 = toErl 128
             in let lop_16 = BIF.erlang__band__2 [bin_3, rop_18]
             in let rop_19 = toErl 7
             in let lop_15 = BIF.erlang__bsr__2 [lop_16, rop_19]
             in let rop_20 = toErl 0
             in let lop_14 = BIF.erlang__op_exactEq [lop_15, rop_20]
             in
               case lop_14 of
                 (ErlangAtom "false") -> ErlangAtom "false"
                 (ErlangAtom "true") ->
                   let    rop_23 = toErl 1
                   in let lop_21 = BIF.erlang__band__2 [bin_3, rop_23]
                   in let rop_24 = toErl 0
                   in BIF.erlang__op_exactEq [lop_21, rop_24]
                 _ -> EXC.badarg1 lop_14))) =
  let    rop_9 = toErl 126
  in let lop_7 = BIF.erlang__band__2 [bin_3, rop_9]
  in let rop_10 = toErl 1
  in let i_11 = BIF.erlang__bsr__2 [lop_7, rop_10]
  in ErlangTuple [i_11, rest_6]
erlps__deserialize2__1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok bin_3 bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5
  , ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_22 = toErl 128
             in let lop_20 = BIF.erlang__band__2 [bin_3, rop_22]
             in let rop_23 = toErl 7
             in let lop_19 = BIF.erlang__bsr__2 [lop_20, rop_23]
             in let rop_24 = toErl 1
             in let lop_18 = BIF.erlang__op_exactEq [lop_19, rop_24]
             in
               case lop_18 of
                 (ErlangAtom "false") -> ErlangAtom "false"
                 (ErlangAtom "true") ->
                   let    rop_27 = toErl 1
                   in let lop_25 = BIF.erlang__band__2 [bin_3, rop_27]
                   in let rop_28 = toErl 0
                   in BIF.erlang__op_exactEq [lop_25, rop_28]
                 _ -> EXC.badarg1 lop_18))) =
  let    rop_9 = toErl 126
  in let lop_7 = BIF.erlang__band__2 [bin_3, rop_9]
  in let rop_10 = toErl 1
  in let i_11 = BIF.erlang__bsr__2 [lop_7, rop_10]
  in
    case ErlangAtom "true" of
      _ | (/=) i_11 (toErl 0) ->
        let tup_el_12 = BIF.erlang__op_neg [i_11]
        in ErlangTuple [tup_el_12, rest_6]
      _ | weakEq i_11 (toErl 0) ->
        let arg_15 = ErlangTuple [ErlangAtom "illegal_sign", i_11]
        in BIF.erlang__error__1 [arg_15]
      _ -> EXC.if_clause unit
erlps__deserialize2__1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 239))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__rlp_decode_int__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [bint_8, rest2_9]) ->
        let    lop_12 = BIF.erlang__op_neg [bint_8]
        in let rop_14 = toErl 64
        in let tup_el_11 = BIF.erlang__op_minus [lop_12, rop_14]
        in ErlangTuple [tup_el_11, rest2_9]
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize2__1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 111))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__rlp_decode_int__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [bint_8, rest2_9]) ->
        let    rop_13 = toErl 64
        in let tup_el_11 = BIF.erlang__op_plus [bint_8, rop_13]
        in ErlangTuple [tup_el_11, rest2_9]
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize2__1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 207))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let case_7 = erlps__rlp_decode_int__1 [rest_6]
  in
    case case_7 of
      (ErlangTuple [pos_9, rest2_10]) | weakGt pos_9 (toErl 0) ->
        let    tup_el_13 = BIF.erlang__op_neg [pos_9]
        in let tup_el_11 = ErlangTuple [ErlangAtom "bits", tup_el_13]
        in ErlangTuple [tup_el_11, rest2_10]
      (ErlangTuple [n_16, _]) ->
        let
          arg_17 =
            ErlangTuple
              [ErlangAtom "illegal_parameter", ErlangAtom "neg_bits", n_16]
        in BIF.erlang__error__1 [arg_17]
      something_else -> EXC.case_clause something_else
erlps__deserialize2__1 args = erlps__deserialize2__1__p1 args

erlps__deserialize2__1__p1 :: ErlangFun
erlps__deserialize2__1__p1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 79))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__rlp_decode_int__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [bint_8, rest2_9]) ->
        let tup_el_11 = ErlangTuple [ErlangAtom "bits", bint_8]
        in ErlangTuple [tup_el_11, rest2_9]
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize2__1__p1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 1))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__deserialize_one__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [s_8, rest2_9]) ->
        let    lop_11 = BIF.erlang__is_integer__1 [s_8]
        in let
          matchExpr_15 =
            case lop_11 of
              (ErlangAtom "false") -> ErlangAtom "false"
              (ErlangAtom "true") ->
                let rop_14 = toErl 0
                in BIF.erlang__op_greaterEq [s_8, rop_14]
              _ -> EXC.badarg1 lop_11
        in
          case matchExpr_15 of
            (ErlangAtom "true") ->
              let    rop_17 = toErl 64
              in let size_18 = BIF.erlang__op_plus [s_8, rop_17]
              in let arg_20 = toErl 0
              in let string_22 = BIF.binary__part__3 [rest2_9, arg_20, size_18]
              in let arg_24 = BIF.erlang__byte_size__1 [rest2_9]
              in let lop_28 = BIF.erlang__byte_size__1 [rest2_9]
              in let op_arg_27 = BIF.erlang__op_minus [lop_28, size_18]
              in let arg_26 = BIF.erlang__op_neg [op_arg_27]
              in let rest3_31 = BIF.binary__part__3 [rest2_9, arg_24, arg_26]
              in ErlangTuple [string_22, rest3_31]
            _ -> EXC.badmatch matchExpr_15
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize2__1__p1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok bin_3 bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5
  , ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_29 = toErl 3
             in let lop_27 = BIF.erlang__band__2 [bin_3, rop_29]
             in let rop_30 = toErl 1
             in BIF.erlang__op_exactEq [lop_27, rop_30]))) =
  let    rop_9 = toErl 252
  in let lop_7 = BIF.erlang__band__2 [bin_3, rop_9]
  in let rop_10 = toErl 2
  in let s_11 = BIF.erlang__bsr__2 [lop_7, rop_10]
  in let arg_13 = toErl 0
  in let string_15 = BIF.binary__part__3 [rest_6, arg_13, s_11]
  in let arg_17 = BIF.erlang__byte_size__1 [rest_6]
  in let lop_21 = BIF.erlang__byte_size__1 [rest_6]
  in let op_arg_20 = BIF.erlang__op_minus [lop_21, s_11]
  in let arg_19 = BIF.erlang__op_neg [op_arg_20]
  in let rest2_24 = BIF.binary__part__3 [rest_6, arg_17, arg_19]
  in ErlangTuple [string_15, rest2_24]
erlps__deserialize2__1__p1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 159))
  , (ErlangInt size_4) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_6) bin_5) <-
      (BIN.chopInt bin_2 size_4 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_6) == (toErl 1))
  , (ErlangInt size_7) <- (BIN.size bin_5)
  , (BIN.Ok rest_9 bin_8) <- (BIN.chopBin bin_5 size_7 8)
  , BIN.empty bin_8 =
  let matchExpr_13 = erlps__deserialize_one__1 [rest_9]
  in
    case matchExpr_13 of
      (ErlangTuple [string_11, rest2_12]) ->
        let matchExpr_15 = BIF.erlang__is_binary__1 [string_11]
        in
          case matchExpr_15 of
            (ErlangAtom "true") ->
              let tup_el_16 = ErlangTuple [ErlangAtom "bytes", string_11]
              in ErlangTuple [tup_el_16, rest2_12]
            _ -> EXC.badmatch matchExpr_15
      _ -> EXC.badmatch matchExpr_13
erlps__deserialize2__1__p1 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 159))
  , (ErlangInt size_4) <- (toErl 8)
  , (BIN.Ok objecttype_6 bin_5) <-
      (BIN.chopInt bin_2 size_4 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_7) <- (BIN.size bin_5)
  , (BIN.Ok rest_9 bin_8) <- (BIN.chopBin bin_5 size_7 8)
  , BIN.empty bin_8 =
  let
    matchExpr_13 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__decode_one__1"
        [rest_9]
  in
    case matchExpr_13 of
      (ErlangTuple [a_11, rest2_12]) ->
        let
          val_30 =
            case objecttype_6 of
              (ErlangInt num_15) | ((ErlangInt num_15) == (toErl 0)) ->
                ErlangTuple [ErlangAtom "address", a_11]
              (ErlangInt num_18) | ((ErlangInt num_18) == (toErl 2)) ->
                ErlangTuple [ErlangAtom "contract", a_11]
              (ErlangInt num_21) | ((ErlangInt num_21) == (toErl 3)) ->
                ErlangTuple [ErlangAtom "oracle", a_11]
              (ErlangInt num_24) | ((ErlangInt num_24) == (toErl 4)) ->
                ErlangTuple [ErlangAtom "oracle_query", a_11]
              (ErlangInt num_27) | ((ErlangInt num_27) == (toErl 5)) ->
                ErlangTuple [ErlangAtom "channel", a_11]
              something_else -> EXC.case_clause something_else
        in ErlangTuple [val_30, rest2_12]
      _ -> EXC.badmatch matchExpr_13
erlps__deserialize2__1__p1 args =
  erlps__deserialize2__1__p2 args

erlps__deserialize2__1__p2 :: ErlangFun
erlps__deserialize2__1__p2 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 255))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  ErlangTuple [ErlangAtom "true", rest_6]
erlps__deserialize2__1__p2 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 127))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  ErlangTuple [ErlangAtom "false", rest_6]
erlps__deserialize2__1__p2 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 63))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let    tup_el_9 = ErlangTuple []
  in let tup_el_7 = ErlangTuple [ErlangAtom "tuple", tup_el_9]
  in ErlangTuple [tup_el_7, rest_6]
erlps__deserialize2__1__p2 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 95))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let tup_el_7 = ErlangBinary (BIN.concat [])
  in ErlangTuple [tup_el_7, rest_6]
erlps__deserialize2__1__p2 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 11))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__rlp_decode_int__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [size_8, rest1_9]) ->
        let    rop_12 = toErl 16
        in let n_13 = BIF.erlang__op_plus [size_8, rop_12]
        in let
          matchExpr_18 = erlps__deserialize_elements__2 [n_13, rest1_9]
        in
          case matchExpr_18 of
            (ErlangTuple [list_16, rest2_17]) ->
              let    tup_el_21 = BIF.erlang__list_to_tuple__1 [list_16]
              in let tup_el_19 = ErlangTuple [ErlangAtom "tuple", tup_el_21]
              in ErlangTuple [tup_el_19, rest2_17]
            _ -> EXC.badmatch matchExpr_18
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize2__1__p2 args =
  erlps__deserialize2__1__p3 args

erlps__deserialize2__1__p3 :: ErlangFun
erlps__deserialize2__1__p3 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok bin_3 bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5
  , ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_24 = toErl 15
             in let lop_22 = BIF.erlang__band__2 [bin_3, rop_24]
             in let rop_25 = toErl 11
             in BIF.erlang__op_exactEq [lop_22, rop_25]))) =
  let    rop_9 = toErl 240
  in let lop_7 = BIF.erlang__band__2 [bin_3, rop_9]
  in let rop_10 = toErl 4
  in let s_11 = BIF.erlang__bsr__2 [lop_7, rop_10]
  in let
    matchExpr_16 = erlps__deserialize_elements__2 [s_11, rest_6]
  in
    case matchExpr_16 of
      (ErlangTuple [list_14, rest1_15]) ->
        let    tup_el_19 = BIF.erlang__list_to_tuple__1 [list_14]
        in let tup_el_17 = ErlangTuple [ErlangAtom "tuple", tup_el_19]
        in ErlangTuple [tup_el_17, rest1_15]
      _ -> EXC.badmatch matchExpr_16
erlps__deserialize2__1__p3 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 31))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__rlp_decode_int__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [size_8, rest1_9]) ->
        let    rop_12 = toErl 16
        in let length_13 = BIF.erlang__op_plus [size_8, rop_12]
        in let
          matchExpr_18 =
            erlps__deserialize_elements__2 [length_13, rest1_9]
        in
          case matchExpr_18 of
            (ErlangTuple [list_16, rest2_17]) ->
              ErlangTuple [list_16, rest2_17]
            _ -> EXC.badmatch matchExpr_18
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize2__1__p3 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok bin_3 bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5
  , ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_21 = toErl 15
             in let lop_19 = BIF.erlang__band__2 [bin_3, rop_21]
             in let rop_22 = toErl 3
             in BIF.erlang__op_exactEq [lop_19, rop_22]))) =
  let    rop_9 = toErl 240
  in let lop_7 = BIF.erlang__band__2 [bin_3, rop_9]
  in let rop_10 = toErl 4
  in let s_11 = BIF.erlang__bsr__2 [lop_7, rop_10]
  in let
    matchExpr_16 = erlps__deserialize_elements__2 [s_11, rest_6]
  in
    case matchExpr_16 of
      (ErlangTuple [list_14, rest1_15]) ->
        ErlangTuple [list_14, rest1_15]
      _ -> EXC.badmatch matchExpr_16
erlps__deserialize2__1__p3 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 47))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__rlp_decode_int__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [size_8, rest1_9]) ->
        let    lop_12 = toErl 2
        in let arg_11 = BIF.erlang__op_mult [lop_12, size_8]
        in let
          matchExpr_17 = erlps__deserialize_elements__2 [arg_11, rest1_9]
        in
          case matchExpr_17 of
            (ErlangTuple [list_15, rest2_16]) ->
              let    kvlist_19 = erlps__insert_kv__1 [list_15]
              in let lop_21 = erlps__sort_and_check__1 [kvlist_19]
              in let case_20 = BIF.erlang__op_eq [lop_21, kvlist_19]
              in
                case case_20 of
                  (ErlangAtom "true") ->
                    let map_25 = BIF.maps__from_list__1 [kvlist_19]
                    in ErlangTuple [map_25, rest2_16]
                  (ErlangAtom "false") ->
                    let
                      arg_28 =
                        ErlangTuple
                          [ErlangAtom "unknown_map_serialization_format",
                           kvlist_19]
                    in BIF.erlang__error__1 [arg_28]
                  something_else -> EXC.case_clause something_else
            _ -> EXC.badmatch matchExpr_17
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize2__1__p3 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 191))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let matchExpr_10 = erlps__rlp_decode_int__1 [rest_6]
  in
    case matchExpr_10 of
      (ErlangTuple [id_8, rest1_9]) ->
        let    tup_el_13 = ErlangMap Map.empty
        in let
          tup_el_11 = ErlangTuple [ErlangAtom "store_map", tup_el_13, id_8]
        in ErlangTuple [tup_el_11, rest1_9]
      _ -> EXC.badmatch matchExpr_10
erlps__deserialize2__1__p3 args =
  erlps__deserialize2__1__p4 args

erlps__deserialize2__1__p4 :: ErlangFun
erlps__deserialize2__1__p4 [(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 175))
  , (ErlangInt size_4) <- (BIN.size bin_2)
  , (BIN.Ok rest_6 bin_5) <- (BIN.chopBin bin_2 size_4 8)
  , BIN.empty bin_5 =
  let
    matchExpr_16 =
      BIF.do_remote_fun_call "Aeser.Rlp" "erlps__decode_one__1"
        [rest_6]
  in
    case matchExpr_16 of
      (ErlangTuple [aritiesbin_8,
                    (ErlangBinary binSeg_9)]) | (ErlangInt size_10) <- (toErl 8)
                                              , (BIN.Ok tag_12 bin_11) <-
                                                  (BIN.chopInt binSeg_9 size_10
                                                     1 BIN.Big BIN.Unsigned)
                                              , (ErlangInt size_13) <-
                                                  (BIN.size bin_11)
                                              , (BIN.Ok rest2_15 bin_14) <-
                                                  (BIN.chopBin bin_11 size_13 8)
                                              , BIN.empty bin_14 ->
        let    arities_18 = BIF.erlang__binary_to_list__1 [aritiesbin_8]
        in let size_20 = BIF.erlang__length__1 [arities_18]
        in
          case ErlangAtom "true" of
            _ | weakGt tag_12 size_20 ->
              let
                arg_21 =
                  ErlangTuple
                    [ErlangAtom "too_large_tag_in_variant", tag_12, size_20]
              in BIF.erlang__exit__1 [arg_21]
            _ ->
              let matchExpr_28 = erlps__deserialize2__1 [rest2_15]
              in
                case matchExpr_28 of
                  (ErlangTuple [(ErlangTuple [(ErlangAtom "tuple"), t_26]),
                                rest3_27]) ->
                    let    rop_31 = toErl 1
                    in let arg_29 = BIF.erlang__op_plus [tag_12, rop_31]
                    in let
                      arity_33 =
                        BIF.do_remote_fun_call "Lists" "erlps__nth__2"
                          [arg_29, arities_18]
                    in let numelements_35 = BIF.erlang__size__1 [t_26]
                    in
                      case ErlangAtom "true" of
                        _ | (/=) numelements_35 arity_33 ->
                          let
                            arg_36 =
                              ErlangTuple
                                [ErlangAtom
                                   "tag_does_not_match_type_in_variant",
                                 tag_12, arity_33]
                          in BIF.erlang__exit__1 [arg_36]
                        _ ->
                          let
                            tup_el_40 =
                              ErlangTuple
                                [ErlangAtom "variant", arities_18, tag_12, t_26]
                          in ErlangTuple [tup_el_40, rest3_27]
                  _ -> EXC.badmatch matchExpr_28
      _ -> EXC.badmatch matchExpr_16
erlps__deserialize2__1__p4 [bin_4@(ErlangBinary binSeg_0)]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok typetag_3 bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    rop_15 = toErl 7
             in let lop_13 = BIF.erlang__op_exactEq [typetag_3, rop_15]
             in
               case lop_13 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   let    rop_18 = toErl 23
                   in let lop_16 = BIF.erlang__op_exactEq [typetag_3, rop_18]
                   in
                     case lop_16 of
                       (ErlangAtom "true") -> ErlangAtom "true"
                       (ErlangAtom "false") ->
                         let    rop_21 = toErl 247
                         in let
                           lop_19 = BIF.erlang__op_exactEq [typetag_3, rop_21]
                         in
                           case lop_19 of
                             (ErlangAtom "true") -> ErlangAtom "true"
                             (ErlangAtom "false") ->
                               let    rop_24 = toErl 231
                               in let
                                 lop_22 =
                                   BIF.erlang__op_exactEq [typetag_3, rop_24]
                               in
                                 case lop_22 of
                                   (ErlangAtom "true") -> ErlangAtom "true"
                                   (ErlangAtom "false") ->
                                     let    rop_27 = toErl 39
                                     in let
                                       lop_25 =
                                         BIF.erlang__op_exactEq
                                           [typetag_3, rop_27]
                                     in
                                       case lop_25 of
                                         (ErlangAtom "true") ->
                                           ErlangAtom "true"
                                         (ErlangAtom "false") ->
                                           let    rop_30 = toErl 55
                                           in let
                                             lop_28 =
                                               BIF.erlang__op_exactEq
                                                 [typetag_3, rop_30]
                                           in
                                             case lop_28 of
                                               (ErlangAtom "true") ->
                                                 ErlangAtom "true"
                                               (ErlangAtom "false") ->
                                                 let    rop_33 = toErl 71
                                                 in let
                                                   lop_31 =
                                                     BIF.erlang__op_exactEq
                                                       [typetag_3, rop_33]
                                                 in
                                                   case lop_31 of
                                                     (ErlangAtom "true") ->
                                                       ErlangAtom "true"
                                                     (ErlangAtom "false") ->
                                                       let    rop_36 = toErl 87
                                                       in let
                                                         lop_34 =
                                                           BIF.erlang__op_exactEq
                                                             [typetag_3, rop_36]
                                                       in
                                                         case lop_34 of
                                                           (ErlangAtom "true") ->
                                                             ErlangAtom "true"
                                                           (ErlangAtom "false") ->
                                                             let   
                                                               rop_39 =
                                                                 toErl 151
                                                             in let
                                                               lop_37 =
                                                                 BIF.erlang__op_exactEq
                                                                   [typetag_3,
                                                                    rop_39]
                                                             in
                                                               case lop_37 of
                                                                 (ErlangAtom "true") ->
                                                                   ErlangAtom
                                                                     "true"
                                                                 (ErlangAtom "false") ->
                                                                   let   
                                                                     rop_42 =
                                                                       toErl 103
                                                                   in let
                                                                     lop_40 =
                                                                       BIF.erlang__op_exactEq
                                                                         [typetag_3,
                                                                          rop_42]
                                                                   in
                                                                     case lop_40 of
                                                                       (ErlangAtom "true") ->
                                                                         ErlangAtom
                                                                           "true"
                                                                       (ErlangAtom "false") ->
                                                                         let   
                                                                           rop_45 =
                                                                             toErl
                                                                               119
                                                                         in let
                                                                           lop_43 =
                                                                             BIF.erlang__op_exactEq
                                                                               [typetag_3,
                                                                                rop_45]
                                                                         in
                                                                           case lop_43 of
                                                                             (ErlangAtom "true") ->
                                                                               ErlangAtom
                                                                                 "true"
                                                                             (ErlangAtom "false") ->
                                                                               let
                                                                                 rop_47 =
                                                                                   toErl
                                                                                     135
                                                                               in
                                                                                 BIF.erlang__op_exactEq
                                                                                   [typetag_3,
                                                                                    rop_47]
                                                                             _ ->
                                                                               EXC.badarg1
                                                                                 lop_43
                                                                       _ ->
                                                                         EXC.badarg1
                                                                           lop_40
                                                                 _ ->
                                                                   EXC.badarg1
                                                                     lop_37
                                                           _ ->
                                                             EXC.badarg1 lop_34
                                                     _ -> EXC.badarg1 lop_31
                                               _ -> EXC.badarg1 lop_28
                                         _ -> EXC.badarg1 lop_25
                                   _ -> EXC.badarg1 lop_22
                             _ -> EXC.badarg1 lop_19
                       _ -> EXC.badarg1 lop_16
                 _ -> EXC.badarg1 lop_13))) =
  let matchExpr_8 = erlps__deserialize_type__1 [bin_4]
  in
    case matchExpr_8 of
      (ErlangTuple [type_6, rest_7]) ->
        let tup_el_9 = ErlangTuple [ErlangAtom "typerep", type_6]
        in ErlangTuple [tup_el_9, rest_7]
      _ -> EXC.badmatch matchExpr_8
erlps__deserialize2__1__p4 [arg_48] = EXC.function_clause unit
erlps__deserialize2__1__p4 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__insert_kv__1 :: ErlangFun
erlps__insert_kv__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__insert_kv__1 [(ErlangCons k_0 (ErlangCons v_1 r_2))] =
  let    head_3 = ErlangTuple [k_0, v_1]
  in let tail_6 = erlps__insert_kv__1 [r_2]
  in ErlangCons head_3 tail_6
erlps__insert_kv__1 [arg_8] = EXC.function_clause unit
erlps__insert_kv__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__deserialize_elements__2 :: ErlangFun
erlps__deserialize_elements__2 [(ErlangInt num_0), rest_1]
  | ((ErlangInt num_0) == (toErl 0)) =
  ErlangTuple [ErlangEmptyList, rest_1]
erlps__deserialize_elements__2 [n_0, es_1] =
  let matchExpr_5 = erlps__deserialize2__1 [es_1]
  in
    case matchExpr_5 of
      (ErlangTuple [e_3, rest_4]) ->
        let    rop_8 = toErl 1
        in let arg_6 = BIF.erlang__op_minus [n_0, rop_8]
        in let
          matchExpr_12 = erlps__deserialize_elements__2 [arg_6, rest_4]
        in
          case matchExpr_12 of
            (ErlangTuple [tail_10, rest2_11]) ->
              ErlangTuple [ErlangCons e_3 tail_10, rest2_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_5
erlps__deserialize_elements__2 [arg_17, arg_18] =
  EXC.function_clause unit
erlps__deserialize_elements__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__sort_and_check__1 :: ErlangFun
erlps__sort_and_check__1 [list_0] =
  let   
    arg_1 =
      ErlangFun 2
        (let
           lambda_2 [(ErlangTuple [k_5, v_6]), acc_7] =
             let    lop_9 = erlps__valid_key_type__1 [k_5]
             in let
               case_8 =
                 case lop_9 of
                   (ErlangAtom "false") -> ErlangAtom "false"
                   (ErlangAtom "true") ->
                     let    arg_13 = toErl 1
                     in let
                       op_arg_11 = BIF.lists__keymember__3 [k_5, arg_13, acc_7]
                     in BIF.erlang__not__1 [op_arg_11]
                   _ -> EXC.badarg1 lop_9
             in
               case case_8 of
                 (ErlangAtom "true") ->
                   let head_15 = ErlangTuple [k_5, v_6]
                   in ErlangCons head_15 acc_7
                 (ErlangAtom "false") -> acc_7
                 something_else -> EXC.case_clause something_else
           lambda_2 [arg_3, arg_4] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 2 lambda_2) args
         in lambda_2)
  in let
    uniqkeylist_21 =
      BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
        [arg_1, ErlangEmptyList, list_0]
  in erlps__sort__1 [uniqkeylist_21]
erlps__sort_and_check__1 [arg_23] = EXC.function_clause unit
erlps__sort_and_check__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__sort__1 :: ErlangFun
erlps__sort__1 [kvlist_0] =
  let
    sortfun_8 =
      ErlangFun 2
        (let
           lambda_1 [(ErlangTuple [k1_4, _]), (ErlangTuple [k2_5, _])] =
             BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__elt__2"
               [k1_4, k2_5]
           lambda_1 [arg_2, arg_3] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 2 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Lists" "erlps__sort__2"
      [sortfun_8, kvlist_0]
erlps__sort__1 [arg_11] = EXC.function_clause unit
erlps__sort__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__valid_key_type__1 :: ErlangFun
erlps__valid_key_type__1 [k_0] | isEMap k_0 =
  let arg_1 = ErlangTuple [ErlangAtom "map_as_key_in_map", k_0]
  in BIF.erlang__error__1 [arg_1]
erlps__valid_key_type__1 [k_0@(ErlangTuple [(ErlangAtom "store_map"),
                                            _, _])]
  =
  let arg_1 = ErlangTuple [ErlangAtom "map_as_key_in_map", k_0]
  in BIF.erlang__error__1 [arg_1]
erlps__valid_key_type__1 [k_0] | isEList k_0 =
  let
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [e_4] = erlps__valid_key_type__1 [e_4]
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in BIF.do_remote_fun_call "Lists" "erlps__all__2" [arg_1, k_0]
erlps__valid_key_type__1 [k_0] | isETuple k_0 =
  let   
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [e_4] = erlps__valid_key_type__1 [e_4]
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let arg_6 = BIF.erlang__tuple_to_list__1 [k_0]
  in BIF.do_remote_fun_call "Lists" "erlps__all__2" [arg_1, arg_6]
erlps__valid_key_type__1 [_k_0] = ErlangAtom "true"
erlps__valid_key_type__1 [arg_1] = EXC.function_clause unit
erlps__valid_key_type__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args