module Aeb.Fate.Maps(erlps__allocate_store_maps__2,
                     erlps__has_store_maps__1, erlps__unfold_store_maps__2,
                     erlps__refcount__1, erlps__refcount_zero__0,
                     erlps__refcount_diff__2, erlps__refcount_union__1,
                     erlps__refcount_union__2, erlps__no_used_ids__0) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__allocate_store_maps__2 :: ErlangFun
erlps__allocate_store_maps__2 [used_0, vals_1] =
  let    arg_4 = ErlangMap Map.empty
  in let
    matchExpr_8 =
      erlps__allocate_store_maps_l__3 [used_0, vals_1, arg_4]
  in
    case matchExpr_8 of
      (ErlangTuple [_used_5, vals1_6, maps_7]) ->
        ErlangTuple [vals1_6, maps_7]
      _ -> EXC.badmatch matchExpr_8
erlps__allocate_store_maps__2 [arg_11, arg_12] =
  EXC.function_clause unit
erlps__allocate_store_maps__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__allocate_store_maps__3 :: ErlangFun
erlps__allocate_store_maps__3 [used_0,
                               val_1@(ErlangAtom "__DELETED__"), maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3 [used_0, val_1@(ErlangAtom "true"),
                               maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3 [used_0,
                               val_1@(ErlangAtom "false"), maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3 [used_0,
                               val_1@(ErlangTuple [(ErlangAtom "tuple"),
                                                   (ErlangTuple [])]),
                               maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3 [used_0,
                               val_1@(ErlangTuple [(ErlangAtom "bits"), _]),
                               maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3 [used_0,
                               val_1@(ErlangTuple [(ErlangAtom "bytes"), _]),
                               maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3 args =
  erlps__allocate_store_maps__3__p1 args

erlps__allocate_store_maps__3__p1 :: ErlangFun
erlps__allocate_store_maps__3__p1 [used_0,
                                   val_1@(ErlangTuple [(ErlangAtom "address"),
                                                       _]),
                                   maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3__p1 [used_0,
                                   val_1@(ErlangTuple [(ErlangAtom "contract"),
                                                       _]),
                                   maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3__p1 [used_0,
                                   val_1@(ErlangTuple [(ErlangAtom "oracle"),
                                                       _]),
                                   maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3__p1 [used_0,
                                   val_1@(ErlangTuple [(ErlangAtom "oracle_query"),
                                                       _]),
                                   maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3__p1 [used_0,
                                   val_1@(ErlangTuple [(ErlangAtom "channel"),
                                                       _]),
                                   maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3__p1 [used_0,
                                   val_1@(ErlangTuple [(ErlangAtom "typerep"),
                                                       _]),
                                   maps_2]
  =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3__p1 args =
  erlps__allocate_store_maps__3__p2 args

erlps__allocate_store_maps__3__p2 :: ErlangFun
erlps__allocate_store_maps__3__p2 [used_0, val_1, maps_2]
  | isEInt val_1 =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3__p2 [used_0, val_1, maps_2]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [val_1]))) =
  ErlangTuple [used_0, val_1, maps_2]
erlps__allocate_store_maps__3__p2 [used_0,
                                   (ErlangTuple [(ErlangAtom "tuple"), val_1]),
                                   maps_2]
  =
  let    arg_4 = BIF.erlang__tuple_to_list__1 [val_1]
  in let
    matchExpr_10 =
      erlps__allocate_store_maps_l__3 [used_0, arg_4, maps_2]
  in
    case matchExpr_10 of
      (ErlangTuple [used1_7, vals_8, maps1_9]) ->
        let    tup_el_14 = BIF.erlang__list_to_tuple__1 [vals_8]
        in let tup_el_12 = ErlangTuple [ErlangAtom "tuple", tup_el_14]
        in ErlangTuple [used1_7, tup_el_12, maps1_9]
      _ -> EXC.badmatch matchExpr_10
erlps__allocate_store_maps__3__p2 [used_0, val_1, maps_2]
  | isEList val_1 =
  let
    matchExpr_9 =
      erlps__allocate_store_maps_l__3 [used_0, val_1, maps_2]
  in
    case matchExpr_9 of
      (ErlangTuple [used1_6, vals_7, maps1_8]) ->
        ErlangTuple [used1_6, vals_7, maps1_8]
      _ -> EXC.badmatch matchExpr_9
erlps__allocate_store_maps__3__p2 [used_0,
                                   (ErlangTuple [(ErlangAtom "variant"),
                                                 arities_1, tag_2, vals_3]),
                                   maps_4]
  =
  let    arg_6 = BIF.erlang__tuple_to_list__1 [vals_3]
  in let
    matchExpr_12 =
      erlps__allocate_store_maps_l__3 [used_0, arg_6, maps_4]
  in
    case matchExpr_12 of
      (ErlangTuple [used1_9, vals1_10, maps1_11]) ->
        let    tup_el_18 = BIF.erlang__list_to_tuple__1 [vals1_10]
        in let
          tup_el_14 =
            ErlangTuple [ErlangAtom "variant", arities_1, tag_2, tup_el_18]
        in ErlangTuple [used1_9, tup_el_14, maps1_11]
      _ -> EXC.badmatch matchExpr_12
erlps__allocate_store_maps__3__p2 [used_0, val_1, maps_2]
  | isEMap val_1 =
  let
    matchExpr_9 =
      erlps__allocate_store_maps_m__3 [used_0, val_1, maps_2]
  in
    case matchExpr_9 of
      (ErlangTuple [used1_6, kvs_7, maps1_8]) ->
        let   
          arg_13 =
            BIF.do_remote_fun_call "Aeb.Fate.Encoding" "erlps__serialize__1"
              [kvs_7]
        in let lop_12 = BIF.erlang__byte_size__1 [arg_13]
        in let rop_15 = toErl 100
        in let case_11 = BIF.erlang__op_lesser [lop_12, rop_15]
        in
          case case_11 of
            (ErlangAtom "true") -> ErlangTuple [used1_6, kvs_7, maps1_8]
            (ErlangAtom "false") ->
              let matchExpr_22 = erlps__next_id__1 [used1_6]
              in
                case matchExpr_22 of
                  (ErlangTuple [id_20, used2_21]) ->
                    let    tup_el_26 = ErlangMap Map.empty
                    in let
                      tup_el_24 =
                        ErlangTuple [ErlangAtom "store_map", tup_el_26, id_20]
                    in let mapExt_32 = ErlangMap (Map.singleton id_20 kvs_7)
                    in let tup_el_28 = BIF.maps__merge__2 [maps1_8, mapExt_32]
                    in ErlangTuple [used2_21, tup_el_24, tup_el_28]
                  _ -> EXC.badmatch matchExpr_22
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_9
erlps__allocate_store_maps__3__p2 args =
  erlps__allocate_store_maps__3__p3 args

erlps__allocate_store_maps__3__p3 :: ErlangFun
erlps__allocate_store_maps__3__p3 [used_0,
                                   val_3@(ErlangTuple [(ErlangAtom "store_map"),
                                                       cache_1, _id_2]),
                                   maps_4]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let rop_9 = ErlangMap Map.empty
             in BIF.erlang__op_exactEq [cache_1, rop_9]))) =
  ErlangTuple [used_0, val_3, maps_4]
erlps__allocate_store_maps__3__p3 [used_0,
                                   (ErlangTuple [(ErlangAtom "store_map"),
                                                 cache_1, id_2]),
                                   maps_3]
  =
  let matchExpr_7 = erlps__next_id__1 [used_0]
  in
    case matchExpr_7 of
      (ErlangTuple [newid_5, used1_6]) ->
        let
          matchExpr_14 =
            erlps__allocate_store_maps_m__3 [used1_6, cache_1, maps_3]
        in
          case matchExpr_14 of
            (ErlangTuple [used2_11, cache1_12, maps1_13]) ->
              let    tup_el_18 = ErlangMap Map.empty
              in let
                tup_el_16 =
                  ErlangTuple [ErlangAtom "store_map", tup_el_18, newid_5]
              in let
                val_23 = ErlangTuple [ErlangAtom "store_map", cache1_12, id_2]
              in let mapExt_27 = ErlangMap (Map.singleton newid_5 val_23)
              in let tup_el_20 = BIF.maps__merge__2 [maps1_13, mapExt_27]
              in ErlangTuple [used2_11, tup_el_16, tup_el_20]
            _ -> EXC.badmatch matchExpr_14
      _ -> EXC.badmatch matchExpr_7
erlps__allocate_store_maps__3__p3 [arg_29, arg_30, arg_31] =
  EXC.function_clause unit
erlps__allocate_store_maps__3__p3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__allocate_store_maps_l__3 :: ErlangFun
erlps__allocate_store_maps_l__3 [used_0, (ErlangEmptyList),
                                 maps_1]
  =
  ErlangTuple [used_0, ErlangEmptyList, maps_1]
erlps__allocate_store_maps_l__3 [used_0, (ErlangCons h_1 t_2),
                                 maps_3]
  =
  let
    matchExpr_10 =
      erlps__allocate_store_maps__3 [used_0, h_1, maps_3]
  in
    case matchExpr_10 of
      (ErlangTuple [used1_7, h1_8, maps1_9]) ->
        let
          matchExpr_17 =
            erlps__allocate_store_maps__3 [used1_7, t_2, maps1_9]
        in
          case matchExpr_17 of
            (ErlangTuple [used2_14, t1_15, maps2_16]) ->
              ErlangTuple [used2_14, ErlangCons h1_8 t1_15, maps2_16]
            _ -> EXC.badmatch matchExpr_17
      _ -> EXC.badmatch matchExpr_10
erlps__allocate_store_maps_l__3 [arg_23, arg_24, arg_25] =
  EXC.function_clause unit
erlps__allocate_store_maps_l__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__allocate_store_maps_m__3 :: ErlangFun
erlps__allocate_store_maps_m__3 [used_0, val_1, maps_2] =
  let   
    arg_3 =
      ErlangFun 3
        (let
           lambda_4 [k_8, v_9, (ErlangTuple [us_10, m_11, ms_12])] =
             let
               matchExpr_19 = erlps__allocate_store_maps__3 [us_10, v_9, ms_12]
             in
               case matchExpr_19 of
                 (ErlangTuple [us1_16, v1_17, ms1_18]) ->
                   let    mapExt_25 = ErlangMap (Map.singleton k_8 v1_17)
                   in let tup_el_21 = BIF.maps__merge__2 [m_11, mapExt_25]
                   in ErlangTuple [us1_16, tup_el_21, ms1_18]
                 _ -> EXC.badmatch matchExpr_19
           lambda_4 [arg_5, arg_6, arg_7] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 3 lambda_4) args
         in lambda_4)
  in let tup_el_30 = ErlangMap Map.empty
  in let arg_28 = ErlangTuple [used_0, tup_el_30, maps_2]
  in
    BIF.do_remote_fun_call "Maps" "erlps__fold__3"
      [arg_3, arg_28, val_1]
erlps__allocate_store_maps_m__3 [arg_33, arg_34, arg_35] =
  EXC.function_clause unit
erlps__allocate_store_maps_m__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__unfold_store_maps__2 :: ErlangFun
erlps__unfold_store_maps__2 [_unfold_0,
                             val_1@(ErlangAtom "__DELETED__")]
  =
  val_1
erlps__unfold_store_maps__2 [_unfold_0,
                             val_1@(ErlangAtom "true")]
  =
  val_1
erlps__unfold_store_maps__2 [_unfold_0,
                             val_1@(ErlangAtom "false")]
  =
  val_1
erlps__unfold_store_maps__2 [_unfold_0,
                             val_1@(ErlangTuple [(ErlangAtom "tuple"),
                                                 (ErlangTuple [])])]
  =
  val_1
erlps__unfold_store_maps__2 [_unfold_0,
                             val_1@(ErlangTuple [(ErlangAtom "bits"), _])]
  =
  val_1
erlps__unfold_store_maps__2 [_unfold_0,
                             val_1@(ErlangTuple [(ErlangAtom "bytes"), _])]
  =
  val_1
erlps__unfold_store_maps__2 [_unfold_0,
                             val_1@(ErlangTuple [(ErlangAtom "address"), _])]
  =
  val_1
erlps__unfold_store_maps__2 [_unfold_0,
                             val_1@(ErlangTuple [(ErlangAtom "contract"), _])]
  =
  val_1
erlps__unfold_store_maps__2 [_unfold_0,
                             val_1@(ErlangTuple [(ErlangAtom "oracle"), _])]
  =
  val_1
erlps__unfold_store_maps__2 [_unfold_0,
                             val_1@(ErlangTuple [(ErlangAtom "oracle_query"),
                                                 _])]
  =
  val_1
erlps__unfold_store_maps__2 args =
  erlps__unfold_store_maps__2__p1 args

erlps__unfold_store_maps__2__p1 :: ErlangFun
erlps__unfold_store_maps__2__p1 [_unfold_0,
                                 val_1@(ErlangTuple [(ErlangAtom "channel"),
                                                     _])]
  =
  val_1
erlps__unfold_store_maps__2__p1 [_unfold_0,
                                 val_1@(ErlangTuple [(ErlangAtom "typerep"),
                                                     _])]
  =
  val_1
erlps__unfold_store_maps__2__p1 [_unfold_0, val_1]
  | isEInt val_1 =
  val_1
erlps__unfold_store_maps__2__p1 [_unfold_0, val_1]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [val_1]))) =
  val_1
erlps__unfold_store_maps__2__p1 [unfold_0,
                                 (ErlangTuple [(ErlangAtom "tuple"), val_1])]
  =
  let    arg_3 = BIF.erlang__tuple_to_list__1 [val_1]
  in let vals_5 = erlps__unfold_store_maps_l__2 [unfold_0, arg_3]
  in let tup_el_7 = BIF.erlang__list_to_tuple__1 [vals_5]
  in ErlangTuple [ErlangAtom "tuple", tup_el_7]
erlps__unfold_store_maps__2__p1 [unfold_0, val_1]
  | isEList val_1 =
  erlps__unfold_store_maps_l__2 [unfold_0, val_1]
erlps__unfold_store_maps__2__p1 [unfold_0,
                                 (ErlangTuple [(ErlangAtom "variant"),
                                               arities_1, tag_2, vals_3])]
  =
  let    arg_5 = BIF.erlang__tuple_to_list__1 [vals_3]
  in let vals1_7 = erlps__unfold_store_maps_l__2 [unfold_0, arg_5]
  in let tup_el_11 = BIF.erlang__list_to_tuple__1 [vals1_7]
  in
    ErlangTuple [ErlangAtom "variant", arities_1, tag_2, tup_el_11]
erlps__unfold_store_maps__2__p1 [unfold_0, val_1]
  | isEMap val_1 =
  erlps__unfold_store_maps_m__2 [unfold_0, val_1]
erlps__unfold_store_maps__2__p1 [unfold_0,
                                 (ErlangTuple [(ErlangAtom "store_map"),
                                               cache_1, id_2])]
  =
  let   
    storemap_5 =
      BIF.erlang__apply__2 [unfold_0, ErlangCons id_2 ErlangEmptyList]
  in let arg_6 = ErlangFun 3 erlps__write_cache__3
  in let arg_7 = erlps__unfold_store_maps__2 [unfold_0, storemap_5]
  in let arg_10 = erlps__unfold_store_maps_m__2 [unfold_0, cache_1]
  in
    BIF.do_remote_fun_call "Maps" "erlps__fold__3"
      [arg_6, arg_7, arg_10]
erlps__unfold_store_maps__2__p1 [arg_13, arg_14] =
  EXC.function_clause unit
erlps__unfold_store_maps__2__p1 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__unfold_store_maps_l__2 :: ErlangFun
erlps__unfold_store_maps_l__2 [unfold_0, vals_1] =
  flmap
    (\ lc_4 ->
       let lcRet_5 = erlps__unfold_store_maps__2 [unfold_0, lc_4]
       in ErlangCons lcRet_5 ErlangEmptyList)
    vals_1
erlps__unfold_store_maps_l__2 [arg_8, arg_9] =
  EXC.function_clause unit
erlps__unfold_store_maps_l__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__unfold_store_maps_m__2 :: ErlangFun
erlps__unfold_store_maps_m__2 [unfold_0, val_1] =
  let
    arg_2 =
      ErlangFun 2
        (let
           lambda_3 [_, v_6] = erlps__unfold_store_maps__2 [unfold_0, v_6]
           lambda_3 [arg_4, arg_5] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 2 lambda_3) args
         in lambda_3)
  in BIF.do_remote_fun_call "Maps" "erlps__map__2" [arg_2, val_1]
erlps__unfold_store_maps_m__2 [arg_10, arg_11] =
  EXC.function_clause unit
erlps__unfold_store_maps_m__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__write_cache__3 :: ErlangFun
erlps__write_cache__3 [key_0, (ErlangAtom "__DELETED__"), map_1]
  =
  BIF.maps__remove__2 [key_0, map_1]
erlps__write_cache__3 [key_0, val_1, map_2] =
  let mapExt_6 = ErlangMap (Map.singleton key_0 val_1)
  in BIF.maps__merge__2 [map_2, mapExt_6]
erlps__write_cache__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__write_cache__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__refcount_zero__0 :: ErlangFun
erlps__refcount_zero__0 [] = ErlangMap Map.empty
erlps__refcount_zero__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__refcount_diff__2 :: ErlangFun
erlps__refcount_diff__2 [new_0, old_1] =
  let
    arg_2 =
      ErlangFun 3
        (let
           lambda_3 [k_7, n_8, c_9] =
             let   
               arg_11 =
                 ErlangFun 1
                   (let
                      lambda_12 [m_14] = BIF.erlang__op_minus [m_14, n_8]
                      lambda_12 [arg_13] = EXC.function_clause unit
                      lambda_12 args = EXC.badarity (ErlangFun 1 lambda_12) args
                    in lambda_12)
             in let arg_17 = BIF.erlang__op_neg [n_8]
             in
               BIF.do_remote_fun_call "Maps" "erlps__update_with__4"
                 [k_7, arg_11, arg_17, c_9]
           lambda_3 [arg_4, arg_5, arg_6] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 3 lambda_3) args
         in lambda_3)
  in
    BIF.do_remote_fun_call "Maps" "erlps__fold__3"
      [arg_2, new_0, old_1]
erlps__refcount_diff__2 [arg_22, arg_23] =
  EXC.function_clause unit
erlps__refcount_diff__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__refcount_union__1 :: ErlangFun
erlps__refcount_union__1 [counts_0] =
  let    arg_1 = ErlangFun 2 erlps__refcount_union__2
  in let arg_2 = ErlangMap Map.empty
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
      [arg_1, arg_2, counts_0]
erlps__refcount_union__1 [arg_4] = EXC.function_clause unit
erlps__refcount_union__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__refcount_union__2 :: ErlangFun
erlps__refcount_union__2 [a_0, b_1] =
  let
    arg_2 =
      ErlangFun 3
        (let
           lambda_3 [k_7, n_8, c_9] =
             let
               arg_11 =
                 ErlangFun 1
                   (let
                      lambda_12 [m_14] = BIF.erlang__op_plus [m_14, n_8]
                      lambda_12 [arg_13] = EXC.function_clause unit
                      lambda_12 args = EXC.badarity (ErlangFun 1 lambda_12) args
                    in lambda_12)
             in
               BIF.do_remote_fun_call "Maps" "erlps__update_with__4"
                 [k_7, arg_11, n_8, c_9]
           lambda_3 [arg_4, arg_5, arg_6] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 3 lambda_3) args
         in lambda_3)
  in
    BIF.do_remote_fun_call "Maps" "erlps__fold__3" [arg_2, b_1, a_0]
erlps__refcount_union__2 [arg_21, arg_22] =
  EXC.function_clause unit
erlps__refcount_union__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__has_store_maps__1 :: ErlangFun
erlps__has_store_maps__1 [val_0] =
  let    lop_1 = erlps__refcount_zero__0 []
  in let rop_2 = erlps__refcount__1 [val_0]
  in BIF.erlang__op_neq [lop_1, rop_2]
erlps__has_store_maps__1 [arg_4] = EXC.function_clause unit
erlps__has_store_maps__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__refcount__1 :: ErlangFun
erlps__refcount__1 [val_0] =
  let arg_2 = ErlangMap Map.empty
  in erlps__refcount__2 [val_0, arg_2]
erlps__refcount__1 [arg_3] = EXC.function_clause unit
erlps__refcount__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__refcount__2 :: ErlangFun
erlps__refcount__2 [(ErlangAtom "__DELETED__"), count_0] =
  count_0
erlps__refcount__2 [(ErlangAtom "true"), count_0] = count_0
erlps__refcount__2 [(ErlangAtom "false"), count_0] = count_0
erlps__refcount__2 [(ErlangTuple [(ErlangAtom "tuple"),
                                  (ErlangTuple [])]),
                    count_0]
  =
  count_0
erlps__refcount__2 [(ErlangTuple [(ErlangAtom "bits"), _]),
                    count_0]
  =
  count_0
erlps__refcount__2 [(ErlangTuple [(ErlangAtom "bytes"), _]),
                    count_0]
  =
  count_0
erlps__refcount__2 [(ErlangTuple [(ErlangAtom "address"), _]),
                    count_0]
  =
  count_0
erlps__refcount__2 [(ErlangTuple [(ErlangAtom "contract"), _]),
                    count_0]
  =
  count_0
erlps__refcount__2 [(ErlangTuple [(ErlangAtom "oracle"), _]),
                    count_0]
  =
  count_0
erlps__refcount__2 [(ErlangTuple [(ErlangAtom "oracle_query"),
                                  _]),
                    count_0]
  =
  count_0
erlps__refcount__2 args = erlps__refcount__2__p1 args

erlps__refcount__2__p1 :: ErlangFun
erlps__refcount__2__p1 [(ErlangTuple [(ErlangAtom "channel"),
                                      _]),
                        count_0]
  =
  count_0
erlps__refcount__2__p1 [(ErlangTuple [(ErlangAtom "typerep"),
                                      _]),
                        count_0]
  =
  count_0
erlps__refcount__2__p1 [val_0, count_1] | isEInt val_0 = count_1
erlps__refcount__2__p1 [val_0, count_1]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [val_0]))) =
  count_1
erlps__refcount__2__p1 [(ErlangTuple [(ErlangAtom "tuple"),
                                      val_0]),
                        count_1]
  =
  let arg_2 = BIF.erlang__tuple_to_list__1 [val_0]
  in erlps__refcount_l__2 [arg_2, count_1]
erlps__refcount__2__p1 [val_0, count_1] | isEList val_0 =
  erlps__refcount_l__2 [val_0, count_1]
erlps__refcount__2__p1 [(ErlangTuple [(ErlangAtom "variant"),
                                      _arities_0, _tag_1, vals_2]),
                        count_3]
  =
  let arg_4 = BIF.erlang__tuple_to_list__1 [vals_2]
  in erlps__refcount_l__2 [arg_4, count_3]
erlps__refcount__2__p1 [val_0, count_1] | isEMap val_0 =
  erlps__refcount_m__2 [val_0, count_1]
erlps__refcount__2__p1 [(ErlangTuple [(ErlangAtom "store_map"),
                                      cache_0, id_1]),
                        count_2]
  =
  let   
    arg_6 =
      ErlangFun 1
        (let
           lambda_7 [n_9] =
             let rop_11 = toErl 1
             in BIF.erlang__op_plus [n_9, rop_11]
           lambda_7 [arg_8] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
         in lambda_7)
  in let arg_12 = toErl 1
  in let
    arg_4 =
      BIF.do_remote_fun_call "Maps" "erlps__update_with__4"
        [id_1, arg_6, arg_12, count_2]
  in erlps__refcount_m__2 [cache_0, arg_4]
erlps__refcount__2__p1 [arg_14, arg_15] =
  EXC.function_clause unit
erlps__refcount__2__p1 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__refcount_l__2 :: ErlangFun
erlps__refcount_l__2 [vals_0, count_1] =
  let arg_2 = ErlangFun 2 erlps__refcount__2
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
      [arg_2, count_1, vals_0]
erlps__refcount_l__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__refcount_l__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__refcount_m__2 :: ErlangFun
erlps__refcount_m__2 [val_0, count_1] =
  let
    arg_2 =
      ErlangFun 3
        (let
           lambda_3 [_, (ErlangAtom "__DELETED__"), c_7] = c_7
           lambda_3 [_, v_8, c_9] = erlps__refcount__2 [v_8, c_9]
           lambda_3 [arg_4, arg_5, arg_6] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 3 lambda_3) args
         in lambda_3)
  in
    BIF.do_remote_fun_call "Maps" "erlps__fold__3"
      [arg_2, count_1, val_0]
erlps__refcount_m__2 [arg_14, arg_15] = EXC.function_clause unit
erlps__refcount_m__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__no_used_ids__0 :: ErlangFun
erlps__no_used_ids__0 [] = ErlangEmptyList
erlps__no_used_ids__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__next_id__1 :: ErlangFun
erlps__next_id__1 [usedids_0] =
  let arg_2 = toErl 0
  in erlps__next_id__3 [usedids_0, arg_2, ErlangEmptyList]
erlps__next_id__1 [arg_4] = EXC.function_clause unit
erlps__next_id__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__next_id__3 :: ErlangFun
erlps__next_id__3 [used_0, j_1, acc_2]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let lop_10 = BIF.erlang__op_eq [used_0, ErlangEmptyList]
             in
               case lop_10 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   let rop_14 = BIF.erlang__hd__1 [used_0]
                   in BIF.erlang__op_lesser [j_1, rop_14]
                 _ -> EXC.badarg1 lop_10))) =
  let   
    lop_5 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_2]
  in let
    tup_el_4 = BIF.erlang__op_append [lop_5, ErlangCons j_1 used_0]
  in ErlangTuple [j_1, tup_el_4]
erlps__next_id__3 [(ErlangCons i_0 used_1), i_2, acc_3]
  | (i_2 == i_0) =
  let    rop_7 = toErl 1
  in let arg_5 = BIF.erlang__op_plus [i_0, rop_7]
  in erlps__next_id__3 [used_1, arg_5, ErlangCons i_0 acc_3]
erlps__next_id__3 [(ErlangCons i_0 used_1), j_2, acc_3]
  | weakGt j_2 i_0 =
  erlps__next_id__3 [used_1, j_2, ErlangCons i_0 acc_3]
erlps__next_id__3 [arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__next_id__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args