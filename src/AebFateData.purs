module Aeb.Fate.Data(erlps__make_integer__1,
                     erlps__make_boolean__1, erlps__make_list__1,
                     erlps__make_variant__3, erlps__make_tuple__1,
                     erlps__make_string__1, erlps__make_map__1,
                     erlps__make_store_map__1, erlps__make_store_map__2,
                     erlps__make_address__1, erlps__make_bytes__1,
                     erlps__make_hash__1, erlps__make_signature__1,
                     erlps__make_contract__1, erlps__make_oracle__1,
                     erlps__make_oracle_query__1, erlps__make_channel__1,
                     erlps__make_bits__1, erlps__make_unit__0,
                     erlps__make_typerep__1, erlps__make_contract_bytearray__1,
                     erlps__elt__2, erlps__lt__2, erlps__format__1,
                     erlps__ordinal__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__make_boolean__1 :: ErlangFun
erlps__make_boolean__1 [(ErlangAtom "true")] = ErlangAtom "true"
erlps__make_boolean__1 [(ErlangAtom "false")] =
  ErlangAtom "false"
erlps__make_boolean__1 [arg_0] = EXC.function_clause unit
erlps__make_boolean__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_list__1 :: ErlangFun
erlps__make_list__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__make_list__1 [l_0] = l_0
erlps__make_list__1 [arg_1] = EXC.function_clause unit
erlps__make_list__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_unit__0 :: ErlangFun
erlps__make_unit__0 [] =
  let tup_el_1 = ErlangTuple []
  in ErlangTuple [ErlangAtom "tuple", tup_el_1]
erlps__make_unit__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_tuple__1 :: ErlangFun
erlps__make_tuple__1 [t_0] =
  ErlangTuple [ErlangAtom "tuple", t_0]
erlps__make_tuple__1 [arg_3] = EXC.function_clause unit
erlps__make_tuple__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_map__1 :: ErlangFun
erlps__make_map__1 [m_0] = m_0
erlps__make_map__1 [arg_1] = EXC.function_clause unit
erlps__make_map__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_store_map__1 :: ErlangFun
erlps__make_store_map__1 [id_0] =
  let arg_1 = ErlangMap Map.empty
  in erlps__make_store_map__2 [arg_1, id_0]
erlps__make_store_map__1 [arg_3] = EXC.function_clause unit
erlps__make_store_map__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_store_map__2 :: ErlangFun
erlps__make_store_map__2 [cache_0, id_1] =
  ErlangTuple [ErlangAtom "store_map", cache_0, id_1]
erlps__make_store_map__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__make_store_map__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_address__1 :: ErlangFun
erlps__make_address__1 [x_0] =
  ErlangTuple [ErlangAtom "address", x_0]
erlps__make_address__1 [arg_3] = EXC.function_clause unit
erlps__make_address__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_bytes__1 :: ErlangFun
erlps__make_bytes__1 [x_0] =
  ErlangTuple [ErlangAtom "bytes", x_0]
erlps__make_bytes__1 [arg_3] = EXC.function_clause unit
erlps__make_bytes__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_hash__1 :: ErlangFun
erlps__make_hash__1 [x_0] = erlps__make_bytes__1 [x_0]
erlps__make_hash__1 [arg_2] = EXC.function_clause unit
erlps__make_hash__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_signature__1 :: ErlangFun
erlps__make_signature__1 [x_0] = erlps__make_bytes__1 [x_0]
erlps__make_signature__1 [arg_2] = EXC.function_clause unit
erlps__make_signature__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_contract__1 :: ErlangFun
erlps__make_contract__1 [x_0] =
  ErlangTuple [ErlangAtom "contract", x_0]
erlps__make_contract__1 [arg_3] = EXC.function_clause unit
erlps__make_contract__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_oracle__1 :: ErlangFun
erlps__make_oracle__1 [x_0] =
  ErlangTuple [ErlangAtom "oracle", x_0]
erlps__make_oracle__1 [arg_3] = EXC.function_clause unit
erlps__make_oracle__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_oracle_query__1 :: ErlangFun
erlps__make_oracle_query__1 [x_0] =
  ErlangTuple [ErlangAtom "oracle_query", x_0]
erlps__make_oracle_query__1 [arg_3] = EXC.function_clause unit
erlps__make_oracle_query__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_channel__1 :: ErlangFun
erlps__make_channel__1 [x_0] =
  ErlangTuple [ErlangAtom "channel", x_0]
erlps__make_channel__1 [arg_3] = EXC.function_clause unit
erlps__make_channel__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_integer__1 :: ErlangFun
erlps__make_integer__1 [i_0] | isEInt i_0 = i_0
erlps__make_integer__1 [arg_1] = EXC.function_clause unit
erlps__make_integer__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_bits__1 :: ErlangFun
erlps__make_bits__1 [i_0] | isEInt i_0 =
  ErlangTuple [ErlangAtom "bits", i_0]
erlps__make_bits__1 [arg_3] = EXC.function_clause unit
erlps__make_bits__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_string__1 :: ErlangFun
erlps__make_string__1 [s_0] | isEList s_0 =
  BIF.erlang__iolist_to_binary__1 [s_0]
erlps__make_string__1 [s_0]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [s_0])) =
  s_0
erlps__make_string__1 [arg_2] = EXC.function_clause unit
erlps__make_string__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_typerep__1 :: ErlangFun
erlps__make_typerep__1 [t_0] =
  ErlangTuple [ErlangAtom "typerep", t_0]
erlps__make_typerep__1 [arg_3] = EXC.function_clause unit
erlps__make_typerep__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_contract_bytearray__1 :: ErlangFun
erlps__make_contract_bytearray__1 [b_0] =
  ErlangTuple [ErlangAtom "contract_bytearray", b_0]
erlps__make_contract_bytearray__1 [arg_3] =
  EXC.function_clause unit
erlps__make_contract_bytearray__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_variant__3 :: ErlangFun
erlps__make_variant__3 [arities_0, tag_1, values_2] =
  let
    matchExpr_13 =
      flmap
        (\ lc_5 ->
           let cond_6 = BIF.erlang__is_integer__1 [lc_5]
           in
             case cond_6 of
               (ErlangAtom "true") ->
                 let    rop_10 = toErl 256
                 in let cond_8 = BIF.erlang__op_lesser [lc_5, rop_10]
                 in
                   case cond_8 of
                     (ErlangAtom "true") -> ErlangCons lc_5 ErlangEmptyList
                     _ -> ErlangEmptyList
               _ -> ErlangEmptyList)
        arities_0
  in
    case matchExpr_13 of
      arities_12 | arities_12 == arities_0 ->
        let size_15 = BIF.erlang__length__1 [arities_0]
        in
          case ErlangAtom "true" of
            _ | (((isEInt tag_1) && (weakLeq (toErl 0) tag_1)) &&
                   (weakLt tag_1 size_15)) &&
                  (isETuple values_2) ->
              let    rop_18 = toErl 1
              in let arg_16 = BIF.erlang__op_plus [tag_1, rop_18]
              in let
                arity_20 =
                  BIF.do_remote_fun_call "Lists" "erlps__nth__2"
                    [arg_16, arities_0]
              in
                case ErlangAtom "true" of
                  _ | (ErlangAtom "true") ==
                        (falsifyErrors
                           (\ _ ->
                              let lop_21 = BIF.erlang__size__1 [values_2]
                              in BIF.erlang__op_exactEq [lop_21, arity_20])) ->
                    ErlangTuple
                      [ErlangAtom "variant", arities_0, tag_1, values_2]
                  _ -> EXC.if_clause unit
            _ -> EXC.if_clause unit
      _ -> EXC.badmatch matchExpr_13
erlps__make_variant__3 [arg_28, arg_29, arg_30] =
  EXC.function_clause unit
erlps__make_variant__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format__1 :: ErlangFun
erlps__format__1 [i_0] | isEInt i_0 =
  BIF.erlang__integer_to_list__1 [i_0]
erlps__format__1 [(ErlangAtom "true")] = toErl "true"
erlps__format__1 [(ErlangAtom "false")] = toErl "false"
erlps__format__1 [(ErlangEmptyList)] = toErl "[]"
erlps__format__1 [l_0] | isEList l_0 =
  erlps__format_list__1 [l_0]
erlps__format__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                (ErlangTuple [])])]
  =
  toErl "()"
erlps__format__1 [(ErlangTuple [(ErlangAtom "tuple"), t_0])] =
  let    head_1 = toErl "( "
  in let arg_4 = toErl ", "
  in let lcSrc_6 = BIF.erlang__tuple_to_list__1 [t_0]
  in let
    arg_5 =
      flmap
        (\ lc_9 ->
           let lcRet_10 = erlps__format__1 [lc_9]
           in ErlangCons lcRet_10 ErlangEmptyList)
        lcSrc_6
  in let
    head_3 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_4, arg_5]
  in let head_13 = toErl " )"
  in
    ErlangCons head_1
      (ErlangCons head_3 (ErlangCons head_13 ErlangEmptyList))
erlps__format__1 [s_0]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [s_0])) =
  let    head_1 = toErl "\""
  in let head_5 = toErl "\""
  in
    ErlangCons head_1
      (ErlangCons s_0 (ErlangCons head_5 ErlangEmptyList))
erlps__format__1 [(ErlangTuple [(ErlangAtom "bits"), b_0])]
  | weakGeq b_0 (toErl 0) =
  let    head_1 = toErl "<"
  in let arg_5 = toErl ""
  in let head_3 = erlps__format_bits__2 [b_0, arg_5]
  in let head_7 = toErl ">"
  in
    ErlangCons head_1
      (ErlangCons head_3 (ErlangCons head_7 ErlangEmptyList))
erlps__format__1 [(ErlangTuple [(ErlangAtom "bits"), b_0])]
  | weakLt b_0 (toErl 0) =
  let    head_1 = toErl "!< "
  in let lop_5 = BIF.erlang__op_neg [b_0]
  in let rop_7 = toErl 1
  in let arg_4 = BIF.erlang__op_minus [lop_5, rop_7]
  in let arg_8 = toErl ""
  in let head_3 = erlps__format_nbits__2 [arg_4, arg_8]
  in let head_10 = toErl " >"
  in
    ErlangCons head_1
      (ErlangCons head_3 (ErlangCons head_10 ErlangEmptyList))
erlps__format__1 [(ErlangTuple [(ErlangAtom "variant"),
                                arities_0, tag_1, t_2])]
  =
  let    head_3 = toErl "(| "
  in let arg_6 = toErl "| "
  in let head_8 = erlps__format_arities__1 [arities_0]
  in let head_11 = BIF.erlang__integer_to_list__1 [tag_1]
  in let arg_15 = erlps__make_tuple__1 [t_2]
  in let head_14 = erlps__format__1 [arg_15]
  in let
    head_5 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2"
        [arg_6,
         ErlangCons head_8
           (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))]
  in let head_19 = toErl " |)"
  in
    ErlangCons head_3
      (ErlangCons head_5 (ErlangCons head_19 ErlangEmptyList))
erlps__format__1 [m_0] | isEMap m_0 =
  let    head_1 = toErl "{ "
  in let arg_4 = BIF.maps__to_list__1 [m_0]
  in let head_3 = erlps__format_kvs__1 [arg_4]
  in let head_7 = toErl " }"
  in
    ErlangCons head_1
      (ErlangCons head_3 (ErlangCons head_7 ErlangEmptyList))
erlps__format__1 [(ErlangTuple [(ErlangAtom "bytes"), x_0])] =
  let    head_1 = toErl "#"
  in let
    head_3 = BIF.do_remote_fun_call "Base64" "erlps__encode__1" [x_0]
  in ErlangCons head_1 (ErlangCons head_3 ErlangEmptyList)
erlps__format__1 [(ErlangTuple [(ErlangAtom "address"), x_0])] =
  let    head_1 = toErl "@"
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeser.Api.Encoder" "erlps__encode__2"
        [ErlangAtom "account_pubkey", x_0]
  in ErlangCons head_1 (ErlangCons head_3 ErlangEmptyList)
erlps__format__1 [(ErlangTuple [(ErlangAtom "contract"), x_0])] =
  let    head_1 = toErl "@"
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeser.Api.Encoder" "erlps__encode__2"
        [ErlangAtom "contract_pubkey", x_0]
  in ErlangCons head_1 (ErlangCons head_3 ErlangEmptyList)
erlps__format__1 [(ErlangTuple [(ErlangAtom "oracle"), x_0])] =
  let    head_1 = toErl "@"
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeser.Api.Encoder" "erlps__encode__2"
        [ErlangAtom "oracle_pubkey", x_0]
  in ErlangCons head_1 (ErlangCons head_3 ErlangEmptyList)
erlps__format__1 [(ErlangTuple [(ErlangAtom "oracle_query"),
                                x_0])]
  =
  let    head_1 = toErl "@"
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeser.Api.Encoder" "erlps__encode__2"
        [ErlangAtom "oracle_query_id", x_0]
  in ErlangCons head_1 (ErlangCons head_3 ErlangEmptyList)
erlps__format__1 [(ErlangTuple [(ErlangAtom "channel"), x_0])] =
  let    head_1 = toErl "@"
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeser.Api.Encoder" "erlps__encode__2"
        [ErlangAtom "channel", x_0]
  in ErlangCons head_1 (ErlangCons head_3 ErlangEmptyList)
erlps__format__1 [(ErlangTuple [(ErlangAtom "typerep"), x_0])] =
  let    head_1 = toErl "\'"
  in let arg_4 = toErl "~p"
  in let
    head_3 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons x_0 ErlangEmptyList]
  in ErlangCons head_1 (ErlangCons head_3 ErlangEmptyList)
erlps__format__1 [(ErlangTuple [(ErlangAtom "contract_bytearray"),
                                b_0])]
  =
  let    head_1 = toErl "@"
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeser.Api.Encoder" "erlps__encode__2"
        [ErlangAtom "contract_bytearray", b_0]
  in ErlangCons head_1 (ErlangCons head_3 ErlangEmptyList)
erlps__format__1 [v_0] =
  let arg_1 = ErlangTuple [ErlangAtom "not_a_fate_type", v_0]
  in BIF.erlang__exit__1 [arg_1]
erlps__format__1 [arg_4] = EXC.function_clause unit
erlps__format__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format_bits__2 :: ErlangFun
erlps__format_bits__2 [(ErlangInt num_0), acc_1]
  | (ErlangInt num_0) == (toErl 0) =
  acc_1
erlps__format_bits__2 [n_0, acc_1] =
  let    lop_2 = toErl 48
  in let rop_5 = toErl 1
  in let rop_3 = BIF.erlang__band__2 [n_0, rop_5]
  in let bit_6 = BIF.erlang__op_plus [lop_2, rop_3]
  in let rop_9 = toErl 1
  in let arg_7 = BIF.erlang__bsr__2 [n_0, rop_9]
  in erlps__format_bits__2 [arg_7, ErlangCons bit_6 acc_1]
erlps__format_bits__2 [arg_13, arg_14] = EXC.function_clause unit
erlps__format_bits__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format_nbits__2 :: ErlangFun
erlps__format_nbits__2 [(ErlangInt num_0), acc_1]
  | (ErlangInt num_0) == (toErl 0) =
  acc_1
erlps__format_nbits__2 [n_0, acc_1] =
  let    lop_2 = toErl 49
  in let rop_5 = toErl 1
  in let rop_3 = BIF.erlang__band__2 [n_0, rop_5]
  in let bit_6 = BIF.erlang__op_minus [lop_2, rop_3]
  in let rop_9 = toErl 1
  in let arg_7 = BIF.erlang__bsr__2 [n_0, rop_9]
  in erlps__format_nbits__2 [arg_7, ErlangCons bit_6 acc_1]
erlps__format_nbits__2 [arg_13, arg_14] =
  EXC.function_clause unit
erlps__format_nbits__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format_arities__1 :: ErlangFun
erlps__format_arities__1 [arities_0] =
  let    head_1 = toErl "[ "
  in let arg_4 = toErl ", "
  in let
    arg_5 =
      flmap
        (\ lc_8 ->
           let lcRet_9 = BIF.erlang__integer_to_list__1 [lc_8]
           in ErlangCons lcRet_9 ErlangEmptyList)
        arities_0
  in let
    head_3 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_4, arg_5]
  in let head_12 = toErl " ]"
  in
    ErlangCons head_1
      (ErlangCons head_3 (ErlangCons head_12 ErlangEmptyList))
erlps__format_arities__1 [arg_14] = EXC.function_clause unit
erlps__format_arities__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format_list__1 :: ErlangFun
erlps__format_list__1 [list_0] =
  let    head_1 = toErl "[ "
  in let arg_4 = toErl ", "
  in let
    arg_5 =
      flmap
        (\ lc_8 ->
           let lcRet_9 = erlps__format__1 [lc_8]
           in ErlangCons lcRet_9 ErlangEmptyList)
        list_0
  in let
    head_3 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_4, arg_5]
  in let head_12 = toErl " ]"
  in
    ErlangCons head_1
      (ErlangCons head_3 (ErlangCons head_12 ErlangEmptyList))
erlps__format_list__1 [arg_14] = EXC.function_clause unit
erlps__format_list__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format_kvs__1 :: ErlangFun
erlps__format_kvs__1 [list_0] =
  let    arg_1 = toErl ", "
  in let
    arg_2 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [k_4, v_5]) ->
               let    head_8 = erlps__format__1 [k_4]
               in let head_11 = toErl " => "
               in let head_13 = erlps__format__1 [v_5]
               in
                 ErlangCons
                   (ErlangCons head_8
                      (ErlangCons head_11 (ErlangCons head_13 ErlangEmptyList)))
                   ErlangEmptyList
             _ -> ErlangEmptyList)
        list_0
  in BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_1, arg_2]
erlps__format_kvs__1 [arg_16] = EXC.function_clause unit
erlps__format_kvs__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__ordinal__1 :: ErlangFun
erlps__ordinal__1 [t_0] | isEInt t_0 = toErl 0
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_boolean__1 [t_0])) =
  toErl 1
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_1 = BIF.erlang__is_tuple__1 [t_0]
            in
              case lop_1 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    arg_6 = toErl 1
                  in let rop_5 = BIF.erlang__element__2 [arg_6, t_0]
                  in let lop_3 = BIF.erlang__op_eq [ErlangAtom "address", rop_5]
                  in
                    case lop_3 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_9 = toErl 2
                        in let arg_8 = BIF.erlang__element__2 [arg_9, t_0]
                        in BIF.erlang__is_binary__1 [arg_8]
                      _ -> EXC.badarg1 lop_3
                _ -> EXC.badarg1 lop_1)) =
  toErl 2
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_1 = BIF.erlang__is_tuple__1 [t_0]
            in
              case lop_1 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    arg_6 = toErl 1
                  in let rop_5 = BIF.erlang__element__2 [arg_6, t_0]
                  in let lop_3 = BIF.erlang__op_eq [ErlangAtom "channel", rop_5]
                  in
                    case lop_3 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_9 = toErl 2
                        in let arg_8 = BIF.erlang__element__2 [arg_9, t_0]
                        in BIF.erlang__is_binary__1 [arg_8]
                      _ -> EXC.badarg1 lop_3
                _ -> EXC.badarg1 lop_1)) =
  toErl 3
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_1 = BIF.erlang__is_tuple__1 [t_0]
            in
              case lop_1 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    arg_6 = toErl 1
                  in let rop_5 = BIF.erlang__element__2 [arg_6, t_0]
                  in let
                    lop_3 = BIF.erlang__op_eq [ErlangAtom "contract", rop_5]
                  in
                    case lop_3 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_9 = toErl 2
                        in let arg_8 = BIF.erlang__element__2 [arg_9, t_0]
                        in BIF.erlang__is_binary__1 [arg_8]
                      _ -> EXC.badarg1 lop_3
                _ -> EXC.badarg1 lop_1)) =
  toErl 4
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_1 = BIF.erlang__is_tuple__1 [t_0]
            in
              case lop_1 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    arg_6 = toErl 1
                  in let rop_5 = BIF.erlang__element__2 [arg_6, t_0]
                  in let lop_3 = BIF.erlang__op_eq [ErlangAtom "oracle", rop_5]
                  in
                    case lop_3 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_9 = toErl 2
                        in let arg_8 = BIF.erlang__element__2 [arg_9, t_0]
                        in BIF.erlang__is_binary__1 [arg_8]
                      _ -> EXC.badarg1 lop_3
                _ -> EXC.badarg1 lop_1)) =
  toErl 5
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_1 = BIF.erlang__is_tuple__1 [t_0]
            in
              case lop_1 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    arg_6 = toErl 1
                  in let rop_5 = BIF.erlang__element__2 [arg_6, t_0]
                  in let lop_3 = BIF.erlang__op_eq [ErlangAtom "bytes", rop_5]
                  in
                    case lop_3 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_9 = toErl 2
                        in let arg_8 = BIF.erlang__element__2 [arg_9, t_0]
                        in BIF.erlang__is_binary__1 [arg_8]
                      _ -> EXC.badarg1 lop_3
                _ -> EXC.badarg1 lop_1)) =
  toErl 6
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_1 = BIF.erlang__is_tuple__1 [t_0]
            in
              case lop_1 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    arg_6 = toErl 1
                  in let rop_5 = BIF.erlang__element__2 [arg_6, t_0]
                  in let lop_3 = BIF.erlang__op_eq [ErlangAtom "bits", rop_5]
                  in
                    case lop_3 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_9 = toErl 2
                        in let arg_8 = BIF.erlang__element__2 [arg_9, t_0]
                        in BIF.erlang__is_integer__1 [arg_8]
                      _ -> EXC.badarg1 lop_3
                _ -> EXC.badarg1 lop_1)) =
  toErl 7
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [t_0])) =
  toErl 8
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_1 = BIF.erlang__is_tuple__1 [t_0]
            in
              case lop_1 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    arg_6 = toErl 1
                  in let rop_5 = BIF.erlang__element__2 [arg_6, t_0]
                  in let lop_3 = BIF.erlang__op_eq [ErlangAtom "tuple", rop_5]
                  in
                    case lop_3 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_9 = toErl 2
                        in let arg_8 = BIF.erlang__element__2 [arg_9, t_0]
                        in BIF.erlang__is_tuple__1 [arg_8]
                      _ -> EXC.badarg1 lop_3
                _ -> EXC.badarg1 lop_1)) =
  toErl 9
erlps__ordinal__1 [t_0] | isEMap t_0 = toErl 10
erlps__ordinal__1 [t_0] | isEList t_0 = toErl 11
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_1 = BIF.erlang__is_tuple__1 [t_0]
            in
              case lop_1 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    arg_6 = toErl 1
                  in let rop_5 = BIF.erlang__element__2 [arg_6, t_0]
                  in let lop_3 = BIF.erlang__op_eq [ErlangAtom "variant", rop_5]
                  in
                    case lop_3 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_10 = toErl 2
                        in let arg_9 = BIF.erlang__element__2 [arg_10, t_0]
                        in let lop_8 = BIF.erlang__is_list__1 [arg_9]
                        in
                          case lop_8 of
                            (ErlangAtom "false") -> ErlangAtom "false"
                            (ErlangAtom "true") ->
                              let    arg_14 = toErl 3
                              in let
                                arg_13 = BIF.erlang__element__2 [arg_14, t_0]
                              in let lop_12 = BIF.erlang__is_integer__1 [arg_13]
                              in
                                case lop_12 of
                                  (ErlangAtom "false") -> ErlangAtom "false"
                                  (ErlangAtom "true") ->
                                    let    arg_17 = toErl 4
                                    in let
                                      arg_16 =
                                        BIF.erlang__element__2 [arg_17, t_0]
                                    in BIF.erlang__is_tuple__1 [arg_16]
                                  _ -> EXC.badarg1 lop_12
                            _ -> EXC.badarg1 lop_8
                      _ -> EXC.badarg1 lop_3
                _ -> EXC.badarg1 lop_1)) =
  toErl 12
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_1 = BIF.erlang__is_tuple__1 [t_0]
            in
              case lop_1 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    arg_6 = toErl 1
                  in let rop_5 = BIF.erlang__element__2 [arg_6, t_0]
                  in let
                    lop_3 = BIF.erlang__op_eq [ErlangAtom "oracle_query", rop_5]
                  in
                    case lop_3 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_9 = toErl 2
                        in let arg_8 = BIF.erlang__element__2 [arg_9, t_0]
                        in BIF.erlang__is_binary__1 [arg_8]
                      _ -> EXC.badarg1 lop_3
                _ -> EXC.badarg1 lop_1)) =
  toErl 13
erlps__ordinal__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_1 = BIF.erlang__is_tuple__1 [t_0]
            in
              case lop_1 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    lop_4 = BIF.erlang__tuple_size__1 [t_0]
                  in let rop_6 = toErl 2
                  in let lop_3 = BIF.erlang__op_exactEq [lop_4, rop_6]
                  in
                    case lop_3 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_9 = toErl 1
                        in let lop_8 = BIF.erlang__element__2 [arg_9, t_0]
                        in let
                          lop_7 =
                            BIF.erlang__op_exactEq
                              [lop_8, ErlangAtom "contract_bytearray"]
                        in
                          case lop_7 of
                            (ErlangAtom "false") -> ErlangAtom "false"
                            (ErlangAtom "true") ->
                              let    arg_13 = toErl 2
                              in let
                                arg_12 = BIF.erlang__element__2 [arg_13, t_0]
                              in BIF.erlang__is_binary__1 [arg_12]
                            _ -> EXC.badarg1 lop_7
                      _ -> EXC.badarg1 lop_3
                _ -> EXC.badarg1 lop_1)) =
  toErl 14
erlps__ordinal__1 [arg_15] = EXC.function_clause unit
erlps__ordinal__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lt__2 :: ErlangFun
erlps__lt__2 [a_0, b_1] =
  let    o1_3 = erlps__ordinal__1 [a_0]
  in let o2_5 = erlps__ordinal__1 [b_1]
  in
    case ErlangAtom "true" of
      _ | weakEq o1_3 o2_5 -> erlps__lt__3 [o1_3, a_0, b_1]
      _ -> BIF.erlang__op_lesser [o1_3, o2_5]
erlps__lt__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__lt__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lt__3 :: ErlangFun
erlps__lt__3 [(ErlangInt num_0), a_1, b_2]
  | (ErlangInt num_0) == (toErl 0)
  , (isEInt a_1) && (isEInt b_2) =
  BIF.erlang__op_lesser [a_1, b_2]
erlps__lt__3 [(ErlangInt num_0), a_1, b_2]
  | (ErlangInt num_0) == (toErl 1)
  , (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_5 = BIF.erlang__is_boolean__1 [a_1]
            in
              case lop_5 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") -> BIF.erlang__is_boolean__1 [b_2]
                _ -> EXC.badarg1 lop_5)) =
  BIF.erlang__op_lesser [a_1, b_2]
erlps__lt__3 [(ErlangInt num_0), a_1, b_2]
  | (ErlangInt num_0) == (toErl 7)
  , (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_14 = BIF.erlang__is_tuple__1 [a_1]
            in let
              lop_13 =
                case lop_14 of
                  (ErlangAtom "false") -> ErlangAtom "false"
                  (ErlangAtom "true") ->
                    let    arg_19 = toErl 1
                    in let rop_18 = BIF.erlang__element__2 [arg_19, a_1]
                    in let
                      lop_16 = BIF.erlang__op_eq [ErlangAtom "bits", rop_18]
                    in
                      case lop_16 of
                        (ErlangAtom "false") -> ErlangAtom "false"
                        (ErlangAtom "true") ->
                          let    arg_22 = toErl 2
                          in let arg_21 = BIF.erlang__element__2 [arg_22, a_1]
                          in BIF.erlang__is_integer__1 [arg_21]
                        _ -> EXC.badarg1 lop_16
                  _ -> EXC.badarg1 lop_14
            in
              case lop_13 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let lop_24 = BIF.erlang__is_tuple__1 [b_2]
                  in
                    case lop_24 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") ->
                        let    arg_29 = toErl 1
                        in let rop_28 = BIF.erlang__element__2 [arg_29, b_2]
                        in let
                          lop_26 = BIF.erlang__op_eq [ErlangAtom "bits", rop_28]
                        in
                          case lop_26 of
                            (ErlangAtom "false") -> ErlangAtom "false"
                            (ErlangAtom "true") ->
                              let    arg_32 = toErl 2
                              in let
                                arg_31 = BIF.erlang__element__2 [arg_32, b_2]
                              in BIF.erlang__is_integer__1 [arg_31]
                            _ -> EXC.badarg1 lop_26
                      _ -> EXC.badarg1 lop_24
                _ -> EXC.badarg1 lop_13)) =
  let    arg_3 = toErl 2
  in let bitsa_5 = BIF.erlang__element__2 [arg_3, a_1]
  in let arg_6 = toErl 2
  in let bitsb_8 = BIF.erlang__element__2 [arg_6, b_2]
  in
    case ErlangAtom "true" of
      _ | weakLt bitsa_5 (toErl 0) ->
        case ErlangAtom "true" of
          _ | weakLt bitsb_8 (toErl 0) ->
            BIF.erlang__op_lesser [bitsa_5, bitsb_8]
          _ -> ErlangAtom "false"
      _ | weakLt bitsb_8 (toErl 0) -> ErlangAtom "true"
      _ -> BIF.erlang__op_lesser [bitsa_5, bitsb_8]
erlps__lt__3 [(ErlangInt num_0),
              (ErlangTuple [(ErlangAtom "tuple"), a_1]),
              (ErlangTuple [(ErlangAtom "tuple"), b_2])]
  | (ErlangInt num_0) == (toErl 9) =
  let    sizea_4 = BIF.erlang__tuple_size__1 [a_1]
  in let sizeb_6 = BIF.erlang__tuple_size__1 [b_2]
  in let case_7 = BIF.erlang__op_minus [sizea_4, sizeb_6]
  in
    case case_7 of
      (ErlangInt num_10) | (ErlangInt num_10) == (toErl 0) ->
        let arg_11 = toErl 0
        in erlps__tuple_elements_lt__4 [arg_11, a_1, b_2, sizea_4]
      n_15 ->
        let rop_17 = toErl 0
        in BIF.erlang__op_lesser [n_15, rop_17]
erlps__lt__3 [(ErlangInt num_0), a_1, b_2]
  | (ErlangInt num_0) == (toErl 10) =
  let   
    sizea_4 = BIF.do_remote_fun_call "Maps" "erlps__size__1" [a_1]
  in let
    sizeb_6 = BIF.do_remote_fun_call "Maps" "erlps__size__1" [b_2]
  in let case_7 = BIF.erlang__op_minus [sizea_4, sizeb_6]
  in
    case case_7 of
      (ErlangInt num_10) | (ErlangInt num_10) == (toErl 0) ->
        erlps__maps_lt__2 [a_1, b_2]
      n_13 ->
        let rop_15 = toErl 0
        in BIF.erlang__op_lesser [n_13, rop_15]
erlps__lt__3 [(ErlangInt num_0), _, (ErlangEmptyList)]
  | (ErlangInt num_0) == (toErl 11) =
  ErlangAtom "false"
erlps__lt__3 [(ErlangInt num_0), (ErlangEmptyList), _]
  | (ErlangInt num_0) == (toErl 11) =
  ErlangAtom "true"
erlps__lt__3 [(ErlangInt num_0), (ErlangCons a_1 ra_2),
              (ErlangCons b_3 rb_4)]
  | (ErlangInt num_0) == (toErl 11) =
  case ErlangAtom "true" of
    _ | weakEq a_1 b_3 -> erlps__lt__2 [ra_2, rb_4]
    _ -> erlps__lt__2 [a_1, b_3]
erlps__lt__3 [(ErlangInt num_0),
              (ErlangTuple [(ErlangAtom "variant"), aritiesa_1, taga_2, ta_3]),
              (ErlangTuple [(ErlangAtom "variant"), aritiesb_4, tagb_5, tb_6])]
  | (ErlangInt num_0) == (toErl 12) =
  case ErlangAtom "true" of
    _ | (ErlangAtom "true") ==
          (falsifyErrors
             (\ _ ->
                let    lop_7 = BIF.erlang__length__1 [aritiesa_1]
                in let rop_9 = BIF.erlang__length__1 [aritiesb_4]
                in BIF.erlang__op_lesser [lop_7, rop_9])) ->
      ErlangAtom "true"
    _ | (ErlangAtom "true") ==
          (falsifyErrors
             (\ _ ->
                let    lop_11 = BIF.erlang__length__1 [aritiesa_1]
                in let rop_13 = BIF.erlang__length__1 [aritiesb_4]
                in BIF.erlang__op_greater [lop_11, rop_13])) ->
      ErlangAtom "false"
    _ ->
      case ErlangAtom "true" of
        _ | weakLt aritiesa_1 aritiesb_4 -> ErlangAtom "true"
        _ | weakGt aritiesa_1 aritiesb_4 -> ErlangAtom "false"
        _ ->
          case ErlangAtom "true" of
            _ | weakLt taga_2 tagb_5 -> ErlangAtom "true"
            _ | weakGt taga_2 tagb_5 -> ErlangAtom "false"
            _ ->
              let    arg_15 = erlps__make_tuple__1 [ta_3]
              in let arg_17 = erlps__make_tuple__1 [tb_6]
              in erlps__lt__2 [arg_15, arg_17]
erlps__lt__3 [(ErlangInt num_0),
              (ErlangTuple [(ErlangAtom "address"), a_1]),
              (ErlangTuple [(ErlangAtom "address"), b_2])]
  | (ErlangInt num_0) == (toErl 2) =
  BIF.erlang__op_lesser [a_1, b_2]
erlps__lt__3 [(ErlangInt num_0),
              (ErlangTuple [(ErlangAtom "channel"), a_1]),
              (ErlangTuple [(ErlangAtom "channel"), b_2])]
  | (ErlangInt num_0) == (toErl 3) =
  BIF.erlang__op_lesser [a_1, b_2]
erlps__lt__3 [(ErlangInt num_0),
              (ErlangTuple [(ErlangAtom "contract"), a_1]),
              (ErlangTuple [(ErlangAtom "contract"), b_2])]
  | (ErlangInt num_0) == (toErl 4) =
  BIF.erlang__op_lesser [a_1, b_2]
erlps__lt__3 [(ErlangInt num_0),
              (ErlangTuple [(ErlangAtom "oracle"), a_1]),
              (ErlangTuple [(ErlangAtom "oracle"), b_2])]
  | (ErlangInt num_0) == (toErl 5) =
  BIF.erlang__op_lesser [a_1, b_2]
erlps__lt__3 [(ErlangInt num_0),
              (ErlangTuple [(ErlangAtom "oracle_query"), a_1]),
              (ErlangTuple [(ErlangAtom "oracle_query"), b_2])]
  | (ErlangInt num_0) == (toErl 13) =
  BIF.erlang__op_lesser [a_1, b_2]
erlps__lt__3 [(ErlangInt num_0), a_1, b_2]
  | (ErlangInt num_0) == (toErl 8) =
  erlps__compare_bytes__2 [a_1, b_2]
erlps__lt__3 [(ErlangInt num_0),
              (ErlangTuple [(ErlangAtom "bytes"), a_1]),
              (ErlangTuple [(ErlangAtom "bytes"), b_2])]
  | (ErlangInt num_0) == (toErl 6) =
  erlps__compare_bytes__2 [a_1, b_2]
erlps__lt__3 [(ErlangInt num_0),
              (ErlangTuple [(ErlangAtom "contract_bytearray"), a_1]),
              (ErlangTuple [(ErlangAtom "contract_bytearray"), b_2])]
  | (ErlangInt num_0) == (toErl 14) =
  erlps__compare_bytes__2 [a_1, b_2]
erlps__lt__3 [arg_5, arg_6, arg_7] = EXC.function_clause unit
erlps__lt__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__compare_bytes__2 :: ErlangFun
erlps__compare_bytes__2 [a_0, b_1] =
  let    sizea_3 = BIF.erlang__byte_size__1 [a_0]
  in let sizeb_5 = BIF.erlang__byte_size__1 [b_1]
  in let case_6 = BIF.erlang__op_minus [sizea_3, sizeb_5]
  in
    case case_6 of
      (ErlangInt num_9) | (ErlangInt num_9) == (toErl 0) ->
        BIF.erlang__op_lesser [a_0, b_1]
      n_12 ->
        let rop_14 = toErl 0
        in BIF.erlang__op_lesser [n_12, rop_14]
erlps__compare_bytes__2 [arg_15, arg_16] =
  EXC.function_clause unit
erlps__compare_bytes__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__tuple_elements_lt__4 :: ErlangFun
erlps__tuple_elements_lt__4 [n_0, _a_1, _b_2, n_3] | n_3 == n_0 =
  ErlangAtom "false"
erlps__tuple_elements_lt__4 [n_0, a_1, b_2, size_3] =
  let    rop_5 = toErl 1
  in let e_6 = BIF.erlang__op_plus [n_0, rop_5]
  in let ea_9 = BIF.erlang__element__2 [e_6, a_1]
  in let eb_12 = BIF.erlang__element__2 [e_6, b_2]
  in
    case ErlangAtom "true" of
      _ | (==) ea_9 eb_12 ->
        erlps__tuple_elements_lt__4 [e_6, a_1, b_2, size_3]
      _ -> erlps__lt__2 [ea_9, eb_12]
erlps__tuple_elements_lt__4 [arg_19, arg_20, arg_21, arg_22] =
  EXC.function_clause unit
erlps__tuple_elements_lt__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__maps_lt__2 :: ErlangFun
erlps__maps_lt__2 [a_0, b_1] =
  let    ia_3 = erlps__maps_iterator__1 [a_0]
  in let ib_5 = erlps__maps_iterator__1 [b_1]
  in erlps__maps_i_lt__2 [ia_3, ib_5]
erlps__maps_lt__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__maps_lt__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__maps_i_lt__2 :: ErlangFun
erlps__maps_i_lt__2 [ia_0, ib_1] =
  let    tup_el_3 = erlps__maps_next__1 [ia_0]
  in let tup_el_5 = erlps__maps_next__1 [ib_1]
  in let case_2 = ErlangTuple [tup_el_3, tup_el_5]
  in
    case case_2 of
      (ErlangTuple [(ErlangAtom "none"), (ErlangAtom "none")]) ->
        ErlangAtom "false"
      (ErlangTuple [_, (ErlangAtom "none")]) -> ErlangAtom "false"
      (ErlangTuple [(ErlangAtom "none"), _]) -> ErlangAtom "true"
      (ErlangTuple [(ErlangTuple [ka1_7, va1_8, ia2_9]),
                    (ErlangTuple [kb1_10, vb1_11, ib2_12])]) ->
        let case_13 = erlps__lt__2 [ka1_7, kb1_10]
        in
          case case_13 of
            (ErlangAtom "true") -> ErlangAtom "true"
            (ErlangAtom "false") ->
              let case_16 = erlps__lt__2 [kb1_10, ka1_7]
              in
                case case_16 of
                  (ErlangAtom "true") -> ErlangAtom "false"
                  (ErlangAtom "false") ->
                    let case_19 = erlps__lt__2 [va1_8, vb1_11]
                    in
                      case case_19 of
                        (ErlangAtom "true") -> ErlangAtom "true"
                        (ErlangAtom "false") ->
                          let case_22 = erlps__lt__2 [vb1_11, va1_8]
                          in
                            case case_22 of
                              (ErlangAtom "true") -> ErlangAtom "false"
                              (ErlangAtom "false") ->
                                erlps__maps_i_lt__2 [ia2_9, ib2_12]
                              something_else -> EXC.case_clause something_else
                        something_else -> EXC.case_clause something_else
                  something_else -> EXC.case_clause something_else
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__maps_i_lt__2 [arg_27, arg_28] = EXC.function_clause unit
erlps__maps_i_lt__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__maps_iterator__1 :: ErlangFun
erlps__maps_iterator__1 [m_0] =
  let   
    arg_1 =
      ErlangFun 2
        (let
           lambda_2 [(ErlangTuple [k1_5, _]), (ErlangTuple [k2_6, _])] =
             erlps__lt__2 [k1_5, k2_6]
           lambda_2 [arg_3, arg_4] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 2 lambda_2) args
         in lambda_2)
  in let arg_9 = BIF.maps__to_list__1 [m_0]
  in BIF.do_remote_fun_call "Lists" "erlps__sort__2" [arg_1, arg_9]
erlps__maps_iterator__1 [arg_11] = EXC.function_clause unit
erlps__maps_iterator__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__maps_next__1 :: ErlangFun
erlps__maps_next__1 [(ErlangEmptyList)] = ErlangAtom "none"
erlps__maps_next__1 [(ErlangCons (ErlangTuple [k_0,
                                               v_1]) rest_2)]
  =
  ErlangTuple [k_0, v_1, rest_2]
erlps__maps_next__1 [arg_6] = EXC.function_clause unit
erlps__maps_next__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__elt__2 :: ErlangFun
erlps__elt__2 [a_0, a_1] | a_1 == a_0 = ErlangAtom "true"
erlps__elt__2 [a_0, b_1] =
  let r_4 = erlps__lt__2 [a_0, b_1]
  in r_4
erlps__elt__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__elt__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args