module Aeb.Heap(erlps__to_binary__1, erlps__to_binary__2,
                erlps__from_heap__3, erlps__from_binary__2,
                erlps__from_binary__3, erlps__maps_with_next_id__1,
                erlps__set_next_id__2, erlps__heap_fragment__3,
                erlps__heap_value__3, erlps__heap_value__4,
                erlps__heap_value_pointer__1, erlps__heap_value_maps__1,
                erlps__heap_value_offset__1, erlps__heap_value_heap__1,
                erlps__heap_value_byte_size__1, erlps__heap_fragment_maps__1,
                erlps__heap_fragment_offset__1,
                erlps__heap_fragment_heap__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__maps_with_next_id__1 :: ErlangFun
erlps__maps_with_next_id__1 [(ErlangTuple [(ErlangAtom "heap"),
                                           (ErlangTuple [(ErlangAtom "maps"), _,
                                                         n_0]),
                                           _, _])]
  =
  let tup_el_2 = ErlangMap Map.empty
  in ErlangTuple [ErlangAtom "maps", tup_el_2, n_0]
erlps__maps_with_next_id__1 [arg_4] = EXC.function_clause unit
erlps__maps_with_next_id__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__set_next_id__2 :: ErlangFun
erlps__set_next_id__2 [heap_0, n_1] =
  let   
    record_4 =
      case heap_0 of
        (ErlangTuple arr_7) | (DM.Just field_6) <- (arr_7 DA.!! 1) ->
          field_6
        _ -> EXC.badrecord (ErlangAtom "heap")
  in let
    record_updt_3 =
      case record_4 of
        (ErlangTuple [(ErlangAtom "maps"), maps_9, next_id_10]) ->
          ErlangTuple [ErlangAtom "maps", maps_9, n_1]
        _ -> EXC.badrecord (ErlangAtom "maps")
  in
    case heap_0 of
      (ErlangTuple [(ErlangAtom "heap"), maps_11, offset_12,
                    heap_13]) ->
        ErlangTuple
          [ErlangAtom "heap", record_updt_3, offset_12, heap_13]
      _ -> EXC.badrecord (ErlangAtom "heap")
erlps__set_next_id__2 [arg_14, arg_15] = EXC.function_clause unit
erlps__set_next_id__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_fragment__1 :: ErlangFun
erlps__heap_fragment__1 [heap_0] =
  let    tup_el_3 = ErlangMap Map.empty
  in let tup_el_4 = toErl 0
  in let
    arg_1 = ErlangTuple [ErlangAtom "maps", tup_el_3, tup_el_4]
  in let arg_5 = toErl 0
  in erlps__heap_fragment__3 [arg_1, arg_5, heap_0]
erlps__heap_fragment__1 [arg_7] = EXC.function_clause unit
erlps__heap_fragment__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_fragment__3 :: ErlangFun
erlps__heap_fragment__3 [maps_0, offset_1, heap_2] =
  ErlangTuple [ErlangAtom "heap", maps_0, offset_1, heap_2]
erlps__heap_fragment__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__heap_fragment__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_fragment_maps__1 :: ErlangFun
erlps__heap_fragment_maps__1 [(ErlangTuple [(ErlangAtom "heap"),
                                            maps_0, _, _])]
  =
  maps_0
erlps__heap_fragment_maps__1 [arg_1] = EXC.function_clause unit
erlps__heap_fragment_maps__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_fragment_offset__1 :: ErlangFun
erlps__heap_fragment_offset__1 [(ErlangTuple [(ErlangAtom "heap"),
                                              _, offs_0, _])]
  =
  offs_0
erlps__heap_fragment_offset__1 [arg_1] = EXC.function_clause unit
erlps__heap_fragment_offset__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_fragment_heap__1 :: ErlangFun
erlps__heap_fragment_heap__1 [(ErlangTuple [(ErlangAtom "heap"),
                                            _, _, heap_0])]
  =
  heap_0
erlps__heap_fragment_heap__1 [arg_1] = EXC.function_clause unit
erlps__heap_fragment_heap__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_value__3 :: ErlangFun
erlps__heap_value__3 [maps_0, ptr_1, heap_2] =
  let arg_6 = toErl 0
  in erlps__heap_value__4 [maps_0, ptr_1, heap_2, arg_6]
erlps__heap_value__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__heap_value__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_value__4 :: ErlangFun
erlps__heap_value__4 [maps_0, ptr_1, heap_2, offs_3] =
  let tup_el_5 = erlps__heap_fragment__3 [maps_0, offs_3, heap_2]
  in ErlangTuple [ptr_1, tup_el_5]
erlps__heap_value__4 [arg_9, arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__heap_value__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_value_pointer__1 :: ErlangFun
erlps__heap_value_pointer__1 [(ErlangTuple [ptr_0, _])] = ptr_0
erlps__heap_value_pointer__1 [arg_1] = EXC.function_clause unit
erlps__heap_value_pointer__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_value_maps__1 :: ErlangFun
erlps__heap_value_maps__1 [(ErlangTuple [_, heap_0])] =
  case heap_0 of
    (ErlangTuple arr_3) | (DM.Just field_2) <- (arr_3 DA.!! 1) ->
      field_2
    _ -> EXC.badrecord (ErlangAtom "heap")
erlps__heap_value_maps__1 [arg_4] = EXC.function_clause unit
erlps__heap_value_maps__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_value_offset__1 :: ErlangFun
erlps__heap_value_offset__1 [(ErlangTuple [_, heap_0])] =
  case heap_0 of
    (ErlangTuple arr_3) | (DM.Just field_2) <- (arr_3 DA.!! 2) ->
      field_2
    _ -> EXC.badrecord (ErlangAtom "heap")
erlps__heap_value_offset__1 [arg_4] = EXC.function_clause unit
erlps__heap_value_offset__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_value_heap__1 :: ErlangFun
erlps__heap_value_heap__1 [(ErlangTuple [_, heap_0])] =
  case heap_0 of
    (ErlangTuple arr_3) | (DM.Just field_2) <- (arr_3 DA.!! 3) ->
      field_2
    _ -> EXC.badrecord (ErlangAtom "heap")
erlps__heap_value_heap__1 [arg_4] = EXC.function_clause unit
erlps__heap_value_heap__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_value_byte_size__1 :: ErlangFun
erlps__heap_value_byte_size__1 [(ErlangTuple [_, heap_0])] =
  let   
    value_4 =
      case heap_0 of
        (ErlangTuple arr_3) | (DM.Just field_2) <- (arr_3 DA.!! 3) ->
          field_2
        _ -> EXC.badrecord (ErlangAtom "heap")
  in let
    maps_8 =
      case heap_0 of
        (ErlangTuple arr_7) | (DM.Just field_6) <- (arr_7 DA.!! 1) ->
          field_6
        _ -> EXC.badrecord (ErlangAtom "heap")
  in let
    valuesize_11 =
      case ErlangAtom "true" of
        _ | (ErlangAtom "true") ==
              (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [value_4])) ->
          BIF.erlang__byte_size__1 [value_4]
        _ -> toErl 0
  in let
    arg_14 =
      case maps_8 of
        (ErlangTuple arr_17) | (DM.Just field_16) <- (arr_17 DA.!! 1) ->
          field_16
        _ -> EXC.badrecord (ErlangAtom "maps")
  in let lcSrc_13 = BIF.maps__values__1 [arg_14]
  in let
    arg_12 =
      flmap
        (\ lc_19 ->
           let lcRet_20 = erlps__pmap_size__1 [lc_19]
           in ErlangCons lcRet_20 ErlangEmptyList)
        lcSrc_13
  in let
    mapssize_22 =
      BIF.do_remote_fun_call "Lists" "erlps__sum__1" [arg_12]
  in BIF.erlang__op_plus [valuesize_11, mapssize_22]
erlps__heap_value_byte_size__1 [arg_25] =
  EXC.function_clause unit
erlps__heap_value_byte_size__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pmap_size__1 :: ErlangFun
erlps__pmap_size__1 [(ErlangTuple [(ErlangAtom "pmap"), _, _, _,
                                   _, (ErlangAtom "stored")])]
  =
  toErl 0
erlps__pmap_size__1 [(ErlangTuple [(ErlangAtom "pmap"), _, _, _,
                                   _, data_0])]
  | isEMap data_0 =
  let    lcSrc_2 = BIF.maps__to_list__1 [data_0]
  in let
    arg_1 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [key_4, val_5]) ->
               let cond_7 = BIF.erlang__op_neq [val_5, ErlangAtom "tombstone"]
               in
                 case cond_7 of
                   (ErlangAtom "true") ->
                     let    lop_11 = BIF.erlang__byte_size__1 [key_4]
                     in let rop_13 = BIF.erlang__byte_size__1 [val_5]
                     in let lcRet_10 = BIF.erlang__op_plus [lop_11, rop_13]
                     in ErlangCons lcRet_10 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_2
  in BIF.do_remote_fun_call "Lists" "erlps__sum__1" [arg_1]
erlps__pmap_size__1 [arg_15] = EXC.function_clause unit
erlps__pmap_size__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_binary__1 :: ErlangFun
erlps__to_binary__1 [data_0] =
  let arg_2 = toErl 0
  in erlps__to_binary__2 [data_0, arg_2]
erlps__to_binary__1 [arg_3] = EXC.function_clause unit
erlps__to_binary__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_binary__2 :: ErlangFun
erlps__to_binary__2 [data_0, baseaddress_1] =
  let    rop_5 = toErl 32
  in let arg_3 = BIF.erlang__op_plus [baseaddress_1, rop_5]
  in let matchExpr_8 = erlps__to_binary1__2 [data_0, arg_3]
  in
    case matchExpr_8 of
      (ErlangTuple [address_6, memory_7]) ->
        let
          r_11 =
            ErlangBinary
              (BIN.concat
                 [BIN.fromInt address_6 (toErl 256) 1 BIN.Big,
                  BIN.binPrefix memory_7 (BIN.packedSize memory_7) 8])
        in r_11
      _ -> EXC.badmatch matchExpr_8
erlps__to_binary__2 [arg_12, arg_13] = EXC.function_clause unit
erlps__to_binary__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_binary1__2 :: ErlangFun
erlps__to_binary1__2 [data_0, _address_1] | isEInt data_0 =
  let tup_el_3 = ErlangBinary (BIN.concat [])
  in ErlangTuple [data_0, tup_el_3]
erlps__to_binary1__2 [data_0, address_1]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [data_0])) =
  let   
    words_3 =
      BIF.do_remote_fun_call "Aeb.Memory" "erlps__binary_to_words__1"
        [data_0]
  in let bin_el_6 = BIF.erlang__size__1 [data_0]
  in let
    bin_el_8 =
      BIN.concatErl
        (flmap
           (\ lc_11 ->
              let
                lcRet_12 =
                  ErlangBinary (BIN.fromInt lc_11 (toErl 256) 1 BIN.Big)
              in ErlangCons lcRet_12 ErlangEmptyList)
           words_3)
  in let
    tup_el_5 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_6 (toErl 256) 1 BIN.Big,
            BIN.binPrefix bin_el_8 (BIN.packedSize bin_el_8) 8])
  in ErlangTuple [address_1, tup_el_5]
erlps__to_binary1__2 [(ErlangTuple [(ErlangAtom "contract_bytearray"),
                                    fatecode_0]),
                      address_1]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [fatecode_0])) =
  let   
    words_3 =
      BIF.do_remote_fun_call "Aeb.Memory" "erlps__binary_to_words__1"
        [fatecode_0]
  in let bin_el_6 = BIF.erlang__size__1 [fatecode_0]
  in let
    bin_el_8 =
      BIN.concatErl
        (flmap
           (\ lc_11 ->
              let
                lcRet_12 =
                  ErlangBinary (BIN.fromInt lc_11 (toErl 256) 1 BIN.Big)
              in ErlangCons lcRet_12 ErlangEmptyList)
           words_3)
  in let
    tup_el_5 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_6 (toErl 256) 1 BIN.Big,
            BIN.binPrefix bin_el_8 (BIN.packedSize bin_el_8) 8])
  in ErlangTuple [address_1, tup_el_5]
erlps__to_binary1__2 [(ErlangAtom "none"), address_0] =
  let    tup_el_3 = toErl 0
  in let
    arg_1 =
      ErlangTuple [ErlangAtom "variant", tup_el_3, ErlangEmptyList]
  in erlps__to_binary1__2 [arg_1, address_0]
erlps__to_binary1__2 [(ErlangTuple [(ErlangAtom "some"),
                                    value_0]),
                      address_1]
  =
  let    tup_el_4 = toErl 1
  in let
    arg_2 =
      ErlangTuple
        [ErlangAtom "variant", tup_el_4,
         ErlangCons value_0 ErlangEmptyList]
  in erlps__to_binary1__2 [arg_2, address_1]
erlps__to_binary1__2 [(ErlangAtom "word"), address_0] =
  let    tup_el_2 = toErl 0
  in let arg_1 = ErlangTuple [tup_el_2]
  in erlps__to_binary1__2 [arg_1, address_0]
erlps__to_binary1__2 [(ErlangAtom "string"), address_0] =
  let    tup_el_2 = toErl 1
  in let arg_1 = ErlangTuple [tup_el_2]
  in erlps__to_binary1__2 [arg_1, address_0]
erlps__to_binary1__2 [(ErlangAtom "typerep"), address_0] =
  let    tup_el_2 = toErl 5
  in let arg_1 = ErlangTuple [tup_el_2]
  in erlps__to_binary1__2 [arg_1, address_0]
erlps__to_binary1__2 [(ErlangAtom "contract_bytearray"),
                      address_0]
  =
  let    tup_el_2 = toErl 8
  in let arg_1 = ErlangTuple [tup_el_2]
  in erlps__to_binary1__2 [arg_1, address_0]
erlps__to_binary1__2 [(ErlangAtom "function"), address_0] =
  let    tup_el_2 = toErl 7
  in let arg_1 = ErlangTuple [tup_el_2]
  in erlps__to_binary1__2 [arg_1, address_0]
erlps__to_binary1__2 [(ErlangTuple [(ErlangAtom "list"), t_0]),
                      address_1]
  =
  let    tup_el_3 = toErl 2
  in let arg_2 = ErlangTuple [tup_el_3, t_0]
  in erlps__to_binary1__2 [arg_2, address_1]
erlps__to_binary1__2 [(ErlangTuple [(ErlangAtom "option"), t_0]),
                      address_1]
  =
  let
    arg_2 =
      ErlangTuple
        [ErlangAtom "variant",
         ErlangCons ErlangEmptyList
           (ErlangCons (ErlangCons t_0 ErlangEmptyList) ErlangEmptyList)]
  in erlps__to_binary1__2 [arg_2, address_1]
erlps__to_binary1__2 [(ErlangTuple [(ErlangAtom "tuple"), ts_0]),
                      address_1]
  =
  let    tup_el_3 = toErl 3
  in let arg_2 = ErlangTuple [tup_el_3, ts_0]
  in erlps__to_binary1__2 [arg_2, address_1]
erlps__to_binary1__2 [(ErlangTuple [(ErlangAtom "variant"),
                                    cons_0]),
                      address_1]
  =
  let    tup_el_3 = toErl 4
  in let arg_2 = ErlangTuple [tup_el_3, cons_0]
  in erlps__to_binary1__2 [arg_2, address_1]
erlps__to_binary1__2 [(ErlangTuple [(ErlangAtom "map"), k_0,
                                    v_1]),
                      address_2]
  =
  let    tup_el_4 = toErl 6
  in let arg_3 = ErlangTuple [tup_el_4, k_0, v_1]
  in erlps__to_binary1__2 [arg_3, address_2]
erlps__to_binary1__2 [(ErlangTuple [(ErlangAtom "variant"),
                                    tag_0, args_1]),
                      address_2]
  =
  let
    arg_3 = BIF.erlang__list_to_tuple__1 [ErlangCons tag_0 args_1]
  in erlps__to_binary1__2 [arg_3, address_2]
erlps__to_binary1__2 [map_0, address_1] | isEMap map_0 =
  let   
    size_3 = BIF.do_remote_fun_call "Maps" "erlps__size__1" [map_0]
  in let lcSrc_5 = BIF.maps__to_list__1 [map_0]
  in let
    arg_4 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [k_7, v_8]) ->
               let    tup_el_11 = erlps__to_binary__1 [k_7]
               in let tup_el_13 = erlps__to_binary__1 [v_8]
               in let lcRet_10 = ErlangTuple [tup_el_11, tup_el_13]
               in ErlangCons lcRet_10 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_5
  in let
    kvs_15 = BIF.do_remote_fun_call "Lists" "erlps__sort__1" [arg_4]
  in let
    bin_el_19 =
      BIN.concatErl
        (flmap
           (\ lc_23 ->
              case lc_23 of
                (ErlangTuple [k_21, v_22]) ->
                  let    bin_el_25 = BIF.erlang__byte_size__1 [k_21]
                  in let bin_el_28 = BIF.erlang__byte_size__1 [v_22]
                  in let
                    lcRet_24 =
                      ErlangBinary
                        (BIN.concat
                           [BIN.fromInt bin_el_25 (toErl 256) 1 BIN.Big,
                            BIN.binPrefix k_21 (BIN.packedSize k_21) 8,
                            BIN.fromInt bin_el_28 (toErl 256) 1 BIN.Big,
                            BIN.binPrefix v_22 (BIN.packedSize v_22) 8])
                  in ErlangCons lcRet_24 ErlangEmptyList
                _ -> ErlangEmptyList)
           kvs_15)
  in let
    tup_el_17 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt size_3 (toErl 256) 1 BIN.Big,
            BIN.binPrefix bin_el_19 (BIN.packedSize bin_el_19) 8])
  in ErlangTuple [address_1, tup_el_17]
erlps__to_binary1__2 [(ErlangTuple []), _address_0] =
  let    tup_el_1 = toErl 0
  in let tup_el_2 = ErlangBinary (BIN.concat [])
  in ErlangTuple [tup_el_1, tup_el_2]
erlps__to_binary1__2 [data_0, address_1] | isETuple data_0 =
  let    arg_2 = BIF.erlang__tuple_to_list__1 [data_0]
  in let lop_7 = toErl 32
  in let rop_8 = BIF.erlang__size__1 [data_0]
  in let rop_6 = BIF.erlang__op_mult [lop_7, rop_8]
  in let arg_4 = BIF.erlang__op_plus [address_1, rop_6]
  in let matchExpr_12 = erlps__to_binaries__2 [arg_2, arg_4]
  in
    case matchExpr_12 of
      (ErlangTuple [elems_10, memory_11]) ->
        let   
          elemsbin_18 =
            BIN.concatErl
              (flmap
                 (\ lc_15 ->
                    let
                      lcRet_16 =
                        ErlangBinary (BIN.fromInt lc_15 (toErl 256) 1 BIN.Big)
                    in ErlangCons lcRet_16 ErlangEmptyList)
                 elems_10)
        in let
          tup_el_20 =
            ErlangBinary
              (BIN.concat
                 [BIN.binPrefix elemsbin_18 (BIN.packedSize elemsbin_18) 8,
                  BIN.binPrefix memory_11 (BIN.packedSize memory_11) 8])
        in ErlangTuple [address_1, tup_el_20]
      _ -> EXC.badmatch matchExpr_12
erlps__to_binary1__2 [(ErlangEmptyList), _address_0] =
  let    op_arg_2 = toErl 1
  in let bin_el_1 = BIF.erlang__op_neg [op_arg_2]
  in let
    matchExpr_7 =
      ErlangBinary (BIN.fromInt bin_el_1 (toErl 256) 1 BIN.Big)
  in
    case matchExpr_7 of
      (ErlangBinary binSeg_3) | (ErlangInt size_4) <- (toErl 256)
                              , (BIN.Ok nil_6 bin_5) <-
                                  (BIN.chopInt binSeg_3 size_4 1 BIN.Big
                                     BIN.Unsigned)
                              , BIN.empty bin_5 ->
        let tup_el_9 = ErlangBinary (BIN.concat [])
        in ErlangTuple [nil_6, tup_el_9]
      _ -> EXC.badmatch matchExpr_7
erlps__to_binary1__2 [(ErlangCons h_0 t_1), address_2] =
  let arg_3 = ErlangTuple [h_0, t_1]
  in erlps__to_binary1__2 [arg_3, address_2]
erlps__to_binary1__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__to_binary1__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_binaries__2 :: ErlangFun
erlps__to_binaries__2 [(ErlangEmptyList), _address_0] =
  let tup_el_2 = ErlangBinary (BIN.concat [])
  in ErlangTuple [ErlangEmptyList, tup_el_2]
erlps__to_binaries__2 [(ErlangCons h_0 t_1), address_2] =
  let matchExpr_7 = erlps__to_binary1__2 [h_0, address_2]
  in
    case matchExpr_7 of
      (ErlangTuple [hrep_5, hmem_6]) ->
        let    rop_11 = BIF.erlang__size__1 [hmem_6]
        in let arg_9 = BIF.erlang__op_plus [address_2, rop_11]
        in let matchExpr_15 = erlps__to_binaries__2 [t_1, arg_9]
        in
          case matchExpr_15 of
            (ErlangTuple [trep_13, tmem_14]) ->
              let
                tup_el_19 =
                  ErlangBinary
                    (BIN.concat
                       [BIN.binPrefix hmem_6 (BIN.packedSize hmem_6) 8,
                        BIN.binPrefix tmem_14 (BIN.packedSize tmem_14) 8])
              in ErlangTuple [ErlangCons hrep_5 trep_13, tup_el_19]
            _ -> EXC.badmatch matchExpr_15
      _ -> EXC.badmatch matchExpr_7
erlps__to_binaries__2 [arg_22, arg_23] = EXC.function_clause unit
erlps__to_binaries__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__from_heap__3 :: ErlangFun
erlps__from_heap__3 [type_0, heap_1, ptr_2] =
  EXC.tryCatch
    (\ _ ->
       let    arg_5 = ErlangMap Map.empty
       in let
         tup_el_4 = erlps__from_binary__4 [arg_5, type_0, heap_1, ptr_2]
       in ErlangTuple [ErlangAtom "ok", tup_el_4])
    (\ ex_10 ->
       case ex_10 of
         (ErlangTuple [_, err_12, _]) ->
           ErlangTuple [ErlangAtom "error", err_12]
         ex_11 -> EXC.raise ex_11)
erlps__from_heap__3 [arg_15, arg_16, arg_17] =
  EXC.function_clause unit
erlps__from_heap__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__from_binary__3 :: ErlangFun
erlps__from_binary__3 [t_0, heap_5@(ErlangBinary binSeg_1),
                       baseaddr_6]
  | (ErlangInt size_2) <- (toErl 256)
  , (BIN.Ok v_4 bin_3) <-
      (BIN.chopInt binSeg_1 size_2 1 BIN.Big BIN.Unsigned) =
  let    bin_el_9 = toErl 0
  in let
    arg_8 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_9 baseaddr_6 8 BIN.Big,
            BIN.binPrefix heap_5 (BIN.packedSize heap_5) 8])
  in erlps__from_heap__3 [t_0, arg_8, v_4]
erlps__from_binary__3 [_, bin_0, _baseaddr_1] =
  let tup_el_3 = ErlangTuple [ErlangAtom "binary_too_short", bin_0]
  in ErlangTuple [ErlangAtom "error", tup_el_3]
erlps__from_binary__3 [arg_6, arg_7, arg_8] =
  EXC.function_clause unit
erlps__from_binary__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__from_binary__2 :: ErlangFun
erlps__from_binary__2 [t_0, heap_1] =
  let arg_4 = toErl 0
  in erlps__from_binary__3 [t_0, heap_1, arg_4]
erlps__from_binary__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__from_binary__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__from_binary__4 :: ErlangFun
erlps__from_binary__4 [_, (ErlangAtom "word"), _, v_0] = v_0
erlps__from_binary__4 [_, (ErlangAtom "signed_word"), _, v_0] =
  let
    matchExpr_6 =
      ErlangBinary (BIN.fromInt v_0 (toErl 256) 1 BIN.Big)
  in
    case matchExpr_6 of
      (ErlangBinary binSeg_2) | (ErlangInt size_3) <- (toErl 256)
                              , (BIN.Ok n_5 bin_4) <-
                                  (BIN.chopInt binSeg_2 size_3 1 BIN.Big
                                     BIN.Signed)
                              , BIN.empty bin_4 ->
        n_5
      _ -> EXC.badmatch matchExpr_6
erlps__from_binary__4 [_, (ErlangAtom "bool"), _, v_0] =
  case v_0 of
    (ErlangInt num_2) | (ErlangInt num_2) == (toErl 0) ->
      ErlangAtom "false"
    (ErlangInt num_3) | (ErlangInt num_3) == (toErl 1) ->
      ErlangAtom "true"
    something_else -> EXC.case_clause something_else
erlps__from_binary__4 [_, (ErlangAtom "string"), heap_0, v_1] =
  let    stringsize_4 = erlps__heap_word__2 [heap_0, v_1]
  in let lop_5 = toErl 8
  in let rop_8 = toErl 32
  in let rop_6 = BIF.erlang__op_plus [v_1, rop_8]
  in let bitaddr_9 = BIF.erlang__op_mult [lop_5, rop_6]
  in
    case heap_0 of
      (ErlangBinary binSeg_10) | (ErlangInt size_11) <- (bitaddr_9)
                               , (BIN.Ok _ bin_12) <-
                                   (BIN.chopInt binSeg_10 size_11 1 BIN.Big
                                      BIN.Unsigned)
                               , (ErlangInt size_13) <- (stringsize_4)
                               , (BIN.Ok bytes_15 bin_14) <-
                                   (BIN.chopBin bin_12 size_13 8) ->
        bytes_15
      _ -> EXC.badmatch heap_0
erlps__from_binary__4 [_,
                       (ErlangTuple [(ErlangAtom "tuple"), (ErlangEmptyList)]),
                       _, _]
  =
  ErlangTuple []
erlps__from_binary__4 [visited_0,
                       (ErlangTuple [(ErlangAtom "tuple"), cpts_1]), heap_2,
                       v_3]
  =
  let    _ = erlps__check_circular_refs__2 [visited_0, v_3]
  in let
    mapExt_9 = ErlangMap (Map.singleton v_3 (ErlangAtom "true"))
  in let newvisited_11 = BIF.maps__merge__2 [visited_0, mapExt_9]
  in let arg_12 = toErl 0
  in let lop_14 = BIF.erlang__length__1 [cpts_1]
  in let rop_16 = toErl 1
  in let arg_13 = BIF.erlang__op_minus [lop_14, rop_16]
  in let
    elementnums_17 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_12, arg_13]
  in let
    typesandpointers_20 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2"
        [cpts_1, elementnums_17]
  in let
    elementaddress_28 =
      ErlangFun 1
        (let
           lambda_21 [index_23] =
             let    lop_26 = toErl 32
             in let rop_25 = BIF.erlang__op_mult [lop_26, index_23]
             in BIF.erlang__op_plus [v_3, rop_25]
           lambda_21 [arg_22] = EXC.function_clause unit
           lambda_21 args = EXC.badarity (ErlangFun 1 lambda_21) args
         in lambda_21)
  in let
    element_36 =
      ErlangFun 1
        (let
           lambda_29 [index_31] =
             let
               arg_33 =
                 BIF.erlang__apply__2
                   [elementaddress_28, ErlangCons index_31 ErlangEmptyList]
             in erlps__heap_word__2 [heap_2, arg_33]
           lambda_29 [arg_30] = EXC.function_clause unit
           lambda_29 args = EXC.badarity (ErlangFun 1 lambda_29) args
         in lambda_29)
  in let
    convert_48 =
      ErlangFun 2
        (let
           lambda_37 [type_40, index_41] =
             let
               arg_45 =
                 BIF.erlang__apply__2
                   [element_36, ErlangCons index_41 ErlangEmptyList]
             in erlps__from_binary__4 [newvisited_11, type_40, heap_2, arg_45]
           lambda_37 [arg_38, arg_39] = EXC.function_clause unit
           lambda_37 args = EXC.badarity (ErlangFun 2 lambda_37) args
         in lambda_37)
  in let
    elements_57 =
      flmap
        (\ lc_52 ->
           case lc_52 of
             (ErlangTuple [t_50, i_51]) ->
               let
                 lcRet_53 =
                   BIF.erlang__apply__2
                     [convert_48,
                      ErlangCons t_50 (ErlangCons i_51 ErlangEmptyList)]
               in ErlangCons lcRet_53 ErlangEmptyList
             _ -> ErlangEmptyList)
        typesandpointers_20
  in BIF.erlang__list_to_tuple__1 [elements_57]
erlps__from_binary__4 [visited_0,
                       (ErlangTuple [(ErlangAtom "list"), elem_1]), heap_2, v_3]
  =
  let    op_arg_5 = toErl 1
  in let bin_el_4 = BIF.erlang__op_neg [op_arg_5]
  in let
    matchExpr_10 =
      ErlangBinary (BIN.fromInt bin_el_4 (toErl 256) 1 BIN.Big)
  in
    case matchExpr_10 of
      (ErlangBinary binSeg_6) | (ErlangInt size_7) <- (toErl 256)
                              , (BIN.Ok nil_9 bin_8) <-
                                  (BIN.chopInt binSeg_6 size_7 1 BIN.Big
                                     BIN.Unsigned)
                              , BIN.empty bin_8 ->
        case ErlangAtom "true" of
          _ | weakEq v_3 nil_9 -> ErlangEmptyList
          _ ->
            let    head_17 = ErlangTuple [ErlangAtom "list", elem_1]
            in let
              arg_12 =
                ErlangTuple
                  [ErlangAtom "tuple",
                   ErlangCons elem_1 (ErlangCons head_17 ErlangEmptyList)]
            in let
              matchExpr_25 =
                erlps__from_binary__4 [visited_0, arg_12, heap_2, v_3]
            in
              case matchExpr_25 of
                (ErlangTuple [h_23, t_24]) -> ErlangCons h_23 t_24
                _ -> EXC.badmatch matchExpr_25
      _ -> EXC.badmatch matchExpr_10
erlps__from_binary__4 [visited_0,
                       (ErlangTuple [(ErlangAtom "option"), a_1]), heap_2, v_3]
  =
  let    head_8 = ErlangTuple [ErlangAtom "none", ErlangEmptyList]
  in let
    head_12 =
      ErlangTuple [ErlangAtom "some", ErlangCons a_1 ErlangEmptyList]
  in let
    arg_5 =
      ErlangTuple
        [ErlangAtom "variant_t",
         ErlangCons head_8 (ErlangCons head_12 ErlangEmptyList)]
  in erlps__from_binary__4 [visited_0, arg_5, heap_2, v_3]
erlps__from_binary__4 [visited_0,
                       (ErlangTuple [(ErlangAtom "variant"), cons_1]), heap_2,
                       v_3]
  =
  let    tag_6 = erlps__heap_word__2 [heap_2, v_3]
  in let rop_9 = toErl 1
  in let arg_7 = BIF.erlang__op_plus [tag_6, rop_9]
  in let
    args_11 =
      BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_7, cons_1]
  in let
    mapExt_15 = ErlangMap (Map.singleton v_3 (ErlangAtom "true"))
  in let visited1_17 = BIF.maps__merge__2 [visited_0, mapExt_15]
  in let arg_23 = ErlangTuple [ErlangAtom "tuple", args_11]
  in let rop_29 = toErl 32
  in let arg_27 = BIF.erlang__op_plus [v_3, rop_29]
  in let
    arg_21 =
      erlps__from_binary__4 [visited1_17, arg_23, heap_2, arg_27]
  in let tup_el_20 = BIF.erlang__tuple_to_list__1 [arg_21]
  in ErlangTuple [ErlangAtom "variant", tag_6, tup_el_20]
erlps__from_binary__4 [visited_0,
                       (ErlangTuple [(ErlangAtom "variant_t"), tcons_1]),
                       heap_2, v_3]
  =
  let
    matchExpr_7 =
      BIF.do_remote_fun_call "Lists" "erlps__unzip__1" [tcons_1]
  in
    case matchExpr_7 of
      (ErlangTuple [tags_5, cons_6]) ->
        let    arg_9 = ErlangTuple [ErlangAtom "variant", cons_6]
        in let
          matchExpr_16 =
            erlps__from_binary__4 [visited_0, arg_9, heap_2, v_3]
        in
          case matchExpr_16 of
            (ErlangTuple [(ErlangAtom "variant"), i_14, args_15]) ->
              let    rop_19 = toErl 1
              in let arg_17 = BIF.erlang__op_plus [i_14, rop_19]
              in let
                tag_21 =
                  BIF.do_remote_fun_call "Lists" "erlps__nth__2"
                    [arg_17, tags_5]
              in
                case args_15 of
                  (ErlangEmptyList) -> tag_21
                  _ -> BIF.erlang__list_to_tuple__1 [ErlangCons tag_21 args_15]
            _ -> EXC.badmatch matchExpr_16
      _ -> EXC.badmatch matchExpr_7
erlps__from_binary__4 [_visited_0,
                       (ErlangTuple [(ErlangAtom "map"), a_1, b_2]), heap_3,
                       ptr_4]
  =
  let    size_7 = erlps__heap_word__2 [heap_3, ptr_4]
  in let rop_14 = toErl 32
  in let arg_12 = BIF.erlang__op_plus [ptr_4, rop_14]
  in
    erlps__map_binary_to_value__5 [a_1, b_2, size_7, heap_3, arg_12]
erlps__from_binary__4 [visited_0, (ErlangAtom "typerep"), heap_1,
                       v_2]
  =
  let    _ = erlps__check_circular_refs__2 [visited_0, v_2]
  in let tag_7 = erlps__heap_word__2 [heap_1, v_2]
  in let
    arg1_28 =
      ErlangFun 2
        (let
           lambda_8 [t_11, i_12] =
             let   
               mapExt_17 = ErlangMap (Map.singleton v_2 (ErlangAtom "true"))
             in let arg_13 = BIF.maps__merge__2 [visited_0, mapExt_17]
             in let lop_26 = toErl 32
             in let rop_25 = BIF.erlang__op_mult [lop_26, i_12]
             in let arg_23 = BIF.erlang__op_plus [v_2, rop_25]
             in let arg_21 = erlps__heap_word__2 [heap_1, arg_23]
             in erlps__from_binary__4 [arg_13, t_11, heap_1, arg_21]
           lambda_8 [arg_9, arg_10] = EXC.function_clause unit
           lambda_8 args = EXC.badarity (ErlangFun 2 lambda_8) args
         in lambda_8)
  in let
    arg_35 =
      ErlangFun 1
        (let
           lambda_29 [t_31] =
             let arg_33 = toErl 1
             in
               BIF.erlang__apply__2
                 [arg1_28, ErlangCons t_31 (ErlangCons arg_33 ErlangEmptyList)]
           lambda_29 [arg_30] = EXC.function_clause unit
           lambda_29 args = EXC.badarity (ErlangFun 1 lambda_29) args
         in lambda_29)
  in
    case tag_7 of
      (ErlangInt num_37) | (ErlangInt num_37) == (toErl 0) ->
        ErlangAtom "word"
      (ErlangInt num_38) | (ErlangInt num_38) == (toErl 1) ->
        ErlangAtom "string"
      (ErlangInt num_39) | (ErlangInt num_39) == (toErl 5) ->
        ErlangAtom "typerep"
      (ErlangInt num_40) | (ErlangInt num_40) == (toErl 2) ->
        let
          tup_el_42 =
            BIF.erlang__apply__2
              [arg_35, ErlangCons (ErlangAtom "typerep") ErlangEmptyList]
        in ErlangTuple [ErlangAtom "list", tup_el_42]
      (ErlangInt num_45) | (ErlangInt num_45) == (toErl 3) ->
        let   
          arg_48 = ErlangTuple [ErlangAtom "list", ErlangAtom "typerep"]
        in let
          tup_el_47 =
            BIF.erlang__apply__2 [arg_35, ErlangCons arg_48 ErlangEmptyList]
        in ErlangTuple [ErlangAtom "tuple", tup_el_47]
      (ErlangInt num_52) | (ErlangInt num_52) == (toErl 4) ->
        let   
          tup_el_57 = ErlangTuple [ErlangAtom "list", ErlangAtom "typerep"]
        in let arg_55 = ErlangTuple [ErlangAtom "list", tup_el_57]
        in let
          tup_el_54 =
            BIF.erlang__apply__2 [arg_35, ErlangCons arg_55 ErlangEmptyList]
        in ErlangTuple [ErlangAtom "variant", tup_el_54]
      (ErlangInt num_61) | (ErlangInt num_61) == (toErl 6) ->
        let   
          tup_el_63 =
            BIF.erlang__apply__2
              [arg_35, ErlangCons (ErlangAtom "typerep") ErlangEmptyList]
        in let arg_68 = toErl 2
        in let
          tup_el_66 =
            BIF.erlang__apply__2
              [arg1_28,
               ErlangCons (ErlangAtom "typerep")
                 (ErlangCons arg_68 ErlangEmptyList)]
        in ErlangTuple [ErlangAtom "map", tup_el_63, tup_el_66]
      (ErlangInt num_70) | (ErlangInt num_70) == (toErl 7) ->
        ErlangAtom "function"
      (ErlangInt num_71) | (ErlangInt num_71) == (toErl 8) ->
        ErlangAtom "contract_bytearray"
      something_else -> EXC.case_clause something_else
erlps__from_binary__4 [_, (ErlangAtom "contract_bytearray"),
                       heap_0, v_1]
  =
  let    fatecodesize_4 = erlps__heap_word__2 [heap_0, v_1]
  in let lop_5 = toErl 8
  in let rop_8 = toErl 32
  in let rop_6 = BIF.erlang__op_plus [v_1, rop_8]
  in let bitaddr_9 = BIF.erlang__op_mult [lop_5, rop_6]
  in
    case heap_0 of
      (ErlangBinary binSeg_10) | (ErlangInt size_11) <- (bitaddr_9)
                               , (BIN.Ok _ bin_12) <-
                                   (BIN.chopInt binSeg_10 size_11 1 BIN.Big
                                      BIN.Unsigned)
                               , (ErlangInt size_13) <- (fatecodesize_4)
                               , (BIN.Ok bytes_15 bin_14) <-
                                   (BIN.chopBin bin_12 size_13 8) ->
        ErlangTuple [ErlangAtom "contract_bytearray", bytes_15]
      _ -> EXC.badmatch heap_0
erlps__from_binary__4 [arg_19, arg_20, arg_21, arg_22] =
  EXC.function_clause unit
erlps__from_binary__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__map_binary_to_value__5 :: ErlangFun
erlps__map_binary_to_value__5 [keytype_0, valtype_1, n_2, bin_3,
                               ptr_4]
  =
  let    lop_5 = BIF.erlang__byte_size__1 [bin_3]
  in let rop_7 = toErl 64
  in let maxn_8 = BIF.erlang__op_div_strict [lop_5, rop_7]
  in let heap_10 = erlps__heap_fragment__1 [bin_3]
  in let
    arg_11 = ErlangTuple [ErlangAtom "value", keytype_0, valtype_1]
  in let arg_15 = BIF.erlang__min__2 [n_2, maxn_8]
  in let arg_20 = ErlangMap Map.empty
  in
    erlps__map_from_binary__5
      [arg_11, arg_15, heap_10, ptr_4, arg_20]
erlps__map_binary_to_value__5 [arg_21, arg_22, arg_23, arg_24,
                               arg_25]
  =
  EXC.function_clause unit
erlps__map_binary_to_value__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__map_from_binary__5 :: ErlangFun
erlps__map_from_binary__5 [_, (ErlangInt num_0), _, _, map_1]
  | (ErlangInt num_0) == (toErl 0) =
  map_1
erlps__map_from_binary__5 [output_2@(ErlangTuple [(ErlangAtom "value"),
                                                  keytype_0, valtype_1]),
                           i_3, heap_4, ptr_5, map_6]
  =
  let    keysize_9 = erlps__get_word__2 [heap_4, ptr_5]
  in let rop_11 = toErl 32
  in let keyptr_12 = BIF.erlang__op_plus [ptr_5, rop_11]
  in let
    keybin_16 = erlps__get_chunk__3 [heap_4, keyptr_12, keysize_9]
  in let arg_18 = BIF.erlang__op_plus [keyptr_12, keysize_9]
  in let valsize_21 = erlps__get_word__2 [heap_4, arg_18]
  in let lop_22 = BIF.erlang__op_plus [keyptr_12, keysize_9]
  in let rop_25 = toErl 32
  in let valptr_26 = BIF.erlang__op_plus [lop_22, rop_25]
  in let
    valbin_30 = erlps__get_chunk__3 [heap_4, valptr_26, valsize_21]
  in let
    matchExpr_34 = erlps__from_binary__2 [keytype_0, keybin_16]
  in
    case matchExpr_34 of
      (ErlangTuple [(ErlangAtom "ok"), key_33]) ->
        let matchExpr_38 = erlps__from_binary__2 [valtype_1, valbin_30]
        in
          case matchExpr_38 of
            (ErlangTuple [(ErlangAtom "ok"), val_37]) ->
              let    rop_42 = toErl 1
              in let arg_40 = BIF.erlang__op_minus [i_3, rop_42]
              in let arg_44 = BIF.erlang__op_plus [valptr_26, valsize_21]
              in let mapExt_51 = ErlangMap (Map.singleton key_33 val_37)
              in let arg_47 = BIF.maps__merge__2 [map_6, mapExt_51]
              in
                erlps__map_from_binary__5
                  [output_2, arg_40, heap_4, arg_44, arg_47]
            _ -> EXC.badmatch matchExpr_38
      _ -> EXC.badmatch matchExpr_34
erlps__map_from_binary__5 [arg_53, arg_54, arg_55, arg_56,
                           arg_57]
  =
  EXC.function_clause unit
erlps__map_from_binary__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__check_circular_refs__2 :: ErlangFun
erlps__check_circular_refs__2 [visited_0, v_1] =
  let case_2 = BIF.maps__is_key__2 [v_1, visited_0]
  in
    case case_2 of
      (ErlangAtom "true") ->
        BIF.erlang__exit__1 [ErlangAtom "circular_references"]
      (ErlangAtom "false") -> ErlangAtom "ok"
      something_else -> EXC.case_clause something_else
erlps__check_circular_refs__2 [arg_6, arg_7] =
  EXC.function_clause unit
erlps__check_circular_refs__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__heap_word__2 :: ErlangFun
erlps__heap_word__2 [heap_0, addr_1]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [heap_0])) =
  let    lop_2 = toErl 8
  in let bitsize_4 = BIF.erlang__op_mult [lop_2, addr_1]
  in
    case heap_0 of
      (ErlangBinary binSeg_5) | (ErlangInt size_6) <- (bitsize_4)
                              , (BIN.Ok _ bin_7) <-
                                  (BIN.chopInt binSeg_5 size_6 1 BIN.Big
                                     BIN.Unsigned)
                              , (ErlangInt size_8) <- (toErl 256)
                              , (BIN.Ok w_10 bin_9) <-
                                  (BIN.chopInt bin_7 size_8 1 BIN.Big
                                     BIN.Unsigned) ->
        w_10
      _ -> EXC.badmatch heap_0
erlps__heap_word__2 [heap_0, addr_1] | isEMap heap_0 =
  let    rop_3 = toErl 32
  in let matchExpr_5 = BIF.erlang__op_rem_strict [addr_1, rop_3]
  in
    case matchExpr_5 of
      (ErlangInt num_4) | (ErlangInt num_4) == (toErl 0) ->
        let arg_8 = toErl 0
        in
          BIF.do_remote_fun_call "Maps" "erlps__get__3"
            [addr_1, heap_0, arg_8]
      _ -> EXC.badmatch matchExpr_5
erlps__heap_word__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__heap_word__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_word__2 :: ErlangFun
erlps__get_word__2 [(ErlangTuple [(ErlangAtom "heap"), _, offs_0,
                                  mem_1]),
                    addr_2]
  | weakGeq addr_2 offs_0 =
  let arg_4 = BIF.erlang__op_minus [addr_2, offs_0]
  in erlps__get_word__2 [mem_1, arg_4]
erlps__get_word__2 [mem_0, addr_1]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [mem_0])) =
  case mem_0 of
    (ErlangBinary binSeg_2) | (ErlangInt size_3) <- (addr_1)
                            , (BIN.Ok _ bin_4) <-
                                (BIN.chopInt binSeg_2 size_3 8 BIN.Big
                                   BIN.Unsigned)
                            , (ErlangInt size_5) <- (toErl 256)
                            , (BIN.Ok word_7 bin_6) <-
                                (BIN.chopInt bin_4 size_5 1 BIN.Big
                                   BIN.Unsigned) ->
      word_7
    _ -> EXC.badmatch mem_0
erlps__get_word__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__get_word__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_chunk__3 :: ErlangFun
erlps__get_chunk__3 [(ErlangTuple [(ErlangAtom "heap"), _,
                                   offs_0, mem_1]),
                     addr_2, bytes_3]
  | weakGeq addr_2 offs_0 =
  let arg_5 = BIF.erlang__op_minus [addr_2, offs_0]
  in erlps__get_chunk__3 [mem_1, arg_5, bytes_3]
erlps__get_chunk__3 [mem_0, addr_1, bytes_2]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [mem_0])) =
  case mem_0 of
    (ErlangBinary binSeg_3) | (ErlangInt size_4) <- (addr_1)
                            , (BIN.Ok _ bin_5) <-
                                (BIN.chopInt binSeg_3 size_4 8 BIN.Big
                                   BIN.Unsigned)
                            , (ErlangInt size_6) <- (bytes_2)
                            , (BIN.Ok chunk_8 bin_7) <-
                                (BIN.chopBin bin_5 size_6 8) ->
      chunk_8
    _ -> EXC.badmatch mem_0
erlps__get_chunk__3 [arg_11, arg_12, arg_13] =
  EXC.function_clause unit
erlps__get_chunk__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args