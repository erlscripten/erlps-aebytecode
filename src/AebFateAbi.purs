module Aeb.Fate.Abi(erlps__create_calldata__2,
                    erlps__decode_calldata__2,
                    erlps__get_function_hash_from_calldata__1,
                    erlps__get_function_name_from_function_hash__2,
                    erlps__get_function_type_from_function_hash__2,
                    erlps__abi_version__0) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.0.2
-}

import Prelude
import Data.Array as DA
import Data.List as DL
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as Tup
import Data.BigInt as DBI
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type (ErlangFun, ErlangTerm(..), weakCmp, weakEq,
                    weakNEq, weakLt, weakLeq, weakGeq, weakGt)
import Effect (Effect)
import Effect.Unsafe (unsafePerformEffect)
import Effect.Exception (throw)
import Partial.Unsafe (unsafePartial)


erlps__abi_version__0 :: ErlangFun
erlps__abi_version__0 [] = (ErlangInt (DBI.fromInt 3))
erlps__abi_version__0 args =
  (EXC.badarity
     (ErlangFun 0 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__create_calldata__2 :: ErlangFun
erlps__create_calldata__2 [funname_0, args_1] =
  let    arg_2 = (BIF.erlang__list_to_binary__1 [funname_0])
  in let
    functionid_4 =
      (BIF.do_remote_fun_call "Aeb.Fate.Code"
         "erlps__symbol_identifier__1" [arg_2])
  in let arg_11 = (BIF.erlang__list_to_tuple__1 [args_1])
  in let
    tup_el_10 =
      (BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_tuple__1"
         [arg_11])
  in let arg_8 = (ErlangTuple [functionid_4, tup_el_10])
  in let
    arg_7 =
      (BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_tuple__1"
         [arg_8])
  in let
    tup_el_6 =
      (BIF.do_remote_fun_call "Aeb.Fate.Encoding" "erlps__serialize__1"
         [arg_7])
  in (ErlangTuple [(ErlangAtom "ok"), tup_el_6])
erlps__create_calldata__2 [arg_13, arg_14] =
  (EXC.function_clause unit)
erlps__create_calldata__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__decode_calldata__2 :: ErlangFun
erlps__decode_calldata__2 [funname_0, calldata_1] =
  let    arg_2 = (BIF.erlang__list_to_binary__1 [funname_0])
  in let
    functionid_4 =
      (BIF.do_remote_fun_call "Aeb.Fate.Code"
         "erlps__symbol_identifier__1" [arg_2])
  in
    (EXC.tryOfCatch
       (\ _ ->
          let   
            arg_7 =
              (BIF.do_remote_fun_call "Aeb.Fate.Encoding"
                 "erlps__deserialize__1" [calldata_1])
          in let
            arg_5 =
              (BIF.erlang__element__2 [(ErlangInt (DBI.fromInt 2)), arg_7])
          in (BIF.erlang__tuple_to_list__1 [arg_5]))
       (\ of_9 ->
          case of_9 of
            (ErlangCons functionid_11 (ErlangCons fateargs_12 (ErlangEmptyList))) | (functionid_11 ==
                                                                                       functionid_4) ->
              let   
                arg_15 =
                  (BIF.erlang__element__2
                     [(ErlangInt (DBI.fromInt 2)), fateargs_12])
              in let tup_el_14 = (BIF.erlang__tuple_to_list__1 [arg_15])
              in (ErlangTuple [(ErlangAtom "ok"), tup_el_14])
            _ ->
              (ErlangTuple [(ErlangAtom "error"), (ErlangAtom "decode_error")])
            something_else -> (EXC.try_clause something_else))
       (\ ex_10 ->
          case ex_10 of
            (ErlangTuple [_, _, _]) ->
              (ErlangTuple [(ErlangAtom "error"), (ErlangAtom "decode_error")])
            ex_10 -> (EXC.raise ex_10)))
erlps__decode_calldata__2 [arg_22, arg_23] =
  (EXC.function_clause unit)
erlps__decode_calldata__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__get_function_name_from_function_hash__2 :: ErlangFun
erlps__get_function_name_from_function_hash__2 [(ErlangBinary bin_c_0),
                                                fatecode_6]
  | size_1 <- ((DBI.fromInt 4))
  , (BIN.Ok symbolhash_3 bin_2) <-
      ((BIN.chop_bin bin_c_0 size_1 8))
  , size_4 <- ((DBI.fromInt 28))
  , (BIN.Ok _ bin_5) <- ((BIN.chop_bin bin_2 size_4 8))
  , (BIN.empty bin_5) =
  (erlps__get_function_name_from_function_hash__2
     [symbolhash_3, fatecode_6])
erlps__get_function_name_from_function_hash__2 [symbolhash_3@(ErlangBinary bin_c_0),
                                                fatecode_4]
  | size_1 <- ((DBI.fromInt 4))
  , (BIN.Ok _ bin_2) <- ((BIN.chop_bin bin_c_0 size_1 8))
  , (BIN.empty bin_2) =
  let   
    symbols_6 =
      (BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__symbols__1"
         [fatecode_4])
  in let
    case_7 =
      (BIF.do_remote_fun_call "Maps" "erlps__get__3"
         [symbolhash_3, symbols_6, (ErlangAtom "undefined")])
  in
    case case_7 of
      (ErlangAtom "undefined") ->
        (ErlangTuple
           [(ErlangAtom "error"),
            (ErlangAtom "no_function_matching_function_hash")])
      function_13 -> (ErlangTuple [(ErlangAtom "ok"), function_13])
      something_else -> (EXC.case_clause something_else)
erlps__get_function_name_from_function_hash__2 [arg_16, arg_17] =
  (EXC.function_clause unit)
erlps__get_function_name_from_function_hash__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__get_function_hash_from_calldata__1 :: ErlangFun
erlps__get_function_hash_from_calldata__1 [calldata_0] =
  (EXC.tryOfCatch
     (\ _ ->
        let   
          arg_3 =
            (BIF.do_remote_fun_call "Aeb.Fate.Encoding"
               "erlps__deserialize__1" [calldata_0])
        in let
          arg_1 =
            (BIF.erlang__element__2 [(ErlangInt (DBI.fromInt 2)), arg_3])
        in (BIF.erlang__tuple_to_list__1 [arg_1]))
     (\ of_5 ->
        case of_5 of
          (ErlangCons funhash_7 (ErlangCons _args_8 (ErlangEmptyList))) ->
            (ErlangTuple [(ErlangAtom "ok"), funhash_7])
          _ ->
            (ErlangTuple [(ErlangAtom "error"), (ErlangAtom "bad_calldata")])
          something_else -> (EXC.try_clause something_else))
     (\ ex_6 ->
        case ex_6 of
          (ErlangTuple [_, _, _]) ->
            (ErlangTuple [(ErlangAtom "error"), (ErlangAtom "bad_calldata")])
          ex_6 -> (EXC.raise ex_6)))
erlps__get_function_hash_from_calldata__1 [arg_15] =
  (EXC.function_clause unit)
erlps__get_function_hash_from_calldata__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__get_function_type_from_function_hash__2 :: ErlangFun
erlps__get_function_type_from_function_hash__2 [(ErlangBinary bin_c_0),
                                                fatecode_6]
  | size_1 <- ((DBI.fromInt 4))
  , (BIN.Ok symbolhash_3 bin_2) <-
      ((BIN.chop_bin bin_c_0 size_1 8))
  , size_4 <- ((DBI.fromInt 28))
  , (BIN.Ok _ bin_5) <- ((BIN.chop_bin bin_2 size_4 8))
  , (BIN.empty bin_5) =
  (erlps__get_function_type_from_function_hash__2
     [symbolhash_3, fatecode_6])
erlps__get_function_type_from_function_hash__2 [symbolhash_0,
                                                fatecode_1]
  =
  let   
    functions_3 =
      (BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__functions__1"
         [fatecode_1])
  in let
    case_4 =
      (BIF.do_remote_fun_call "Maps" "erlps__get__3"
         [symbolhash_0, functions_3, (ErlangAtom "undefined")])
  in
    case case_4 of
      (ErlangAtom "undefined") ->
        (ErlangTuple
           [(ErlangAtom "error"),
            (ErlangAtom "no_function_matching_function_hash")])
      (ErlangTuple [_attrs_10, (ErlangTuple [argtypes_11, rettype_12]),
                    _code_13]) ->
        (ErlangTuple [(ErlangAtom "ok"), argtypes_11, rettype_12])
      something_else -> (EXC.case_clause something_else)
erlps__get_function_type_from_function_hash__2 [arg_17, arg_18] =
  (EXC.function_clause unit)
erlps__get_function_type_from_function_hash__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)